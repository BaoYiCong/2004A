#    一.JavaScript核心

核心（ECMAScript）

文档对象模型（DOM）

浏览器对象模型（BOM） 

# 二.DOM   

1.文档对象模型（DOM，Document Object Model），是一个应用编程接口（API），用于在HTML中使用扩展的XML。               

2.DOM Level 1中的DOM Core也被扩展以包含对XML命名空间的支持。

3.DOM Level 2新增了以下模块，以支持新的接口。

DOM视图：描述追踪文档不同视图（如应用CSS样式前后的

文档）的接口。

DOM事件：描述事件及事件处理的接口。

DOM样式：描述处理元素CSS样式的接口。

DOM遍历和范围：描述遍历和操作DOM树的接口。

4.其他DOM

除了DOM Core和DOM HTML接口，有些其他语言也发布了自己的DOM标准。

# 三.BOM

1.    IE3和Netscape Navigator 3提供了浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。使用BOM，开发者可以操控浏览器显示页面之外的部分。而BOM真正独一无二的地方，当然也是问题最多的地方，就是它是唯一一个没有相关标准的JavaScript实现。
2. BOM主要针对浏览器窗口和子窗口（frame），
3. 扩展

弹出新浏览器窗口的能力；移动、缩放和关闭浏览器窗口的能力；

navigator 对象，提供关于浏览器的详尽信息；

location 对象，提供浏览器加载页面的详尽信息；

screen 对象，提供关于用户屏幕分辨率的详尽信息；

performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；

对cookie的支持；

其他自定义对象，如 XMLHttpRequest 和IE的 ActiveXObject 。

# 四.**HTML**中的JavaScript

1.<script> 元素

async ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。

charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值

crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。 

defer ：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。

src ：可选。表示包含要执行的代码的外部文件。

type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。

2.  标签占位符

过去，所有 <script> 元素都被放在页面的 <head> 标签内，

```
<!DOCTYPE html> 

<html> 

<head> 

<title>Example HTML Page</title> 

<script src="example1.js"></script> 

<script src="example2.js"></script> 

</head> 

<body> 

<!--这里是页面内容-->

</body> 

</html>
```

不过这种方法会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。所以我们把标签放在 <body> 元素中的页面内容后面

```
<!DOCTYPE html> 

<html> 

<head> 

<title>Example HTML Page</title> 

</head> 

<body> 
<!--这里是页面内容-->

<script src="example1.js"></script> 

<script src="example2.js"></script> 

</body> 

</html>
```

3.推迟执行脚本

4. 异步执行脚本
5. 动态加载脚本
6. XHTML中的变化

#  五.语言基础

**.1** 语法

ECMAScript的语法很大程度上借鉴了C语言和其他类C语言，如Java和Perl。熟悉这些语言的开发者，应该很容易理解ECMAScript宽松的语法 

2. 区分大小写
3. 标识符
4. 注释
5. 严格模式
6. 语句
7. 关键字与保留字

break do in typeof  case else instanceof var  catch export new void  class extends return while  const finally super with  continue for switch yield  debugger function this  default if throw  delete import try 

8.  变量

有3个关键字可以声明变量： var 、 const 和 let 。其中， var 在ECMAScript的所有版本中都可以使用，而 const 和 let 只能在ECMAScript 6及更晚的版本中使用

9.数据类型

ECMAScript有6种简单数据类型（也称为原始类型）：Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。

10. typeof 操作符

"undefined" 表示值未定义；

"boolean" 表示值为布尔值；

"string" 表示值为字符串；

"number" 表示值为数值；

"object" 表示值为对象（而不是函数）或 null ； 

"function" 表示值为函数；

"symbol" 表示值为符号

### 操作符

ECMA-262描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。

1.一元操作符

2. 一元加和减

```
let num = 25; 

num = +num; 

console.log(num); // 25
```

3.位操作符

3.1   按位非

3.2 按位与

3.3  按位或

3.4 按位异或

3.5 左移

3.6 有符号右移

3.7 无符号右移

### 布尔值

1. 逻辑非
2. 逻辑与
3. 逻辑或

### 乘法操作符

1. 乘法操作符
2. 除法操作符
3. 取模操作符

### 指数操作符

ECMAScript 7新增了指数操作符， Math.pow() 现在有了自己

的操作符 ** ，结果是一样的：

```
console.log(Math.pow(3, 2); // 9

console.log(3 ** 2); // 9console.log(Math.pow(16, 0.5); // 4

console.log(16** 0.5); // 4
```

不仅如此，指数操作符也有自己的指数赋值操作符 **= ，该操

作符执行指数运算和结果的赋值操作：

```
let squared = 3; 

squared **= 2; 

console.log(squared); // 9

let sqrt = 16; 

sqrt **= 0.5; 

console.log(sqrt); // 4
```



### 加性操作符

1. 加法操作符

   加法操作符（ + ）用于求两个数的和，比如：

   let result = 1 + 2;

   如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：

   如果有任一操作数是 NaN ，则返回 NaN ；

   如果是 Infinity 加 Infinity ，则返回 Infinity ；

   如果是 -Infinity 加 -Infinity ，则返回 - Infinity ；

   如果是 Infinity 加 -Infinity ，则返回 NaN ；

   如果是 +0 加 +0 ，则返回 +0 ；

   如果是 -0 加 +0 ，则返回 +0 ；

   如果是 -0 加 -0 ，则返回 -0 。

   不过，如果有一个操作数是字符串，则要应用如下规则：

   如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；

   如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。

   如果有任一操作数是对象、数值或布尔值，则调用它们的toString() 方法以获取字符串，然后再应用前面的关于字符串的规则。对于 undefined 和 null ，则调用 String() 函数，分别获取 "undefined" 和 "null" 。

   看下面的例子：

   let result1 = 5 + 5; *//* *两个数值*

   console.log(result1); *// 10* 

   let result2 = 5 + "5"; *//* *一个数值和一个字*

   *符串*

   console.log(result2); *// "55"*

   以上代码展示了加法操作符的两种运算模式。正常情况下， 5 + 

   5 等于10（数值），如前两行代码所示。但是，如果将一个操作数改为字符串，比如 "5" ，则相加的结果就变成了 "55" （原始字符串值），因为第一个操作数也会被转换为字符串。

   ECMAScript中最常犯的一个错误，就是忽略加法操作中涉及的数据类型。比如下面这个例子：

   let num1 = 5; 

   let num2 = 10; 

   let message = "The sum of 5 and 10 is " + 

   num1 + num2; 

   console.log(message); *// "The sum of 5 and* 

   *10 is 510"*

   这里，变量 message 中保存的是一个字符串，是执行两次加法操作之后的结果。有人可能会认为最终得到的字符串是 "The sum of 5 and 10 is 15" 。可是，实际上得到的是 "The 

   sum of 5 and 10 is 510" 。这是因为每次加法运算都是独立完成的。第一次加法的操作数是一个字符串和一个数值（5），结果还是一个字符串。第二次加法仍然是用一个字符串去加一个数值（10），同样也会得到一个字符串。如果想真正执行数学计算，然后把结果追加到字符串末尾，只要使用一对括号即可：

   let num1 = 5; 

   let num2 = 10; 

   let message = "The sum of 5 and 10 is " + 

   (num1 + num2); 

   console.log(message); *// "The sum of 5 and 10* 

   *is 15"*在此，我们用括号把两个数值变量括了起来，意思是让解释器先

   执行两个数值的加法，然后再把结果追加给字符串。因此，最终

   得到的字符串变成了 "The sum of 5 and 10 is 15" 。

2. 减法操作符

减法操作符（ - ）也是使用很频繁的一种操作符，比如：

let result = 2 - 1;

与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript中不同类型之间的转换。

如果两个操作数都是数值，则执行数学减法运算并返回结果。

如果有任一操作数是 NaN ，则返回 NaN 。

如果是 Infinity 减 Infinity ，则返回 NaN 。

如果是 -Infinity 减 -Infinity ，则返回 NaN 。

如果是 Infinity 减 -Infinity ，则返回 Infinity 。

如果是 -Infinity 减 Infinity ，则返回 - Infinity 。

如果是 +0 减 +0 ，则返回 +0 。

如果是 +0 减 -0 ，则返回 -0 。

如果是 -0 减 -0 ，则返回 +0 。

如果有任一操作数是字符串、布尔值、 null 或 

undefined ，则先在后台使用 Number() 将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是NaN ，则减法计算的结果是 NaN 。

如果有任一操作数是对象，则调用其 valueOf() 方法取得        表示它的数值。如果该值是 NaN ，则减法计算的结果是NaN 。如果对象没有 valueOf() 方法，则调用其toString() 方法，然后再将得到的字符串转换为数值。

以下示例演示了上面的规则：

let result1 = 5 - true; *// true**被转换为**1**，所以结*

*果是**4* 

let result2 = NaN - 1; *// NaN* 

let result3 = 5 - 3; *// 2* 

let result4 = 5 - ""; *// ""**被转换为**0**，所以结果*

*是**5*

let result5 = 5 - "2"; *// "2"**被转换为**2**，所以结*

*果是**3* 

let result6 = 5 - null; *// null**被转换为**0**，所以结*

*果是**5* 

### 关系操作符

关系操作符执行比较两个值的操作，包括小于（ < ）、大于（ > ）、小于等于（ <= ）和大于等于（ >= ），用法跟数学课上学的一样。这几个操作符都返回布尔值，如下所示：

let result1 = 5 > 3; *// true* 

let result2 = 5 < 3; *// false*

### 相等操作符

1. 等于和不等于
2. 全等和不全等

### 条件操作符

条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟Java中一样：

variable = boolean_expression ? true_value :      false_value;

###  赋值操作符

简单赋值用等于号（ = ）表示，将右手边的值赋给左手边的变量，如下所示：

let num = 10;

每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：

乘后赋值（ *= ）

除后赋值（ /= ）

取模后赋值（ %= ）

加后赋值（ += ）

减后赋值（ -= ）

左移后赋值（ <<= ）

右移后赋值（ >>= ）

无符号右移后赋值（ >>>= ）

这些操作符仅仅是简写语法，使用它们不会提升性能。

### 逗号操作符

逗号操作符可以用来在一条语句中执行多个操作，如下所示：let num1 = 1, num2 = 2, num3 = 3;

##   语句

1. if 语句
2. do-while 语句
3. while 语句
4. for 语句
5. for-in 语句
6. for-of 语句
7. 标签语句
8. break 和 continue 语句
9. with 语句
10. switch 语句

### 函数

函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用function 关键字声明，后跟一组参数，然后是函数体。





#### ECMAScript中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。

# 六 变量，作用域与内存

## 1.原始值与引用值

### 1.1动态属性

原始值和引用值的定义方式很类似，都是创建一个变量，然后给

它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什

么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属

性和方法。

### 1.2复制值

除了存储方式不同，原始值和引用值在通过变量复制时也有所不

同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制

到新变量的位置。

```
let num1 = 5; 

let num2 = num1;
```

### 1.3传递参数

ECMAScript中所有函数的参数都是按值传递的。这意味着函数外

的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变

量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引

用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块

可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值

传递

## 2.执行上下文与作用域

### 2.1作用域链增强

try / catch 语句的 catch 块 

with 语句

### 2.2变量声明

1. 使用 var 的函数作用域声明

2. 使用 let 的块级作用域声明
   3. 使用 const 的常量声明
   4. 标识符查找

## 3.垃圾回收

JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码

执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是

个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个

负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很

简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程

是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程

中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且

不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，

意味着靠算法是解决不了的。

### 3.1标记清理

JavaScript最常用的垃圾回收策略是标记清理（mark-and

sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑

上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运

行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下

文的标记。

### 3.2引用计数

另一种没那么常用的垃圾回收策略是引用计数（reference

counting）。其思路是对每个值都记录它被引用的次数。声明变量并给

它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一

个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他

值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办

法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序

下次运行的时候就会释放引用数为0的值的内存。

### 3.3 性能

垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可

能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有

限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。

开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代

码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工

作

### 3.4内存管理

1. 通过 const 和 let 声明提升性能

2. 隐藏类和删除操作

### 4.内存泄漏

写得不好的JavaScript可能出现难以察觉且有害的内存泄漏问题。

在内存有限的设备上，或者在函数会被调用很多次的情况下，内

存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合

理的引用导致的

### 5.静态分配与对象池

为了提升JavaScript性能，最后要考虑的一点往往就是压榨浏览器

了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次

数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控

制触发垃圾回收的条件。理论上，如果能够合理使用分配的内

存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失

的性能。

## 总结

JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有以下特点。

原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。引用值是对象，存储在堆内存上。

包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。执行上下文分全局上下文、函数上下文和块级上下文。代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。

函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。

变量的执行上下文用于确定什么时候释放内存。JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript的垃圾回收程序可以总结如下。

离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。

主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。

引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。

JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）。

引用计数在代码中存在循环引用时会出现问题。

解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都

应该在不需要时解除引用。

# 第五章  基本引用数据类型

本章节主要理解的是   

1.对象，

2.基本JavaScript数据类型 ， 

3.原始值与原始值包装类型

引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲JavaScript是一门面向对象语言，但ECMAScript缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。

在这里要注意一点

引用类型虽然有点像类，但跟类并不是一个概念。

对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数。

let now = new Date();

 

函数也是一种引用类型，但有关函数的内容太多了，一章放不下，所以本书专门用第10章来介绍函数。

## Date

ECMAScript的 Date 类型参考了Java早期版本中的java.util.Date 。为此， Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式， Date 类型可以精确表示1970年1月 1日之前及之后285 616年的日期。

下面是一个创建时间的代码  用到了new和Data

```
let now = new Date();
```

Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262第5版定义了Date.parse() 应该支持的日期格式，填充了第3版遗留的空白。所有实现都必须支持下列日期格式：

“月/日/年”，如 "5/23/2019" ； 

“月名 日, 年”，如 "May 23, 2019" ； 

“周几 月名 日 年 时:分:秒 时区”，如 "Tue May 23 2019 00:00:00GMT-0700" ；

ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05- 

23T00:00:00 （只适用于兼容ES5的实现）。

要创建一个表示“2019年5月23日”的日期对象，可以使用以下代

码：let someDate = new Date(Date.parse("May 23, 2019"));

1. 继承的方法
2. 日期格式化方法
3. 日期**/**时间组件方法 

方法 说明

getTime()返回日期的毫秒表示；与valueOf() 相同setTime(*milliseconds*)设置日期的毫秒表示，从而修改整个日期

getFullYear()返回4位数年（即2019而不是19） 

getUTCFullYear()返回UTC日期的4位数年

setFullYear(*year*)设置日期的年（ *year* 必须是4位数）

setUTCFullYear(*year*)设置UTC日期的年（ *year* 必须是4位数）

getMonth()返回日期的月（0表示1月，11表 示12月）

getUTCMonth()返回UTC日期的月（0表示1月，11表示12月）

setMonth(*month*)设置日期的月（ *month* 为大于0的数值，大于11加年）

setUTCMonth(*month*)设置UTC日期的月（ *month* 为大于0的数值，大于11加年）

getDate()返回日期中的日（1~31） 

getUTCDate()返回UTC日期中的日（1~31） 

setDate(*date*)设置日期中的日（如果 *date* 大于该月天数，则加月）

setUTCDate(*date*)设置UTC日期中的日（如果date大于该月天数，则加月）

getDay()返回日期中表示周几的数值（0表示周日，6表示周六）

##  RegExp

1. RegExp 实例属性

   每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。

   global ：布尔值，表示是否设置了 g 标记。

   ignoreCase ：布尔值，表示是否设置了 i 标记。

   unicode ：布尔值，表示是否设置了 u 标记。

   sticky ：布尔值，表示是否设置了 y 标记。

   lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。

   multiline ：布尔值，表示是否设置了 m 标记。

   dotAll ：布尔值，表示是否设置了 s 标记。

   source ：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。

   flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）

2. RegExp 实例方法 

3. RegExp 构造函数属性

4. 模式局限

## 原始值包装类型

1. Boolean

2. Number

3. String

   3.1    JavaScript字符

   3.2   normalize() 方法

   3.3   字符串操作方法

   3.4    字符串位置方法

   3.5    字符串包含方法

   3.6    trim() 方法

   3.7    repeat() 方法

   3.8    padStart() 和 padEnd() 方法

   3.9   字符串迭代与解构

   3.10   字符串大小写转换

   3.11   字符串模式匹配方法

   3.12    localeCompare() 方法

   3.13      HTML方法

## 单例内置对象

### Global

​	1. URL编码方法

2. eval() 方法

3. Global 对象属性

4. window 对象

### Math

1. Math 对象属性
2. min() 和 max() 方法
3. 舍入方法
4. random() 方法
5. 其他方法

## 小结

JavaScript中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。

引用值与传统面向对象编程语言中的类相似，但实现不同。

Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。

RegExp 类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。

JavaScript比较独特的一点是，函数实际上是 Function 类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。

由于原始值包装类型的存在，JavaScript中的原始值可以被当成对象来使用。有3种原始值包装类型： Boolean 、 Number 和 String 。它们都具备如下特点。

1. 每种包装类型都映射到同名的原始类型。

2. 以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。

3. 涉及原始值的语句执行完毕后，包装对象就会被销毁。

当代码开始执行时，全局上下文中会存在两个内置对象： Global 和 Math 。其中， Global 对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是Global 对象的属性。 Math 对象包含辅助完成复杂计算的属性和方法。

# 第六章

## **Object**

1. 大多数引用值的示例使用的是 Object 类型。Object 是ECMAScript中最常用的类型之一。虽然 Object 的例没有多少功能，但很适合存储和在应用程序间交换数据。

2. 显式地创建 Object 的实例有两种方式。第一种是使用 new 操符和 Object 构造函数

   代码

```
let person = new Object(); 

person.name = "Nicholas"; 

person.age = 29;
```

3. 另一种方式是使用对象字面量（object literal）表示法。对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的建。

代码

```
let person = { 

name: "Nicholas", 

age: 29 

};
```

4. 在对象字面量表示法中，属性名可以是字符串或数值

代码

```
let person = { 

"name": "Nicholas", 

"age": 29, 

5: true 

};
```

## Array

1. ### 创建数组

   有几种基本的方式可以创建数组

let colors = new Array();

let colors = new Array(20);

let colors = new Array("red", "blue", "green");

2. ### 数组空位

   1. 使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规范重新定义了该如何处理这些空位。

```
const options = [,,,,,]; //创建包含5个元素的数组

console.log(options.length); // 5
```

2. ES6新增的方法和迭代器与早期ECMAScript版本中存在的方法行为不同。ES6新增方法普遍将这些空位当成存在的元素，只不过值为undefined

```
const options = [1,,,,5]; 
for (const option of options) { 
console.log(option === undefined); 
}
// false
// true
// true
// true
// false
const a = Array.from([,,,]); //使用ES6的Array.from()
创建的包含3个空位的数组
for (const val of a) { 
alert(val === undefined); 
}
// true
// true
// true
alert(Array.of(...[,,,])); // [undefined, undefined,
undefined]
for (const [index, value] of options.entries()) {alert(value); 
}
// 1
// undefined
// undefined
// undefined
// 5
```

3. ### 数组索引

   要取得或设置数组的值，需要使用中括号并提供相应值的数字索引

4. ### 检测数组

   一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符

使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。为解决这个问题，ECMAScript提供了 Array.isArray() 方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的

5. ### 迭代器方法

6. ### 复制和填充方法

7. ### 转换方法

8. ### 栈方法

9. ### 队列方法

10. ### 排序方法

11. ### 操作方法

12. ### 搜索和位置方法

13. ### 迭代方法

14. ### 归并方法

    ## Array

    1. 历史

    2. ArrayBuffer

    3. DataView

    4. 定型数组

       ## Map

       1. 基本API
       2. 顺序与迭代
       3. 选择 Object 还是 Map

       ## WeakMap

       1. 基本API
       2. 弱键
       3. 不可迭代键
       4. 使用弱映射

    ## Set

    1. 基本API
    2. 顺序与迭代
    3. 定义正式集合操作

    ## WeakSet

    1. 基本API
    2. 弱值
    3. 不可迭代值
    4. 使用弱集合

    ## 迭代与扩展操作

    ECMAScript 6新增的迭代器和扩展操作符对集合引用类型特别有用。这些新特性让集合类型之间相互操作、复制和修改变得异常方便

## 总结

1.JavaScript中的对象是引用值，可以通过几种内置引用类型创建特定类型的对象。

2.引用类型与传统面向对象编程语言中的类相似，但实现不同。

3.Object 类型是一个基础类型，所有引用类型都从它继承了基本的行为。

4.Array 类型表示一组有序的值，并提供了操作和转换值的能力。定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。Date 类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。

5.RegExp 类型是ECMAScript支持的正则表达式的接口，提供了大多数基本正则表达式以及一些高级正则表达式的能力。

6.JavaScript比较独特的一点是，函数其实是 Function 类型的实例，这意味着函数也是对象。由于函数是对象，因此也就具有能够增强自身行为的方法。

7.因为原始值包装类型的存在，所以JavaScript中的原始值可以拥有类似对象的行为。有3种原始值包装类型： Boolean 、 Number 和 String 。它们都具有如下特点。

8.每种包装类型都映射到同名的原始类型。在以读模式访问原始值时，后台会实例化一个原始值包装对象，通过这个对象可以操作数据。

9.涉及原始值的语句只要一执行完毕，包装对象就会立即销毁。JavaScript还有两个在一开始执行代码时就存在的内置对象：Global 和 Math 。其中， Global 对象可以在大多数ECMAScript实现中访问。不过浏览器将 Global 实现为 window 对象。所有全局变量和函数都是 Global 对象的属性。 Math 对象包含辅助完成复杂数学计算的属性和方法。

10.ECMAScript 6新增了一批引用类型： Map 、 WeakMap 、 Set 和 WeakSet 。这些类型为组织应用程序数据和简化内存管理提供了新能力。

# 第八章   对象、类与面向对象编程

## 8.1.1 理解对象

创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法

```
let person = new Object(); 

person.name = "Nicholas"; 

person.age = 29; 

person.job = "Software Engineer"; 

person.sayName = function() { 

console.log(this.name); 

};
```

1. ### 属性的类型

ECMA-262使用一些内部特性来描述属性的特征。这些特性是由为JavaScript实现引擎的规范定义的。因此，开发者不能在JavaScript中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 [[Enumerable]] 。

属性分两种：数据属性和访问器属性

 #### 数据属性

数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为。

[[Configurable]] ：表示属性是否可以通过 delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true ，如前面的例子所示。

[[Enumberable]] ：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true ，如前面的例子所示。

[[Writable]] ：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是true ，如前面的例子所示。

[[Value]] ：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为undefined 。

#### 访问器属性

访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为。

[[Configurable]] ：表示属性是否可以通过 delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。 

[[Enumerable]] ：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。 

[[Get]] ：获取函数，在读取属性时调用。默认值为undefined 。 

[[Set]] ：设置函数，在写入属性时调用。默认值为undefined 。

访问器属性是不能直接定义的，必须使用Object.defineProperty() 。

```
let book = { 

year_: 2017, 

edition: 1};

Object.defineProperty(book, "year", { 

get() { 

return this.year_; 

},

set(newValue) { 

if (newValue > 2017) { 

this.year_ = newValue; 

this.edition += newValue - 2017; 

} 

} 

}); 

book.year = 2018; 

console.log(book.edition); // 2
```

## 8.1.2 定义多个属性

在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript提供了 Object.defineProperties() 方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。

```
let book = {}; 

Object.defineProperties(book, { 

year_: { 

value: 2017 

},

edition: { 

value: 1 

},

year: {get() { 

return this.year_; 

},

set(newValue) { 

if (newValue > 2017) { 

this.year_ = newValue; 

this.edition += newValue - 2017; 

} 

} 

} 

});
```

## 8.1.3 读取属性的特性

使用 Object.getOwnPropertyDescriptor() 方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 configurable 、 enumerable 、 get 和 set 属性，对于数据属性包含 configurable 、 enumberable 、 writable 和 value 属性。

```
let book = {}; 

Object.defineProperties(book, { 

year_: {value: 2017 

},

edition: { 

value: 1 

},

year: { 

get: function() { 

return this.year_; 

},

set: function(newValue){ 

if (newValue > 2017) { 

this.year_ = newValue; 

this.edition += newValue - 2017; 

} 

} 

} 

}); 

let descriptor =  Object.getOwnPropertyDescriptor(book, "year_"); 

console.log(descriptor.value); // 2017

console.log(descriptor.configurable); // false

console.log(typeof descriptor.get); // "undefined"

let descriptor =Object.getOwnPropertyDescriptor(book, "year"); 

console.log(descriptor.value); //undefined

console.log(descriptor.enumerable); // false

console.log(typeof descriptor.get); //"function"
```

ECMAScript 2017新增了Object.getOwnPropertyDescriptors() 静态方法。这个方法实际上会在每个自有属性上调用 Object.defineProperties()并在一个新对象中返回它们。

```
let book = {}; 

Object.defineProperties(book, { 

year_: { 

value: 2017 

},

edition: { 

value: 1 

},

year: {get: function() { 

return this.year_; 

},

set: function(newValue){ 

if (newValue > 2017) { 

this.year_ = newValue; 

this.edition += newValue - 2017; 

} 

} 

} 

}); 

console.log(Object.getOwnPropertyDescriptors(boo 

k)); 
```

## 8.1.4 合并对象

JavaScript开发者经常觉得“合并”（merge）两个对象很有用。更具体地说，就是把源对象所有的本地属性一起复制到目标对象上。有时候这种操作也被称为“混入”（mixin），因为目标对象通过混入源对象的属性得到了增强。

ECMAScript 6专门为合并对象提供了 Object.assign() 方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（ Object.propertyIsEnumerable() 返 回 true ）和自有（ Object.hasOwnProperty() 返回 true ）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的 [[Get]] 取得属性的值，然后使用目标对象上的 [[Set]] 设置属性的值

```
let dest, src, result; 
dest = {}; 
src = { id: 'src' };result = Object.assign(dest, src); 
// Object.assign修改目标对
//也会返回修改后的目标对象
console.log(dest === result);// true
console.log(dest !== src); // true
console.log(result); // { id: src }
console.log(dest); // { id: src }


dest = {}; 
result = Object.assign(dest, { a: 'foo' }, { b: 'bar' }); 
console.log(result); // { a: foo, b: bar }



dest = { set a(val) { 
console.log('Invoked dest setter with param${val}'); 
} 
};
src = { 
get a() { 
console.log('Invoked src getter'); 
return 'foo'; 
} 
};
Object.assign(dest, src); 
//调用src的获取方法
//调用dest的设置方法并传入参数"foo"
//因为这里的设置函数不执行赋值操作
//所以实际上并没有把值转移过来
console.log(dest); // { set a(val) {...} }
```

## 8.2 继承

继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript中是不可能的，因为函数没有签名。实现继承是ECMAScript唯一支持的继承方式，而这主要是通过原型链实现的。

### 8.2.1 原型链

ECMA-262把原型链定义为ECMAScript的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。

```
function SuperType() { 

this.property = true; 

}

SuperType.prototype.getSuperValue = function() { 

return this.property; 

};

function SubType() { 

this.subproperty = false; 

}

//继承SuperType

SubType.prototype = new SuperType(); 

SubType.prototype.getSubValue = function () { 

return this.subproperty; 

};

let instance = new SubType(); 

console.log(instance.getSuperValue()); // true
```

1. 默认原型

实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object ，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向 Object.prototype 。这也是为什么自定义类型能够继承包括 toString() 、 valueOf() 在内的所有默认方法的原因。因此前面的例子还有额外一层继承关系。图8-5展示了完整的原型链

SubType 继承 SuperType ，而 SuperType 继承Object 。在调用 instance.toString() 时，实际上调用的是保存在 Object.prototype 上的方法

2. 原型与继承关系

原型与实例的关系可以通过两种方式来确定。第一种方式是使用instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true 。

```
console.log(instance instanceof Object); // true
console.log(instance instanceof SuperType); // true 
console.log(instance instanceof SubType); // true
```

3. 关于方法

子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。

```
function SuperType() { 

this.property = true; 

}

SuperType.prototype.getSuperValue = function() {return this.property; 

};

function SubType() { 

this.subproperty = false; 

}

//继承SuperType

SubType.prototype = new SuperType(); 

//新方法

SubType.prototype.getSubValue = function () { 

return this.subproperty; 

};

//覆盖已有的方法

SubType.prototype.getSuperValue = function () { 

return false; 

};

let instance = new SubType(); 

console.log(instance.getSuperValue()); //false
```

4. 原型链的问题

原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。

```
function SuperType() { 

this.colors = ["red", "blue", "green"]; 

}

function SubType() {}//继承**SuperType

SubType.prototype = new SuperType(); 

let instance1 = new SubType(); 

instance1.colors.push("black"); 

console.log(instance1.colors); //"red,blue,green,black"

let instance2 = new SubType(); 

console.log(instance2.colors); // "red,blue,green,black"
```

### 8.2.2 盗用构造函数

为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 apply() 和 call() 方法以新创建的对象为上下文执行构造函数。

```
function SuperType() { 

this.colors = ["red", "blue", "green"]; 

}

function SubType() {  //继承SuperType*

SuperType.call(this); 

}

let instance1 = new SubType(); 

instance1.colors.push("black"); 

console.log(instance1.colors); *//* 

*"red,blue,green,black"* 

let instance2 = new SubType(); 

console.log(instance2.colors); *//* 

"red,blue,green"
```

### 8.2.3 组合继承

组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。

```
function SuperType(name){ 

this.name = name; 

this.colors = ["red", "blue", "green"]; 

}

SuperType.prototype.sayName = function() { 

console.log(this.name); 

};

function SubType(name, age){ 

*//* *继承属性*

SuperType.call(this, name); 

this.age = age;}

*//* *继承方法*

SubType.prototype = new SuperType(); 

SubType.prototype.sayAge = function() { 

console.log(this.age); 

};

let instance1 = new SubType("Nicholas", 29); 

instance1.colors.push("black"); 

console.log(instance1.colors); *//* 

*"red,blue,green,black"* 

instance1.sayName(); *// "Nicholas";* 

instance1.sayAge(); *// 29* 

let instance2 = new SubType("Greg", 27); 

console.log(instance2.colors); *//* 

*"red,blue,green"* 

instance2.sayName(); *// "Greg";* 

instance2.sayAge(); *// 27*
```

### 8.2.4 原型式继承

2006年，Douglas Crockford写了一篇文章：《JavaScript中的原型式继承》（“Prototypal Inheritance in JavaScript”）。这篇文章介绍了一种不涉及严格意义上构造函数的继承方法。他的出发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。

```
function object(o) { 

function F() {} 

F.prototype = o; 

return new F(); 

}
```

### 8.2.5 寄生式继承

与原型式继承比较接近的一种继承方式是寄生式继承（parasiticinheritance），也是Crockford首倡的一种模式。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。

```
function createAnother(original){ 

let clone = object(original); *//* *通过调用函数创*

*建一个新对象*

clone.sayHi = function() { *//* *以某种方式增强*

*这个对象*

console.log("hi"); 

};

return clone; *//* *返回这个对象*

}
```

### 8.2.6 寄生式组合继承

组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。

```
function SuperType(name) { 

this.name = name; 

this.colors = ["red", "blue", "green"];}

SuperType.prototype.sayName = function() { 

console.log(this.name); 

};

function SubType(name, age){ 

SuperType.call(this, name); *//* *第二次调用*

*SuperType()* 

this.age = age; 

}

SubType.prototype = new SuperType(); *//* *第一次调*

*用**SuperType()* 

SubType.prototype.constructor = SubType; 

SubType.prototype.sayAge = function() { 

console.log(this.age); 

};
```



## 8.3  创建原型



### 8.3.1 概述

综观ECMAScript规范的历次发布，每个版本的特性似乎都出人意料。ECMAScript 5.1并没有正式支持面向对象的结构，比如类或继承。但是，正如接下来几节会介绍的，巧妙地运用原型式继承可以成功地模拟同样的行为。

### 8.3.2 工厂模式

工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。（本书后面还会讨论其他设计模式及其在JavaScript中的实现。）

```
function createPerson(name, age, job) { 

let o = new Object(); 

o.name = name; 

o.age = age; 

o.job = job; 

o.sayName = function() { 

console.log(this.name); 

};

return o; 

}

let person1 = createPerson("Nicholas", 29, 

"Software Engineer"); 

let person2 = createPerson("Greg", 27, 

"Doctor");
```

### 8.3.3 构造函数模式

前面几章提到过，ECMAScript中的构造函数是用于创建特定类型对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法

```
function Person(name, age, job){ 

this.name = name; 

this.age = age; 

this.job = job; 

this.sayName = function() { 

console.log(this.name); 

}; 

}

let person1 = new Person("Nicholas", 29, 

"Software Engineer"); 

let person2 = new Person("Greg", 27, "Doctor"); 

person1.sayName(); *// Nicholas* 

person2.sayName(); // Greg
```

### 8.3.4 原型模式

每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型

```
function Person() {} 

Person.prototype.name = "Nicholas"; 

Person.prototype.age = 29; 

Person.prototype.job = "Software Engineer"; 

Person.prototype.sayName = function() { 

console.log(this.name); 

};

let person1 = new Person(); 

person1.sayName(); // "Nicholas"

let person2 = new Person(); 

person2.sayName(); *// "Nicholas"*console.log(person1.sayName == person2.sayName); // true
```

使用函数表达式也可以：

```
let Person = function() {}; 

Person.prototype.name = "Nicholas"; 

Person.prototype.age = 29; 

Person.prototype.job = "Software Engineer"; 

Person.prototype.sayName = function() { 

console.log(this.name); 

};

let person1 = new Person(); 

person1.sayName(); *// "Nicholas"* 

let person2 = new Person(); 

person2.sayName(); *// "Nicholas"* 

console.log(person1.sayName == person2.sayName); // true
```

## 8.4 类

前几节深入讲解了如何只使用ECMAScript 5的特性来模拟类似于类（class-like）的行为。不难看出，各种策略都有自己的问题，也有相应的妥协。正因为如此，实现继承的代码也显得非常冗长和混乱。为解决这些问题，ECMAScript 6新引入的 class 关键字具有正式定义类的能力。类（class）是ECMAScript中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。虽然ECMAScript 6类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。

### 8.4.1 类定义

与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 class 关键字加大括号

```
//* *类声明*

class Person {} 

*//* *类表达式*

const Animal = class {}
```

### 8.4.2 类构造函数

constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。

### 8.4.3 实例、原型和类成员

类的语法可以非常方便地定义应该存在于实例上的成员、应该存在于原型上的成员，以及应该存在于类本身的成员

### 8.4.4 继承

ECMAScript 6新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链

1. 继承基础
2. 构造函数、 HomeObject 和 super()
3. 抽象基类
4. 继承内置类型
5. 类混入

## 第八章小结

对象在代码执行过程中的任何时候都可以被创建和增强，具有极大的动态性，并不是严格定义的实体。下面的模式适用于创建对象。

1. 工厂模式就是一个简单的函数，这个函数可以创建对象，为它添加属性和方法，然后返回这个对象。这个模式在构造函数模式出现后就很少用了。
2. 使用构造函数模式可以自定义引用类型，可以使用 new 关键字像创建内置类型实例一样创建自定义类型的实例。不过，构造函数模式也有不足，主要是其成员无法重用，包括函数。考虑到函数本身是松散的、弱类型的，没有理由让函数不能在多个对象实例间共享
3. 原型模式解决了成员共享的问题，只要是添加到构造函数prototype 上的属性和方法就可以共享。而组合构造函数和原型模式通过构造函数定义实例属性，通过原型定义共享的属性和方法。
4. JavaScript的继承主要通过原型链来实现。原型链涉及把构造函数的原型赋值为另一个类型的实例。这样一来，子类就可以访问父类的所有属性和方法，就像基于类的继承那样。原型链的问题是所有继承的属性和方法都会在对象实例间共享，无法做到实例私有。盗用构造函数模式通过在子类构造函数中调用父类构造函数，可以避免这个问题。这样可以让每个实例继承的属性都是私有的，但要求类型只能通过构造函数模式来定义（因为子类不能访问父类原型上的方法）。目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。
5. 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强。
6. 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。
7. 寄生组合继承被认为是实现基于类型继承的最有效方式

ECMAScript 6新增的类很大程度上是基于既有原型机制的语法糖。类的语法让开发者可以优雅地定义向后兼容的类，既可以继承内置类型，也可以继承自定义类型。类有效地跨越了对象实例、对象原型和对象类之间的鸿沟。

# 第九章 代理与反射

ECMAScript 6新增的代理和反射为开发者提供了拦截并向基本操作嵌入额外行为的能力。具体地说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。在对目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制。

在此要注意的是 ：在ES6之前，ECMAScript中并没有类似代理的特性。由于代理是一种新的基础性语言能力，很多转译程序都不能把代理行为转换为之前的ECMAScript代码，因为代理的行为实际上是无可替代的。为此，代理和反射只在百分之百支持它们的平台上有用。可以检测代理是否存在，不存在则提供后备代码。不过这会导致代码冗余，因此并不推荐。

## 9.1 代理基础

### 9.1.1 创建空代理

最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。

代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出TypeError 要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。

```
const target = { 

id: 'target' 

};

const handler = {}; 

const proxy = new Proxy(target, handler);*// id**属性会访问同一个值*

console.log(target.id); *// target* 

console.log(proxy.id); *// target* 

*//* *给目标属性赋值会反映在两个对象上*

*//* *因为两个对象访问的是同一个值*

target.id = 'foo'; 

console.log(target.id); *// foo* 

console.log(proxy.id); *// foo* 

*//* *给代理属性赋值会反映在两个对象上*

*//* *因为这个赋值会转移到目标对象*

proxy.id = 'bar'; 

console.log(target.id); *// bar* 

console.log(proxy.id); *// bar* 

*// hasOwnProperty()**方法在两个地方*

*//* *都会应用到目标对象*

console.log(target.hasOwnProperty('id')); *//* 

*true* 

console.log(proxy.hasOwnProperty('id')); *//* 

*true* 

*// Proxy.prototype**是**undefined*

*//* *因此不能使用**instanceof**操作符*

console.log(target instanceof Proxy); *//* 

*TypeError: Function has non-object prototype**'undefined' in instanceof check*

console.log(proxy instanceof Proxy); *//* 

*TypeError: Function has non-object prototype*

*'undefined' in instanceof check*

*//* *严格相等可以用来区分代理和目标*

console.log(target === proxy); *// false*
```

### 9.1.2 定义捕获器

使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。

```
const target = { 

foo: 'bar' 

};

const handler = { 

*//* *捕获器在处理程序对象中以方法名为键*get() { 

return 'handler override'; 

} 

};

const proxy = new Proxy(target, handler);
```

这样，当通过代理对象执行 get() 操作时，就会触发定义的get() 捕获器。当然， get() 不是ECMAScript对象可以调用的方法。这个操作在JavaScript代码中可以通过多种形式触发并被 get()捕获器拦截到。 proxy[property] 、 proxy.property 或 Object.create(proxy)[property] 等操作都会触发基本的get() 操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 get() 捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。

```
const target = { 

foo: 'bar' 

};

const handler = { 

//捕获器在处理程序对象中以方法名为键

get() { 

return 'handler override'; 

} 

};

const proxy = new Proxy(target, handler);console.log(target.foo); //bar

console.log(proxy.foo); //handler override*

console.log(target['foo']); //bar

console.log(proxy['foo']); //handler override

console.log(Object.create(target)['foo']); //bar

console.log(Object.create(proxy)['foo']); //handler override
```

### 9.1.3 捕获器参数和反射**API**

所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如， get() 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。

```
const target = { 

foo: 'bar' 

};

const handler = { 

get(trapTarget, property, receiver) { 

console.log(trapTarget === target);console.log(property); 

console.log(receiver === proxy); 

} 

};

const proxy = new Proxy(target, handler); 

proxy.foo; 

*// true* 

*// foo* 

*// true*
```

有了这些参数，就可以重建被捕获方法的原始行为：

```
const target = { 

foo: 'bar' 

};

const handler = { 

get(trapTarget, property, receiver) { 

return trapTarget[property]; 

} 

};

const proxy = new Proxy(target, handler); 

console.log(proxy.foo); *// bar* 

console.log(target.foo); *// bar*
```

处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射API也可以像下面这样定义出空代理对象

```
const target = { 

foo: 'bar' 

};

const handler = { 

get() { 

return Reflect.get(...arguments); 

} 

};

const proxy = new Proxy(target, handler); 

console.log(proxy.foo); *// bar* 

console.log(target.foo); *// bar*
```

甚至还可以写得更简洁一些：

```
const target = { 

foo: 'bar'};

const handler = { 

get: Reflect.get 

};

const proxy = new Proxy(target, handler); 

console.log(proxy.foo); *// bar* 

console.log(target.foo); *// bar
```

### 9.1.4 捕获器不变式

使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据ECMAScript规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”（trapinvariant）。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为

比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError ： 

```
const target = {}; 

Object.defineProperty(target, 'foo', { 

configurable: false, 

writable: false, 

value: 'bar' 

}); 

const handler = { 

get() { 

return 'qux'; 

} 

};

const proxy = new Proxy(target, handler); 

console.log(proxy.foo); 

*// TypeError* 
```

### 9.1.5 可撤销代理

有时候可能需要中断代理对象与目标对象之间的联系。对于使用new Proxy() 创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。Proxy 也暴露了 revocable() 方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（ revoke() ）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError 。

撤销函数和代理对象是在实例化时同时生成的

```
const target = { 

foo: 'bar' 

};

const handler = { 

get() { 

return 'intercepted'; 

} 

};

const { proxy, revoke } = 

Proxy.revocable(target, handler); 

console.log(proxy.foo); *// intercepted* 

console.log(target.foo); *// bar* 

revoke(); 

console.log(proxy.foo); *// TypeError* 
```

 ### 9.1.6  实用反射**API**

某些情况下应该优先使用反射API，这是有一些理由的。

1. 反射**API**与对象**API**
2. 状态标记
3. 用一等函数替代操作符
4. 安全地应用函数

### 9.1.7 代理另一个代理

代理可以拦截反射API的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：

```
const target = { 

foo: 'bar' 

};

const firstProxy = new Proxy(target, { 

get() { 

console.log('first proxy'); 

return Reflect.get(...arguments); 

} 

});const secondProxy = new Proxy(firstProxy, { 

get() { 

console.log('second proxy'); 

return Reflect.get(...arguments); 

} 

}); 

console.log(secondProxy.foo); 

*// second proxy* 

*// first proxy* 

*// bar* 
```

### 9.1.8 代理的问题与不足

1. 代理中的 this
2. 代理与内部槽位

## 9.2 代理捕获器与反射方法

### 9.2.1 get()

get() 捕获器会在获取属性值的操作中被调用。对应的反射API方法为 Reflect.get() 

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

get(target, property, receiver) { 

console.log('get()'); 

return Reflect.get(...arguments) 

} 

}); 

proxy.foo; 

*// get()* 
```

1. 返回值
2. 拦截的操作
3. 捕获器处理程序参数
4. 捕获器不变式

### 9.2.2 set() 

set() 捕获器会在设置属性值的操作中被调用。对应的反射API方法为 Reflect.set() 

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

set(target, property, value, receiver) { 

console.log('set()'); 

return Reflect.set(...arguments) 

} 

}); 

proxy.foo = 'bar'; 

*// set()* 
```

### 9.2.3 has()

has() 捕获器会在 in 操作符中被调用。对应的反射API方法为 Reflect.has() 。 

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

has(target, property) { 

console.log('has()'); 

return Reflect.has(...arguments) 

} 

}); 

'foo' in proxy; 

*// has()*
```

### 9.2.4 defineProperty()

defineProperty() 捕获器会在Object.defineProperty() 中被调用。对应的反射API方法为Reflect.defineProperty() 。 

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

defineProperty(target, property, descriptor) { 

console.log('defineProperty()');return Reflect.defineProperty(...arguments) 

} 

}); 

Object.defineProperty(proxy, 'foo', { value: 

'bar' }); 

*// defineProperty()* 
```

### 9.2.5 getOwnPropertyDescriptor()

getOwnPropertyDescriptor() 捕获器会在Object.getOwnPropertyDescriptor() 中被调用。对应的反射API方法为 Reflect.getOwnPropertyDescriptor() 。 

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

getOwnPropertyDescriptor(target, property) { 

console.log('getOwnPropertyDescriptor()'); 

return 

Reflect.getOwnPropertyDescriptor(...arguments) 

} 

}); 

Object.getOwnPropertyDescriptor(proxy, 'foo'); 

*// getOwnPropertyDescriptor()*
```

### 9.2.6 deleteProperty() 

deleteProperty() 捕获器会在 delete 操作符中被调用。对应的反射API方法为 Reflect.deleteProperty() 。 

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

deleteProperty(target, property) { 

console.log('deleteProperty()'); 

return Reflect.deleteProperty(...arguments)} 

}); 

delete proxy.foo 

*// deleteProperty()* 
```

### 9.2.7 ownKeys() 

ownKeys() 捕获器会在 Object.keys() 及类似方法中被调用。对应的反射API方法为 Reflect.ownKeys() 。 

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, {ownKeys(target) { 

console.log('ownKeys()'); 

return Reflect.ownKeys(...arguments) 

} 

}); 

Object.keys(proxy); 

*// ownKeys()* 
```

### 9.2.8 getPrototypeOf()

getPrototypeOf() 捕获器会在Object.getPrototypeOf() 中被调用。对应的反射API方法为Reflect.getPrototypeOf() 。 

```
Reflect.getPrototypeOf() 。 

const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

getPrototypeOf(target) { 

console.log('getPrototypeOf()'); 

return Reflect.getPrototypeOf(...arguments) 

} 

}); 

Object.getPrototypeOf(proxy); 

*// getPrototypeOf()* 
```

### 9.2.9 setPrototypeOf()

setPrototypeOf() 捕获器会在Object.setPrototypeOf() 中被调用。对应的反射API方法为Reflect.setPrototypeOf() 。

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

setPrototypeOf(target, prototype) { 

console.log('setPrototypeOf()'); 

return Reflect.setPrototypeOf(...arguments) 

} 

}); 

Object.setPrototypeOf(proxy, Object); 

*// setPrototypeOf()* 
```

### 9.2.10 isExtensible() 

isExtensible() 捕获器会在 Object.isExtensible(中被调用。对应的反射API方法为 Reflect.isExtensible() 。 

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

isExtensible(target) { 

console.log('isExtensible()'); 

return Reflect.isExtensible(...arguments) 

} 

}); 

Object.isExtensible(proxy); 

*// isExtensible()* 
```

### 9.2.11 preventExtensions() 

preventExtensions() 捕获器会在Object.preventExtensions() 中被调用。对应的反射API方法为 Reflect.preventExtensions() 。

```
const myTarget = {}; 

const proxy = new Proxy(myTarget, { 

preventExtensions(target) { 

console.log('preventExtensions()'); 

return 

Reflect.preventExtensions(...arguments) 

} 

}); 

Object.preventExtensions(proxy); 

*// preventExtensions()* 
```

### 9.2.12 apply()

apply() 捕获器会在调用函数时中被调用。对应的反射API方法为 Reflect.apply() 。 

```
const myTarget = () => {}; 

const proxy = new Proxy(myTarget, { 

apply(target, thisArg, ...argumentsList) { 

console.log('apply()'); 

return Reflect.apply(...arguments) 

} 

}); 

proxy(); 

*// apply()* 
```

### 9.2.13 construct() 

construct() 捕获器会在 new 操作符中被调用。对应的反射API方法为 Reflect.construct() 。 

```
const myTarget = function() {}; 

const proxy = new Proxy(myTarget, { 

construct(target, argumentsList, newTarget) { 

console.log('construct()'); 

return Reflect.construct(...arguments) 

} 

});new proxy; 

*// construct()* 
```

## 9.3 代理模式

### 9.3.1 跟踪属性访问

通过捕获 get 、 set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过

```
const user = { 

name: 'Jake' 

};const proxy = new Proxy(user, { 

get(target, property, receiver) { 

console.log('Getting ${property}'); 

return Reflect.get(...arguments); 

},

set(target, property, value, receiver) { 

console.log('Setting ${property}=${value}'); 

return Reflect.set(...arguments); 

} 

}); 

proxy.name; *// Getting name* 

proxy.age = 27; *// Setting age=27* 
```

### 9.3.2 隐藏属性

代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举

```
const hiddenProperties = ['foo', 'bar']; 

const targetObject = { 

foo: 1, 

bar: 2, 

baz: 3 

};

const proxy = new Proxy(targetObject, {get(target, property) { 

if (hiddenProperties.includes(property)) { 

return undefined; 

} else { 

return Reflect.get(...arguments); 

} 

},

has(target, property) { 

if (hiddenProperties.includes(property)) { 

return false; 

} else { 

return Reflect.has(...arguments); 

} 

} 

}); 

*// get()* 

console.log(proxy.foo); *// undefined* 

console.log(proxy.bar); *// undefined* 

console.log(proxy.baz); *// 3* 

*// has()* 

console.log('foo' in proxy); *// false* 

console.log('bar' in proxy); *// false* 

console.log('baz' in proxy); *// true* 
```

### **9.3.3** 属性验证

因为所有赋值操作都会触发 set() 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：

```
const target = { 

onlyNumbersGoHere: 0 

};

const proxy = new Proxy(target, { 

set(target, property, value) { 

if (typeof value !== 'Number') { 

return false; 

} else { 

return Reflect.set(...arguments); 

} 

} 

}); 

proxy.onlyNumbersGoHere = 1; 

console.log(proxy.onlyNumbersGoHere); *// 1* 

proxy.onlyNumbersGoHere = '2'; 

console.log(proxy.onlyNumbersGoHere); *// 1* 
```

### **9.3.4** 函数与构造函数参数验证

跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：

```
function median(...nums) { 

return nums.sort()[Math.floor(nums.length /2)]; 

}

const proxy = new Proxy(median, { 

apply(target, thisArg, ...argumentsList) { 

for (const arg of argumentsList) { 

if (typeof arg !== 'number') { 

throw 'Non-number argument provided'; 

} 

}

return Reflect.apply(...arguments); 

} 

}); 

console.log(proxy(4, 7, 1)); *// 4* 

console.log(proxy(4, '7', 1)); 

*// Error: Non-number argument provided*
```

类似地，可以要求实例化时必须给构造函数传参：

```
class User { 

constructor(id) { 

this.id_ = id; 

} 

}

const proxy = new Proxy(User, { 

construct(target, argumentsList, newTarget) { 

if (argumentsList[0] === undefined) {throw 'User cannot be instantiated without

id';

} else { 

return Reflect.construct(...arguments); 

} 

} 

}); 

new proxy(1); 

new proxy(); 

*// Error: User cannot be instantiated without id*
```

### **9.3.5** 数据绑定与可观察对象

通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作

可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：

```
const userList = []; 

class User { 

constructor(name) { 

this.name_ = name; 

} 

}

const proxy = new Proxy(User, {construct() { 

const newUser = 

Reflect.construct(...arguments); 

userList.push(newUser); 

return newUser; 

} 

}); 

new proxy('John'); 

new proxy('Jacob'); 

new proxy('Jingleheimerschmidt'); 

console.log(userList); *// [User {}, User {},* User{}]
```

另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：

```
const userList = []; 

function emit(newValue) { 

console.log(newValue); 

}

const proxy = new Proxy(userList, { 

set(target, property, value, receiver) { 

const result = Reflect.set(...arguments); 

if (result) { 

emit(Reflect.get(target, property,receiver)); 

}

return result; 

} 

}); 

proxy.push('John'); 

*// John* 

proxy.push('Jacob'); 

*// Jacob* 
```

## **9.4** 小结

代理是ECMAScript 6新增的令人兴奋和动态十足的新特性。尽管不支持向后兼容，但它开辟出了一片前所未有的JavaScript元编程及抽象的新天地。

从宏观上看，代理是真实JavaScript对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分JavaScript的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。

与代理如影随形的反射API，则封装了一整套与捕获器拦截的操作相对应的方法。可以把反射API看作一套基本操作，这些操作是绝大部分JavaScript对象API的基础。

代理的应用场景是不可限量的。开发者使用它可以创建出各种编码模式，比如（但远远不限于）跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定，以及可观察对象。

# 第十一章 期约与异步函数

## **11.1** 异步编程

同步行为和异步行为的对立统一是计算机科学的一个基本概念。特别是在JavaScript这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他令，系统也能保持稳定，那么这样做就是务实的。

重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用

### **11.1.1** 同步与异步

同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地（如寄存器或系统内存）的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态（比如变量的值）。

```
let x = 3; 
x = x + 4;
```

在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。

这两行JavaScript代码对应的低级指令（从JavaScript到x86）并不难想象。首先，操作系统会在栈内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。

相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待

```
let x = 3; 
setTimeout(() => x = x + 4, 1000);
```

### **11.1.2** 以往的异步编程模式

异步行为是JavaScript的基础，但以前的实现不理想。在早期的JavaScript中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。假设有以下异步函数，使用了 setTimeout 在一秒钟之后执行某些操作：

```
function double(value) { 
setTimeout(() => setTimeout(console.log, 0, 
value * 2), 1000); 
}
double(3); 
// 6**（大约**1000毫秒之后）
```

这里的代码没什么神秘的，但关键是理解为什么说它是一个异步函数。 setTimeout 可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000毫秒之后，JavaScript运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对JavaScript代码就完全不可见了。还有一点，double() 函数在 setTimeout 成功调度异步操作之后会立即退出。

#### 1. 异步返回值

假设 setTimeout 操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。

```
function double(value, callback) { 
setTimeout(() => callback(value * 2), 
1000); 
}double(3, (x) => console.log(`I was given: 
${x}`)); 
// I was given: 6（大约1000毫秒之后）
```

这里的 setTimeout 调用告诉JavaScript运行时在1000毫秒之后把一个函数推到消息队列上。这个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的

#### 2.异步返回值

异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调：

```
function double(value, success, failure) { 
setTimeout(() => { 
try { 
if (typeof value !== 'number') { 
throw 'Must provide number as first
argument'; 
}
success(2 * value); 
} catch (e) { 
failure(e); 
} 
}, 1000); 
}
const successCallback = (x) =>console.log(`Success: ${x}`); 
const failureCallback = (e) => 
console.log(`Failure: ${e}`); 
double(3, successCallback, failureCallback); 
double('b', successCallback, 
failureCallback); 
// Success: 6（大约1000毫秒之后）
// Failure: Must provide number as first
argument（大约1000毫秒之后）
```

这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。

#### 3.嵌套异步回调

如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。在实际的代码中，这就要求嵌套回调：

```
function double(value, success, failure) { 

setTimeout(() => { 

try { 

if (typeof value !== 'number') { 

throw 'Must provide number as first

argument'; 

}

success(2 * value); 

} catch (e) {failure(e); 

} 

}, 1000); 

}

const successCallback = (x) => { 

double(x, (y) => console.log(`Success: 

${y}`)); 

};

const failureCallback = (e) => 

console.log(`Failure: ${e}`); 

double(3, successCallback, failureCallback); 

// Success: 12**（大约**1000毫秒之后
```

显然，随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。

## 11 小结

长期以来，掌握单线程JavaScript运行时的异步行为一直都是个艰巨的任务。随着ES6新增了期约和ES8新增了异步函数，ECMAScript的异步编程特性有了长足的进步。通过期约和async/await，不仅可以实现之前难以实现或不可能实现的任务，而且也能写出更清晰、简洁，并且容易理解、调试的代码。

期约的主要功能是为异步代码提供了清晰的抽象。可以用期约表示异步执行的代码块，也可以用期约表示异步计算的值。在需要串行异步代码时，期约的价值最为突出。作为可塑性极强的一种结构，期约可以被序列化、连锁使用、复合、扩展和重组。

异步函数是将期约应用于JavaScript函数的结果。异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函数可以说是现代JavaScript工具箱中最重要的工具之一。