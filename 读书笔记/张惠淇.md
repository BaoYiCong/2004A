# 一、什么是JavaScript
（于书中摘录理解）
### 1-1、JavaScript实现
虽然JavaScript和ECMAScript基本上是同义词，但JavaScript远不限于ECMA-262所定义的那样。完整的JavaScript实现包含：
-  核心（ECMAScript）
-  文档对象模型（DOM）
-  浏览器对象模型（BOM）

Web浏览器只是ECMAScript实现可能存在的一种宿主环境（hostenvironment）。宿主环境提供ECMAScript的基准实现和与环境自身交互必需的扩展。扩展（比如DOM）使用ECMAScript核心类型和语法，提供特定于环境的额外功能。其他宿主环境还有服务器端JavaScript平台Node.js和即将被淘汰的Adobe Flash。
在基本层面，描述这门语言：语法，类型，语句，关键字，保留字，操作符，全局对象

ECMAScript只是对实现这个规范描述的所有方面的一门语言的称呼。JavaScript实现了ECMAScript，而Adobe ActionScript同样也实现了
ECMAScript。


### 1-2、DOM
文档对象模型（DOM，Document Object Model）是一个应用编程接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节
点，包含不同的数据。

DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用DOM API，可以轻松地删除、添加、替换、修改节点。

### 1-3、BOM
IE3和Netscape Navigator 3提供了**浏览器对象模型**（BOM） API，用于支持访问和操作浏览器的窗口。使用BOM，开发者可以操控浏览器显示页面之外的部分。而BOM真正独一无二的地方，当然也是问题最多的地方，就是它是唯一一个没有相关标准的JavaScript实现。HTML5改变了这个局面，这个版本的HTML以正式规范的形式涵盖了尽可能多的BOM特性。由于HTML5的出现，之前很多与BOM有关的问题都迎刃而解了。

总体来说，BOM主要针对浏览器窗口和子窗口（frame），不过
人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。下面就是这样一些扩展：

 - 弹出新浏览器窗口的能力；
 - 移动、缩放和关闭浏览器窗口的能力；
 - navigator 对象，提供关于浏览器的详尽信息；
 - location 对象，提供浏览器加载页面的详尽信息；
 - screen 对象，提供关于用户屏幕分辨率的详尽信息；
 - performance 对象，提供浏览器内存占用、导航行为和时间统
 - 计的详尽信息；
 - 对cookie的支持；
 - 其他自定义对象，如 XMLHttpRequest 和IE的
 - ActiveXObject 


# 二、HTML中的JavaScript
### 2-1、`` script ``元素
将JavaScript插入HTML的主要方法是使用  script  元素。这
个元素是由网景公司创造出来，并最早在Netscape Navigator 2中实现
的。后来，这个元素被正式加入到HTML规范。  script  元素有下
列8个属性。

- ``async``：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。
  
 - charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。

 - crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin="anonymous" 配置文件请求不必设置凭据标志。 crossorigin="use-credentials" 设置凭据标志，意
味着出站请求会包含凭据。

 - defer ：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。

 - integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，Subresource Intergrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，Content Delivery Network）不会提供恶意内容。

 - language ：废弃。最初用于表示代码块中的脚本语言（如 "JavaScript" 、 "JavaScript1.2" 或 "VBScript" ）。大多数浏览器都会忽略这个属性，不应该再使用它。

 - src ：可选。表示包含要执行的代码的外部文件。

 - type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。

包含在 script 内的代码会被从上到下解释

### 2-2、
使用了 src 属性的  script  元素不应该再在 script  和  /script  标签中再包含其他JavaScript代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。

 script  元素的一个最为强大、同时也备受争议的特性是，它可以包含来自外部域的JavaScript文件。跟  img  元素很像， script  元素的 src 属性可以是一个完整的URL，而且这个URL指向的资源可以跟包含它的HTML页面不在同一个域中


### 2-3、文档模式
可以使用 doctype 切换文档模式。最初的文档模式有两种：**混杂模式**（quirks mode）和**标准模式**（standards mode）。前者让IE像IE5一样（支持一些非标准的特性），后者让IE具有兼容标准的行为。虽然这两种模式的主要区别只体现在通过CSS渲染的内容方面，但对JavaScript也有一些关联影响，或称为副作用。本书会经常提到这些副作用。

IE初次支持文档模式切换以后，其他浏览器也跟着实现了。随着浏览器的普遍实现，又出现了第三种文档模式：**准标准模式**（almost
standards mode）。这种模式下的浏览器支持很多标准的特性，但是没有标准规定得那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。

混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关。这种约定并不合理，因为混杂模式在不同浏览器中的差异非常大，不使用黑科技基本上就没有浏览器一致性可言。


### 2-4、noscript 元素
针对早期浏览器不支持JavaScript的问题，需要一个页面优雅降级的处理方案。最终， <noscript> 元素出现，被用于给不支持JavaScript的浏览器提供替代内容。虽然如今的浏览器已经100%支持JavaScript，但对于禁用JavaScript的浏览器来说，这个元素仍然有它的用处。

<noscript> 元素可以包含任何可以出现在 <body> 中的HTML元素， <script> 除外。在下列两种情况中，浏览器将显示包含在 <noscript> 中的内容：7
1. 浏览器不支持脚本
2. 浏览器对脚本的支持被关闭 


# 三、语法基础
### 3-1、语法
首先要知道的是，ECMAScript中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变量 Test 是两个不同的变量。类似地， typeof 不能作为函数名，因为它是一个关键字（后面会介绍）。但 Typeof 是一个完全有效的函数名。



### 3-2、标识符

所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：
 - 第一个字符必须是一个字母、下划线（ _ ）或美元符号（ $ ）；
 - 剩下的其他字符可以是字母、下划线、美元符号或数字。

标识符中的字母可以是扩展ASCII（Extended ASCII）中的字母，也可以是Unicode的字母字符，如À和Æ（但不推荐使用）。

按照惯例，ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写


### 3-3、严格模式
ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误




### 3-4、关键字与保留字
ECMA-262描述了一组保留的关键字，这些关键字有特殊用途，比如表示控制语句的开始和结束，或者执行特定的操作

**ECMA-262第6版规定的所有关键字：**

````
break			  do	      	 in		       	 typeof
case	 		  else	      	 instanceof      var
catch			  export	     new			 void
class			  extends        return			 while
const			  finally	     super			 with
continue	 	  for		     switch			 yield
debugger	 	  function	     this
default			  if		     throw
delete	   		  import try
````


规范中也描述了一组未来的保留字，同样不能用作标识符或属性名。虽然保留字在语言中没有特定用途，但它们是保留给将来做关键字用的

### 3-5、变量
ECMAScript变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有3个关键字可以声明变量： var 、 const 和 let 。其中， var 在CMAScript的所有版本中都可以使用，而 const 和 let 只能在ECMAScript 6及更晚的版本中使用



### 3-6、var关键字

1. var声明作用域
关键的问题在于，使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁


2. var 声明提升
使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部



### 3-7、let 声明
let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是， let 声明的范围是块作用域，而 var 声明的范围是函数作用域。

1. 暂时性死区
let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。

2. 全局声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（ var 声明的变量则会）

3. 条件声明
在使用 var 声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它

4. for 循环中的 let 声明
在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外部

5. const 声明
const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。

### 3-8、声明风格及最佳实践
ECMAScript 6增加 let 和 const 从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。行为怪异的 var 所造成的各种问题，已经让JavaScript社区为之苦恼了很多年。随着这两个新关键字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。
1. 不使用 var
有了 let 和 const ，大多数开发者会发现自己不再需要 var了。限制自己只使用 let 和 const 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。
2. const 优先， let 次之
使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修改时，再使用 let 。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。

# 四、数据类型
ECMAScript有6种简单数据类型（也称为原始类型）：Undefined 、 Null 、 Boolean 、 Number 、 String 和Symbol 。 Symbol （符号）是ECMAScript 6新增的。还有一种复杂数据类型叫 Object （对象）。 Object 是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部数据。但ECMAScript的数据类型很灵活，一种数据类型可以当作多种数据类型来使用


### 4-1、typeof 操作符
因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。 typeof 操作符就是为此而生的。对一个值使用 typeof 操作符会返回下列字符串之一：
"undefined" 表示值未定义；
"boolean" 表示值为布尔值；
"string" 表示值为字符串；
"number" 表示值为数值；
"object" 表示值为对象（而不是函数）或 null ；
"function" 表示值为函数；
"symbol" 表示值为符号。



### 4-2、Undefined 类型
Undefined 类型只有一个值，就是特殊值 undefined 。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值

即使未初始化的变量会被自动赋予 undefined 值，但我们仍然建议在声明变量的同时进行初始化。这样，当 typeof 返回 "undefined" 时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。


### 4-3、Null 类型
Null 类型同样只有一个值，即特殊值 null 。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 "object" 的原因

在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用

用等于操作符（ == ）比较 null 和 undefined 始终返回true 。但要注意，这个操作符会为了比较而转换它的操作数。
即使 null 和 undefined 有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为 undefined 。但null 不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用 null 来填充该变量。这样就可以保持null 是空对象指针的语义，并进一步将其与 undefined 区分开来。
null 是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是 null 这个字面值，而不仅仅是假值


### 4-4、Boolean 类型
Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值： true 和 false 。这两个布尔值不同于数值，因此 true 不等于1， false 不等于0

注意：布尔值字面量 true 和 false 是区分大小写的，因此True 和 False （及其他大小混写形式）是有效的标识符，但不是布尔值。


### 4-5、Number 类型
ECMAScript中最有意思的数据类型或许就是 Number 了。Number 类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式

1. 浮点值
要定义浮点值，数值中必须包含小数点，而且小数点后面必须至
少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。

2. 值的范围
由于内存的限制，ECMAScript并不支持表示这个世界上的所有数值。ECMAScript可以表示的最小数值保存在Number.MIN_VALUE 中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity （无穷）值。任何无法表示的负数以 -Infinity （负无穷大）表示，任何无法表示的正数以 Infinity （正无穷大）表示。如果计算返回正 Infinity 或负 Infinity ，则该值将不能再进一步用于任何计算。这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用 isFinite() 函数


3. NaN
有一个特殊的数值叫 NaN ，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回NaN

4. 数值转换
有3个函数可以将非数值转换为数值： Number() 、parseInt() 和 parseFloat() 。 Number() 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。
### 4-6、 NaN
有一个特殊的数值叫 NaN ，意思是“不是数值”（Not aNumber），用于表示本来要返回数值的操作失败了（而不是抛出错误）。
### 4-7、数值转换
有3个函数可以将非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。 Number() 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。Number() 函数基于如下规则执行转换。布尔值， true 转换为1， false 转换为0。
数值，直接返回。null ，返回0。 undefined ，返回 NaN 。
### 4-8、String 类型 
String （字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（"）、单引号（'）或反引号（`）标示，
1. 字符字面量
字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符

1. 字符串的特点
ECMAScript中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量

3. 转换为字符串
有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 toString() 方法。这个方法唯一的用途就是返回当前值的字符串等价物

4. 模板字面量
ECMAScript 6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串

5. 字符串插值
模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值

6. 模板字面量标签函数
模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，

7. 原始字符串
使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。为此，可以使用默认的 String.raw 标签函数





# 五、操作符
ECMA-262描述了一组可用于操作数据值的操作符，包括数学操作符（如加、减）、位操作符、关系操作符和相等操作符等。ECMAScript中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf() 和 / 或 toString() 方法来取得可以计算的值。3.5.1 一元操作符只操作一个值的操作符叫一元操作符（unary operator）。一元操作符是ECMAScript中最简单的操作符。

### 5-1、一元操作符

1. 递增 / 递减操作符
递增和递减操作符直接照搬自C语言，但有两个版本：前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。前缀递增操作符会给数值加1，把两个加号（ ++ ）放到变量前头即可

2.一元加和减
一元加和减操作符对大多数开发者来说并不陌生，它们在ECMAScript中跟在高中数学中的用途一样。一元加由一个加号（ + ）表示，放在变量前头，对数值没有任何影响

### 5-2、位操作符
1. 按位非
按位非操作符用波浪符（ ~ ）表示，它的作用是返回数值的一补数。按位非是ECMAScript中为数不多的几个二进制数学操作符之一

2. 按位与
按位与操作符用和号（ & ）表示，有两个操作数。本质上，按位与就是将两个数的每一个位对齐，然后基于真值表中的规则，对每一位执行相应的与操作。

3. 按位或
按位或操作符用管道符（ | ）表示，同样有两个操作数。

4. 按位异或
按位异或用脱字符（ ^ ）表示，同样有两个操作数

5. 左移
左移操作符用两个小于号（ << ）表示，会按照指定的位数将数值的所有位向左移动。比如，如果数值2（二进制10）向左移5位，就会得到64（二进制1000000）

6. 有符号右移
有符号右移由两个大于号（ >> ）表示，会将数值的所有32位都向右移，同时保留符号（正或负）。有符号右移实际上是左移的逆运算

7. 无符号右移
无符号右移用3个大于号表示（ >>> ），会将数值的所有32位都向右移。对于正数，无符号右移与有符号右移结果相同

### 5-3、布尔操作符
1. 逻辑非
逻辑非操作符由一个叹号（ ! ）表示，可应用给ECMAScript中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反

2. 逻辑与
逻辑与操作符由两个和号（ && ）表示，应用到两个值

3. 逻辑或
逻辑或操作符由两个管道符（ || ）表示

### 5-4、乘性操作符
1. 乘法操作符
乘法操作符由一个星号（ * ）表示，可以用于计算两个数值的乘积。

2. 除法操作符
除法操作符由一个斜杠（ / ）表示，用于计算第一个操作数除以第二个操作数的商

3. 取模操作符
 - 取模（余数）操作符由一个百分比符号（ % ）表示
 - 如果操作数是数值，则执行常规除法运算，返回余数。
 - 如果被除数是无限值，除数是有限值，则返回 NaN 。
 - 如果被除数是有限值，除数是0，则返回 NaN 。
 - 如果是 Infinity 除以 Infinity ，则返回 NaN 。
 - 如果被除数是有限值，除数是无限值，则返回被除数。
 - 如果被除数是0，除数不是0，则返回0。
 - 如果有不是数值的操作数，则先在后台用 Number() 函数将其转换为数值，然后再应用上述规则。

# 六、语句
ECMA-262描述了一些语句（也称为流控制语句），而ECMAScript中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。

### 6-1、do-while 语句
do-while 语句是一种后测试循环语句，即循环体中的代码执
行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行
一次

### 6-2、while 语句
while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此， while 循环体内的代码有可能不会执行




# 七、函数
函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用function 关键字声明，后跟一组参数，然后是函数体。

ECMAScript中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 return 语句来返回函数的值，用法是后跟要返回的值

函数 sum() 会将两个值相加并返回结果。注意，除了 return语句之外没有任何特殊声明表明该函数有返回值

严格模式对函数也有一些限制：
函数不能以 eval 或 arguments 作为名称；
函数的参数不能叫 eval 或 arguments ；
两个函数的参数不能叫同一个名称。

# 八、变量，作用域与内存
### 4-1、原始值与引用值
ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。

在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。上一章讨论了6种原始值： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。

引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实
际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的

注意：在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。

1. 动态属性
原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法

2. 复制值
除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。
 - 在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来


3. 传递参数
ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递

在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部

4. 确定类型
前一章提到的 typeof 操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式。如果值是对象或 null ，那么typeof 返回 "object" 

按照定义，所有引用值都是 Object 的实例，因此通过instanceof 操作符检测任何引用值和 Object 构造函数都会返回 true 。类似地，如果用 instanceof 检测原始值，则始终会返回 false ，因为原始值不是对象。

注意 typeof 操作符在用于检测函数时也会返回 "function" 。当在Safari（直到Safari 5）和Chrome（直到Chrome 7）中用于检测正则表达式时，由于实现细节的原因，typeof 也会返回 "function" 。ECMA-262规定，任何实现内部 [[Call]] 方法的对象都应该在 typeof 检测时返回 "function" 。因为上述浏览器中的正则表达式实现了这个方法，所以 typeof 对正则表达式也返回 "function" 。在IE和Firefox中， typeof 对正则表达式返回 "object" 。




### 4-2、执行上下文与作用域
执行上下文（以上简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而
这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
全局上下文是最外层的上下文。根据ECMAScript实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 window 对象（第12章会详细介绍），因此所有通过
var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。
每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript
程序的执行流就是通过这个上下文栈进行控制的。上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activationobject）用作变量对象。活动对象最初只有一个定义变量：arguments 。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象

1. 作用域链增强
虽然执行上下文主要有全局上下文和函数上下文两种（ eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码
执行后会被删除。

2. 变量声明
ES6之后，JavaScript的变量声明经历了翻天覆地的变化。直到
ECMAScript 5.1， var 都是声明变量的唯一关键字。ES6不仅增加了
let 和 const 两个关键字，而且还让这两个关键字压倒性地超越
var 成为首选。
- 使用 var 的函数作用域声明
在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文
``注意：未经声明而初始化变量是JavaScript编程中一个非常常见的错误，会导致很多问题。为此，读者在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错``
var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升”（hoisting）。提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提升也会导致合法却奇怪的现象，即在变量声明之前使用变量。

 - 使用 let 的块级作用域声明
ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号 {} 界定。换句话说， if 块、 while 块、 function块，甚至连单独的块也是 let 声明变量的作用域。

- 使用 const 的常量声明
除了 let ，ES6同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值

``注意 开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用 const 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的bug``

### 4-3、垃圾回收
JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。

我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：标记清理和引用计数。

1. 标记清理
JavaScript最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。
给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。
垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。
到了2008年，IE、Firefox、Opera、Chrome和Safari都在自己的JavaScript实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异。

2. 引用计数
另一种没那么常用的垃圾回收策略是引用计数（referencecounting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序
下次运行的时候就会释放引用数为0的值的内存。引用计数最早由Netscape Navigator 3.0采用，但很快就遇到了严重的问题：循环引用。所谓循环引用，就是对象A有一个指针指向对象B，而对象B也引用了对象A。

- 把变量设置为 null 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。
为了补救这一点，IE9把BOM和DOM对象都改成了JavaScript对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。


3. 内存泄漏
写得不好的JavaScript可能出现难以察觉且有害的内存泄漏问题。在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript中的内存泄漏大部分是由不合理的引用导致的

JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有以下特点。原始值大小固定，因此保存在栈内存上。
从一个变量到另一个变量复制原始值会创建该值的第二个副本。引用值是对象，存储在堆内存上。包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。
typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。
执行上下文分全局上下文、函数上下文和块级上下文。
代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。
函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。
全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。
变量的执行上下文用于确定什么时候释放内存。

JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript的垃圾回收程序可以总结如下。
离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。
JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）。
引用计数在代码中存在循环引用时会出现问题。
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。



# 九、基本引用类型
引用值（或者对象）是某个特定引用类型的实例。在ECMAScript中，引用类型是把数据和功能组织到一起的结构，经常被人错误地称作“类”。虽然从技术上讲JavaScript是一门面向对象语言，但ECMAScript缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。

``注意 引用类型虽然有点像类，但跟类并不是一个概念。为避免混淆，本章后面不会使用术语“类”。``

对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数


### 9-1、Date
ECMAScript的 Date 类型参考了Java早期版本中的java.util.Date 。为此， Date 类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式， Date 类型可以精确表示1970年1月1日之前及之后285 616年的日期。

- 要创建日期对象，就使用 new 操作符来调用 Date 构造函数：
``let now = new Date();``

- 在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX纪元1970年1月1日午夜之后的毫秒数）。ECMAScript为此提供了两个辅助方法： Date.parse() 和 Date.UTC() 。
Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262第5版定义了Date.parse() 应该支持的日期格式，填充了第3版遗留的空白

1. 继承的方法
与其他类型一样， Date 类型重写了 toLocaleString() 、toString() 和 valueOf() 方法。但与其他类型不同，重写后这些方法的返回值不一样。 Date 类型的 toLocaleString() 方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）。 toString() 方法通常返回带时区信息的日期和时间，而时间也是以24小时制（0~23）表示的。

2. 日期格式化方法
 - Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：
 - toDateString() 显示日期中的周几、月、日、年（格式特定于实现）；
 - toTimeString() 显示日期中的时、分、秒和时区（格式特定于实现）；
 - toLocaleDateString() 显示日期中的周几、月、日、年（格式特定于实现和地区）；
 - toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实现）；
 - toUTCString() 显示完整的UTC日期（格式特定于实现）。
 - 这些方法的输出与 toLocaleString() 和 toString() 一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。

注意 还有一个方法叫 toGMTString() ，这个方法跟toUTCString() 是一样的，目的是为了向后兼容。不过，规范建议新代码使用 toUTCString() 。

3. 日期/时间组件方法
Date 类型剩的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC日期”，指的是没有时区偏移（将日期转换为GMT）时的日期。


| 方法                               | 说明                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| getTime()                          | 返回日期的毫秒表示；与valueOf() 相同                         |
| setTime(milliseconds)              | 设置日期的毫秒表示，从而修改整个日期                         |
| getFullYear()                      | 返回4位数年（即2019而不是19）                                |
| getUTCFullYear()                   | 返回UTC日期的4位数年                                         |
| setFullYear( year )                | 设置日期的年（ year 必须是4位数）                            |
| 导setUTCFullYear( year )           | 设置UTC日期的年（ year 必须是4位数）                         |
| getMonth()                         | 返回日期的月（0表示1月，11表示12月）                         |
| getUTCMonth()                      | 返回UTC日期的月（0表示1月，11表示12月）                      |
| setMonth( month)                   | （ month 为大于0的数值，大于11加年）                         |
| setUTCMonth( month）               | 设置UTC日期的月（ month 为大于0的数值，大于11加年）          |
| getDate()                          | 返回日期中的日（1~31）                                       |
| getUTCDate()                       | 返回UTC日期中的日（1~31）                                    |
| setDate( date)                     | 设置日期中的日（如果 date 大于该月天数，则加月）             |
| setUTCDate( date                   | 设置UTC日期中的日（如果date 大于该月天数，则加月）           |
| getDay()                           | 返回日期中表示周几的数值（0表示周日，6表示周六）             |
| getUTCDay()                        | 返回UTC日期中表示周几的数值（0表示周日，6表示周六）          |
| getHours()                         | 返回日期中的时（0~23）                                       |
| getUTCHours()                      | 返回UTC日期中的时（0~23）                                    |
| setHours( hours )                  | 设置日期中的时（如果 hours大于23，则加日）                   |
| setUTCHours( hours )               | 设置UTC日期中的时（如果hours 大于23，则加日）                |
| getMinutes()                       | 返回日期中的分（0~59）                                       |
| getUTCMinutes()                    | 返回UTC日期中的分（0~59）                                    |
| setMinutes( minutes)               | 设置日期中的分（如果minutes 大于59，则加时）                 |
| setUTCMinutes( minutes ）          | 设置UTC日期中的分（如果minutes 大于59，则加时）              |
| getSeconds()                       | 返回日期中的秒（0~59）                                       |
| getUTCSeconds()                    | 返回UTC日期中的秒（0~59）                                    |
| setSeconds( seconds )              | 设置日期中的秒（如果seconds 大于59，则加分）                 |
| setUTCSeconds( seconds)            | 设置UTC日期中的秒（如果seconds 大于59，则加分）              |
| getMilliseconds()                  | 返回日期中的毫秒                                             |
| getUTCMilliseconds()               | 返回UTC日期中的毫秒                                          |
| setMilliseconds( milliseconds）    | 设置日期中的毫秒                                             |
| setUTCMilliseconds( milliseconds ) | 设置UTC日期中的毫秒                                          |
| getTimezoneOffset()                | 返回以分钟计的UTC与本地时区的偏移量（如美国EST即“东部标准时间”返回300，进入夏令时的地区可能有所差异） |

### 9-2、RegExp
ECMAScript通过 RegExp 类型支持正则表达式。正则表达式使用类似Perl的简洁语法来创建：
``let expression = /pattern/flags;``
这个正则表达式的 pattern （模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式
可以带零个或多个 flags （标记），用于控制正则表达式的行为。下面给
出了表示匹配模式的标记

 - g ：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
 - i ：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
 - m ：多行模式，表示查找到一行文本末尾时会继续查找。
 - y ：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
 - u ：Unicode模式，启用Unicode匹配。
 - s ： dotAll 模式，表示元字符 . 匹配任何字符（包括 \n 或\r ）。


1. RegExp 实例属性
每个 RegExp 实例都有下列属性，提供有关模式的各方面信息。
- global ：布尔值，表示是否设置了 g 标记。
- ignoreCase ：布尔值，表示是否设置了 i 标记。
- unicode ：布尔值，表示是否设置了 u 标记。
- sticky ：布尔值，表示是否设置了 y 标记。
- lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。
- multiline ：布尔值，表示是否设置了 m 标记。
- dotAll ：布尔值，表示是否设置了 s 标记。
- source ：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
- flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。


2. RegExp 实例方法
RegExp 实例的主要方法是 exec() ，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返
回包含第一个匹配信息的数组；如果没找到匹配项，则返回 null 。返回
的数组虽然是 Array 的实例，但包含两个额外的属性： index 和
input 。 index 是字符串中匹配模式的起始位置， input 是要查找的
字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表
达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个
元素。

3. RegExp 构造函数属性
RegExp 构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了 RegExp 构造函数的属性。


| 全名         | 简写 | 说明                                     |
| ------------ | ---- | ---------------------------------------- |
| input        | $_   | 最后搜索的字符串                         |
| lastMatch    | $&   | 最后匹配的文本                           |
| lastParen    | $+   | 最后匹配的捕获组                         |
| leftContext  | $`   | input 字符串中出现在lastMatch 前面的文本 |
| rightContext | $'   | input 字符串中出现在lastMatch 后面的文本 |

4. 模式局限
虽然ECMAScript对正则表达式的支持有了长足的进步，但仍然缺少Perl
语言中的一些高级特性。参考Regular-Expressions.info网站


### 9-3、原始值包装类型
为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：Boolean 、 Number 和 String 。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。

1. Boolean
Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入 true 或 false 




### 9-4、单例内置对象
ECMA-262对内置对象的定义是“任何由ECMAScript实现提供、与宿主
环境无关，并在ECMAScript程序开始执行时就存在的对象”。这就意味着，
开发者不用显式地实例化内置对象，因为它们已经实例化好了。前面我们已
经接触了大部分内置对象，包括 Object 、 Array 和 String 。本节介
绍ECMA-262定义的另外两个单例内置对象： Global 和 Math 。

1. Global
Global 对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。ECMA-262规定 Global 对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性 。本书前面介绍的函数，包括 isNaN() 、 isFinite() 、 parseInt() 和parseFloat() ，实际上都是 Global 对象的方法。除了这些，Global 对象上还有另外一些方法。

2. URL编码方法
encodeURI() 和 encodeURIComponent() 方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。ecnodeURI() 方法用于对整个URI进行编码，比如 "www.wrox.com/illegal value.js" 。而encodeURIComponent() 方法用于编码URI中单独的组件，比如前面URL中的 "illegal value.js" 。这两个方法的主要区别是，encodeURI() 不会编码属于URL组件的特殊字符，比如冒号、斜杠、问号、井号，而 encodeURIComponent() 会编码它发现的所有非标准字符

3. eval() 方法
最后一个方法可能是整个ECMAScript语言中最强大的了，它就是eval() 。这个方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。

4.Global 对象属性
Global 对象有很多属性，其中一些前面已经提到过了。像undefined 、 NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和Function ，也都是 Global 对象的属性。
下表列出了所有这些属性：

| 属性           | 说明                      |
| -------------- | ------------------------- |
| undefined      | 特殊值undefined           |
| NaN            | 特殊值NaN                 |
| Infinity       | 特殊值Infinity            |
| Object         | Object的构造函数          |
| Array          | Array的构造函数           |
| Function       | Function的构造函数        |
| Boolean        | Boolean的构造函数         |
| String         | String的构造函数          |
| Number         | Number的构造函数          |
| Date           | Date的构造函数            |
| RegExp         | RegExp的构造函数          |
| Symbol         | Symbol的构造函数          |
| Error          | Error的构造函数           |
| EvalError      | EvalError的构造函数       |
| RangeError     | RangeError的构造函数      |
| ReferenceError | ReferenceError 的构造函数 |
| SyntaxError    | SyntaxError的构造函数     |
| TypeError      | TypeError 的构造函数      |
| URIError       | URIError的构造函数        |

5. window 对象
虽然ECMA-262没有规定直接访问 Global 对象的方式，但浏览器将window 对象实现为 Global 对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性

6. Math
ECMAScript提供了 Math 对象作为保存数学公式、信息和计算的地方。 Math 对象提供了一些辅助计算的属性和方法。

注意： Math 对象上提供的计算要比直接在JavaScript实现的快得多，因
为 Math 对象上的计算使用了JavaScript引擎中更高效的实现和处理器指
令。但使用 Math 计算的问题是精度会因浏览器、操作系统、指令集和
硬件而异。  

 - Math 对象属性
Math 对象有一些属性，主要用于保存数学中的一些特殊值 


| 属性         | 说明                |
| ------------ | ------------------- |
| Math.E       | 自然对数的基数e的值 |
| Math.LN10    | 10为底的自然对数    |
| Math.LN2     | 2为底的自然对数     |
| Math.LOG2E   | 以2为底e的对数      |
| Math.LOG10E  | 以10为底e的对数     |
| Math.PI      | π的值               |
| Math.SQRT1_2 | 1/2的平方根         |
| Math.SQRT2   | 2的平方根           |

 - min() 和 max() 方法
Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。min() 和 max() 方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数

# 十、集合引用类型
### 10-1、Object
1. 显式地创建Object的实例有两种方式。第一种是使用new操作符和Object构造函数，另一种方式是使用对象字面量表示法。
2. 虽然属性通常是通过点语法来访问的，这也是面向对象语言的惯例，但也可以使用中括号来访问属性。在使用中括号时，要在括号内使用属性名的字符串形式。
3. 通常，点语法是首选的属性访问方式，除非访问属性时必须使用变量。
### 10-2、Array
创建数组
1. 有几种基本的方式可以创建数组。一种是使用Array构造函数，例如：let colors = new Array（）;也可以给Array构造函数替换要保存的元素
2. 这时候只是有点问题了，因为如果这个值是数值，则创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组。
3. 在使用Array构造函数时，也可以省略new操作符，结果是一样的：
let colors = Array（3）; //创建一个包含3个元素的数组
让名字= Array（“ Greg”）; //创建一个只包含一个元素，即串联“ Greg”的数组
4. 另一种创建副本的方式是使用多重字面量（数组文字）表示法。分散字面量是在中括号中包含以逗号分隔的元素列表：
让颜色= [“红色”，“蓝色”，“绿色”]；//创建一个包：含3个元素的层叠
让名字= []; //创建一个空副本
令值= [1,2，]; //创建一个包
含2个元素的层叠

数组空位
1. const options = [,,,,,]; //创建包含5个元素的数组
2. console.log（options.length）; // 5
3. console.log（options）; // [,,,,,]

数组索引
要取得或设置数组的值，需要使用中括号并提供相应值的数字索引：
让颜色= [“红色”，“蓝色”，“绿色”]；//定义一个字符串数组
alert（colors [0]）; //显示第一项
colors [2] =“黑色”；//修改第三项
colors [3] =“棕色”；//添加第四项

检测数组
1. 在只有一个网页（因此只有一个整体作用域）的情况下，使用操作符就足矣的实例：
if（value instanceof Array）{//操作数组}
2. 如果网页里有多个框架，则可能涉及两个不同的片段执行数组，因此就会有两个不同版本的数组。如果要把数组从一个框架传给另一个框架，则这个数组为解决这个问题，ECMAScript提供了Array.isArray（）方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在这之上执行某些中创建的：
if（Array.isArray（value））{//操作数组}

迭代器方法
在ES6中，Array的原型上暴露了3个用于检索副本内容的方法：keys（），values（）和entry（）。keys（）返回索引的迭代器，values（）返回层叠元素的迭代器，而entry（）返回索引/值对的迭代器：
const a = [“ foo”，“ bar”，“ baz”，“ qux”]；//因为这些方法都返回迭代器，所以可以将它们的内容
//通过Array.from（）直接转换为副本实例
const aKeys = Array.from（a.keys（））;
 const aValues = Array.from（a.values（））; 
 const aEntries = Array.from（a.entries（））; 
console.log（aKeys）; // [0，1，2，3]
console.log（aValues）; // [“ foo”，“ bar”，“ baz”，“ qux”]
console.log（aEntries）; // [[0，“ foo”]，[1，“ bar”]，[2，“ baz”]，[3，“ qux”]]

转换方法
1. 所有对象都有toLocaleString（），toString（）和valueOf（）方法。其中，valueOf（）返回的还是嵌套本身。而toString（）返回由多个中每个值的等效字符串拼接而成的一个逗号分隔的字符串。初始，对数组的每个值都会调用其toString（）方法，以得到最终的字符串。
例子：
让颜色= [“红色”，“蓝色”，“绿色”]；//创建一个包含3个字符串的数组
alert（colors.toString（））; //红色，蓝色，绿色
alert（colors.valueOf（））; //红色，蓝色，绿色
警报（颜色）；//红色，蓝色，绿色
2. toLocaleString（）方法也可能返回跟toString（）和valueOf（）相同的结果，但也不一定。在调用称为的toLocaleString（）方法时，会得到一个逗号分隔的枚举值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的toLocaleString（）方法，而不是toString（）方法：

````j
let person1 = {
	toLocaleString（）{
		return "Nicholas" ;
		}，
	toString（）{
		return “Nicholas” ;
		} 
	};
	让person2 = {
	toLocaleString（）{
		return “ Grigorios ” ;
		}，toString（）{
		 return “Greg” ;
		 } 
		};
		 let people = [person1, person2];
		 alert(people); // Nicholas,Greg
		 alert(people.toString()); // Nicholas,Greg
		 alert(people.toLocaleString()); //Nikolaos,Grigorios
````

栈方法
因为有了在数据末尾添加数据的push（）方法，所以要模拟模拟就差一个从串行开头获取数据的方法了。这种方法叫shift（） ），它会删除副本的第一项并返回它，然后数组长度减少1。使用shift（）和push（），可以把排列当成一体来使用：

```j
let colors = new Array(); // 创建一个
数组
let count = colors.push("red", "green"); // 推入两项
alert(count); // 2
count = colors.push("black"); // 再推入一项
alert(count); // 3
let item = colors.pop(); // 取得最后一项
alert(item); // black
alert(colors.length); // 2
```

队列方法
1，枚举两个方法可以用来对元素重新排序：reverse（）和sort（）。
reverse（）方法就是将数组元素反向转换：let值= [1、2、3、4、5]；values.reverse（）; 警报（值）; // 5,4,3,2,1
2，sort（）会按照升序重新排列排列的元素，即最小的值在前面，最大的值在后面。变量，sort（）会在每一个上级调用String（）转换函数，然后比较长度来决定顺序。否则排列的元素都是数值，也会先把数组转换为字符串再比较，排序：
let值= [0、1、5、10、15]；values.sort（）; 警报（值）; // 0,1,10,15,5

操作方法
splice（）的主要目的是在多个中间插入元素，但有3种不同的方式使用这个方法：
1.删除：需要给splice（）传递2个参数：要删除的第一个元素的位置和要删除的元素数量。可以从中间删除任意多个元素，例如splice（0，2）会删除前两个元素。
2.插入：需要给splice（）传递3个参数：开始位置，0（要删除的元素数量）和要插入的元素，可以在多个中指定的位置插入元素。四个，第五个参数，乃至任意多个要插入的元
平原。splice（2，0，“ red”，“ green”）会从数组位置2开始插入字符串“ red”和“ green”。
3.替换：splice（）在删除元素的同时可以在指定位置插入新元素，同样要插入3个参数：开始位置，要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定，删除（2，1，“ red”，“ green”）会在位置2删除一个元素，然后从该位置开始向阵列中插入“ red”和“ green”。 splice（）方法始终返回这样一个副本，它包含从多个中被删除的元素（如果没有删除元素，则返回空数组）。


 # 十一、迭代器与生成器

### 11-1、理解迭代
循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。
迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是JavaScript中有序集合的最典型例子。

 - 迭代之前需要事先知道如何使用数据结构。数组中的每一项都只能先通过引用取得数组对象，然后再通过 [] 操作符取得特定索引位置上的项。这种情况并不适用于所有数据结构。
 - 遍历顺序并不是数据结构固有的。通过递增索引来访问数据是特定于数组类型的方式，并不适用于其他具有隐式顺序的数据结构。

在ECMAScript较早的版本中，执行迭代必须使用循环或其他辅助结构。随着代码量增加，代码会变得越发混乱。很多语言都通过原生语言结构解决了这个问题，开发者无须事先知道如何迭代就能实现迭代操作。这个解决方案就是迭代器模式。Python、Java、C++，还有其
他很多语言都对这个模式提供了完备的支持。JavaScript在CMAScript6以后也支持了迭代器模式。

### 11-2、迭代器模式
迭代器模式（特别是在ECMAScript这个语境下）描述了一个方案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序：
```j
// 数组的元素是有限的
// 递增索引可以按序访问每个元素
let arr = [3, 1, 4];
// 集合的元素是有限的
// 可以按插入顺序访问每个元素
let set = new Set().add(3).add(1).add(4);
```
任何实现 Iterable 接口的数据结构都可以被实现 Iterator接口的结构“消费”（consume）。迭代器（iterator）是按需创建的一次性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代其关联可迭代对象的API。迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。这种概念上的分离正是Iterable 和 Iterator 的强大之处。

可迭代协议
实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力。在ECMAScript中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。很多内置类型都实现了 Iterable 接口：字符串、数组、映射、集合、arguments 对象、NodeList 等DOM集合类型检查是否存在默认迭代器属性可以暴露这个工厂函数：
````j
let num = 1;
let obj = {};
// 这两种类型没有实现迭代器工厂函数
console.log(num[Symbol.iterator]); // undefined
console.log(obj[Symbol.iterator]); // undefined
let str = 'abc';
let arr = ['a', 'b', 'c'];
let map = new Map().set('a', 1).set('b',
2).set('c', 3);
let set = new Set().add('a').add('b').add('c');
let els = document.querySelectorAll('div');
// 这些类型都实现了迭代器工厂函数
console.log(str[Symbol.iterator]); // f values(){ [native code] }
console.log(arr[Symbol.iterator]); // f values(){ [native code] }
console.log(map[Symbol.iterator]); // f values(){ [native code] }
console.log(set[Symbol.iterator]); // f values(){ [native code] }
console.log(els[Symbol.iterator]); // f values(){ [native code] }
// 调用这个工厂函数会生成一个迭代器
console.log(str[Symbol.iterator]()); //StringIterator {}
console.log(arr[Symbol.iterator]()); //ArrayIterator {}
console.log(map[Symbol.iterator]()); //MapIterator {}
console.log(set[Symbol.iterator]()); //SetIterator {}
console.log(els[Symbol.iterator]()); //ArrayIterator {}
````
实际写代码过程中，不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：for-of 循环、数组解构、扩展操作符、Array.from()、创建集合、创建映射、Promise.all() 接收由期约组成的可迭代对象、Promise.race() 接收由期约组成的可迭代对象、yield* 操作符，在生成器中使用



迭代器协议
迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器API使用 next() 方法在可迭代对象中遍历数据。每次成功调用 next() ，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next() ，则无法知道迭代器的当前位置。
next() 方法返回的迭代器对象 IteratorReault 包含两个属性： done 和 value 。 done 是一个布尔值，表示是否还可以再次调用 next() 取得下一个值； value 包含可迭代对象的下一个值（ done 为 false ），或者 undefined （ done 为 true ）。
done: true 状态称为“耗尽”。可以通过以下简单的数组来演示：
````j
// 可迭代对象
let arr = ['foo', 'bar'];
// 迭代器工厂函数
console.log(arr[Symbol.iterator]); // f values()
{ [native code] }
// 迭代器
let iter = arr[Symbol.iterator]();
console.log(iter); // ArrayIterator {}
// 执行迭代
console.log(iter.next()); // { done: false,
value: 'foo' }
console.log(iter.next()); // { done: false,
value: 'bar' }
console.log(iter.next()); // { done: true,
value: undefined }
````
这里通过创建迭代器并调用 next() 方法按顺序迭代了数组，直至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达 done: true 状态，后续调用 next() 就一直返回同样的值了：
````j
let arr = ['foo'];
let iter = arr[Symbol.iterator]();
console.log(iter.next()); // { done: false,
value: 'foo' }
console.log(iter.next()); // { done: true,
value: undefined }
console.log(iter.next()); // { done: true,
value: undefined }
console.log(iter.next()); // { done: true,
value: undefined }
````
迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化：
````j
let arr = ['foo', 'bar'];
let iter = arr[Symbol.iterator]();
console.log(iter.next()); // { done: false,
value: 'foo' }
// 在数组中间插入值
arr.splice(1, 0, 'bar');
console.log(iter.next()); // { done: false,
value: 'bar' }
console.log(iter.next()); // { done: false,
value: 'bar' }
console.log(iter.next()); // { done: true,
value: undefined }
````
注意 迭代器维护着一个指向可迭代对象的引用，因此迭代器会阻止垃圾回收程序回收可迭代对象。

“迭代器”的概念有时候容易模糊，因为它可以指通用的迭代，也可以指接口，还可以指正式的迭代器类型。下面的例子比较了一个显式的迭代器实现和一个原生的迭代器实现。
````j
// 这个类实现了可迭代接口（Iterable）
// 调用默认的迭代器工厂函数会返回
// 一个实现迭代器接口（Iterator）的迭代器对象
class Foo {
[Symbol.iterator]() {
return {
next() {
return { done: false, value: 'foo' };
}
}
}
}
let f = new Foo();
// 打印出实现了迭代器接口的对象
console.log(f[Symbol.iterator]()); // { next:
f() {} }
// Array类型实现了可迭代接口（Iterable）
// 调用Array类型的默认迭代器工厂函数
// 会创建一个ArrayIterator的实例
let a = new Array();
// 打印出ArrayIterator的实例
console.log(a[Symbol.iterator]()); // Array
Iterator {}

````
7.2.3 自定义迭代器
与 Iterable 接口类似，任何实现 Iterator 接口的对象都可以作为迭代器使用。

### 11-3、生成器
生成器基础
生成器的形式是一个函数，函数名称前面加一个星号（ * ）表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器。
````j
// 生成器函数声明
function* generatorFn() {}
// 生成器函数表达式
let generatorFn = function* () {}
// 作为对象字面量方法的生成器函数
let foo = {
* generatorFn() {}
}
// 作为类实例方法的生成器函数
class Foo {
* generatorFn() {}
}
// 作为类静态方法的生成器函数
class Bar {
static * generatorFn() {}
}
````
标识生成器函数的星号不受两侧空格的影响：
````j
// 等价的生成器函数：
function* generatorFnA() {}
function *generatorFnB() {}
function * generatorFnC() {}
// 等价的生成器方法：
class Foo {
*generatorFnD() {}
 * generatorFnE() {}
}
````
调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了Iterator 接口，因此具有 next() 方法。调用这个方法会让生成器开始或恢复执行。
````j
function* generatorFn() {}
const g = generatorFn();
console.log(g); // generatorFn
{<suspended>}
console.log(g.next); // f next() { [native
code] }
````
next() 方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次next() 就会让生成器到达 done: true 状态。
````j
function* generatorFn() {}
let generatorObject = generatorFn();
console.log(generatorObject); //
generatorFn {<suspended>}
console.log(generatorObject.next()); // { done:
true, value: undefined }
````
value 属性是生成器函数的返回值，默认值为 undefined ，可以通过生成器函数的返回值指定：
````j
function* generatorFn() {
return 'foo';
}
let generatorObject = generatorFn();
console.log(generatorObject); //
generatorFn {<suspended>}
console.log(generatorObject.next()); // { done:
true, value: 'foo' }
````
生成器函数只会在初次调用 next() 方法后开始执行，如下所示：
````j
function* generatorFn() {
console.log('foobar');
}
// 初次调用生成器函数并不会打印日志
let generatorObject = generatorFn();
generatorObject.next(); // foobar
````
生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的：
````j
function* generatorFn() {}
console.log(generatorFn);
// f* generatorFn() {}
console.log(generatorFn()[Symbol.iterator]);
// f [Symbol.iterator]() {native code}
console.log(generatorFn());
// generatorFn {<suspended>}
console.log(generatorFn()[Symbol.iterator]());
// generatorFn {<suspended>}
const g = generatorFn();
console.log(g === g[Symbol.iterator]());
// true
````

# 十二十二、对象、类与面向对象编程
### 12-1、理解对象
建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法
```j
let person = new Object();
person.name = "Nicholas";
person.age = 29;
person.job = "Software Engineer";
person.sayName = function() {
console.log(this.name);
};
```

这个例子创建了一个名为 person 的对象，而且有三个属性（ name 、 age 和 job ）和一个方法（ sayName() ）。sayName() 方法会显示 this.name 的值，这个属性会解析为person.name 。早期JavaScript开发者频繁使用这种方式创建新对象。几年后，对象字面量变成了更流行的方式。前面的例子如果使用对象字面量则可以这样写：
```j
let person = {
name: "Nicholas",
age: 29,
job: "Software Engineer",
sayName() {
console.log(this.name);
}
};
```
这个例子中的 person 对象跟前面例子中的 person 对象是等价的，它们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在JavaScript中的行为。
12-1-1、 属性的类型
ECMA-262使用一些内部特性来描述属性的特征。这些特性是由为JavaScript实现引擎的规范定义的。因此，开发者不能在JavaScript中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如 [[Enumerable]] 。
属性分两种：数据属性和访问器属性。
1. 数据属性
数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为。[[Configurable]] ：表示属性是否可以通过 delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true ，如前面的例子所示。[[Enumberable]] ：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true ，如前面的例子所示。[[Writable]] ：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是true ，如前面的例子所示。[[Value]] ：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为undefined 。在像前面例子中那样将属性显式添加到对象之后，[[Configurable]] 、 [[Enumerable]] 和[[Writable]] 都会被设置为 true ，而 [[Value]] 特性会被设置为指定的值。比如：
```j
let person = {
name: "Nicholas"
};

```
这里，我们创建了一个名为 name 的属性，并给它赋予了一个值 "Nicholas" 。这意味着 [[Value]] 特性会被设置为 "Nicholas" ，之后对这个值的任何修改都会保存这个位置。
要修改属性的默认特性，就必须使用Object.defineProperty() 方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含： configurable 、enumerable 、 writable 和 value ，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值：
```j
let person = {};
Object.defineProperty(person, "name", {
writable: false,
value: "Nicholas"
});
console.log(person.name); // "Nicholas"
person.name = "Greg";
console.log(person.name); // "Nicholas"

```
这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值 "Nicholas" 。这个属性的值就不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。类似的规则也适用于创建不可配置的属性。
```j
let person = {};
Object.defineProperty(person, "name", {
configurable: false,
value: "Nicholas"
});
console.log(person.name); // "Nicholas"
delete person.name;
console.log(person.name); // "Nicholas"
```
这个例子把 configurable 设置为 false ，意味着这个属性不能从对象上删除。非严格模式下对这个属性调用 delete 没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就不能再变回可配置的了。再次调用Object.defineProperty() 并修改任何非 writable 属性
会导致错误：
```j
let person = {};
Object.defineProperty(person, "name", {
configurable: false,
value: "Nicholas"
});
// 抛出错误
Object.defineProperty(person, "name", {
configurable: true,
value: "Nicholas"
});
```

2. 访问器属性
访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为。
[[Configurable]] ：表示属性是否可以通过 delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
[[Enumerable]] ：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
[[Get]] ：获取函数，在读取属性时调用。默认值为undefined 。
[[Set]] ：设置函数，在写入属性时调用。默认值为undefined 。访问器属性是不能直接定义的，必须使用
Object.defineProperty() 。
```j
// 定义一个对象，包含伪私有成员year_和公共成员
edition
let book = {
year_: 2017,
edition: 1
};
Object.defineProperty(book, "year", {
get() {
return this.year_;
},
set(newValue) {
if (newValue > 2017) {
this.year_ = newValue;
this.edition += newValue - 2017;
}
}
});
book.year = 2018;
console.log(book.edition); // 2
```

### 12-2、创建对象
12-2-1、工厂模式
工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。（本书后面还会讨论其他设计模式及其在JavaScript中的实现。）

12-2-2、构造函数模式
前面几章提到过，ECMAScript中的构造函数是用于创建特定类型
对象的。像 Object 和 Array 这样的原生构造函数，运行时可以直
接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为
自己的对象类型定义属性和方法。

Person() 内部的代码跟createPerson() 基本是一样的。
区别：
1. 没有显式地创建对象。
2. 属性和方法直接赋值给了 this 。
3. 没有 return 。
注意函数名 Person 的首字母大写了。按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。这是从面向对象编程语言那里借鉴的，有助于在ECMAScript中区分构造函数和普通函数。

要创建 Person 的实例，应使用 new 操作符。
1. 在内存中创建一个新对象。
2. 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数的 prototype 属性。
3. 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。
4. 执行构造函数内部的代码（给新对象添加属性）。
5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。

- 构造函数也是函数
构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用 new 操作符调用就是构造函数，而不使用 new 操作符调用的函数就是普通函数。
 - 构造函数的问题
构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言， person1 和 person2 都有名为 sayName() 的方法，但这两个方法不是同一个 Function 实例。我们知道，ECMAScript中的函数是对象，因此每次定义函数时，都会初始化一个对象。

12-2-3、原型模式
每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型

 - 理解原型
无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person 。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object 。每次调用构造函数创建一个新实例，这个实例的内部 [[Prototype]] 指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]] 特性的标准方式，但Firefox、Safari和Chrome会在每个对象上暴露 __proto__ 属性，通过这个属性可以访问
对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于
理解这一点：实例与构造函数原型之间有直接的联系，但实例与
构造函数之间没有

### 12-3、继承
12-3-1、原型链
SuperType 和 SubType 的主要区别是
SubType 通过创建 SuperType 的实例并将其赋值给自己的原型SubTtype.prototype 实现了对 SuperType 的继承。这个赋值重写了 SubType 最初的原型，将其替换为 SuperType 的实例。这意味着 SuperType 实例可以访问的所有属性和方法也会存在于SubType.prototype 。这样实现继承之后，代码紧接着又给SubType.prototype ，也就是这个 SuperType 的实例添加了一个新方法。最后又创建了 SubType 的实例并调用了它继承的getSuperValue() 方法

1. 默认原型
实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object ，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向Object.prototype 。这也是为什么自定义类型能够继承包括 toString() 、 valueOf() 在内的所有默认方法的原因。因此前面的例子还有额外一层继承关系
2. 原型与继承关系
原型与实例的关系可以通过两种方式来确定。第一种方式是使用instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true

12-3-2、盗用构造函数
为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用 apply() 和 call() 方法以新创建的对象为上下文执行构造函数

12-3-3、组合继承
组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性

12-3-4、原型式继承
```j
function object(o) {
function F() {}
F.prototype = o;
return new F();
}
```
这个 object() 函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上， object() 是对传入的对象执行了一次浅复制。




### 12-4、类

概念：把具有共同性质的事物归结为一类，得出一个抽象的概念——类

12-4-1、 定义类
```
class Person {} // 类声明
const Animal = class {};// 类表达式
```
12-4-2 、构造函数
```
function F(){
 
}
new F();
```
- 经历的步骤：

1. 创建一个空对象，作为将要返回的实例对象
2. 将空对象的原型指向构造函数的prototype属性，也就是F构造函数的prototype属性。
3. 将空对象赋值给构造函数内部的this关键字，也就是this关键字会指向实例对象。
4. 开始执行构造函数内部的代码。

理解constructor属性:

任何javascript函数都可以用来做构造函数，并且调用构造函数是需要用到一个prototype属性的，因此每个javascript函数都在动拥有一个prototype属性。这个属性的值是一个对象，这个对象包含唯一一个不可美居枚举属性constructor，constructor属性的值是一个函数对象

12-4-3、 es6 类

ES6中类就是根据构造函数原理来的：

```
class F {
  constructor(name) 
    this.name = 'Base';
   }
    getName() {
       //==>F.prototype.getName=function(){}
    }
}
```

 类的继承 extends

继承父类后，子类会继承父类所有的方法和属性(包括静态方法和属性)

如果子类没有定义`constructor`方法，会默认被添加该方法

任何子类都有`constructor`方法;

```
 Class Father{
 3       constructor(){
 4       }
 5      sum(){
 6          console.log("abc");
 7      }
 8      static fn(){
 9          console.log("hello")
10      }
11  }
12  Class Son extends Father{
13     
14  }
15  let s=new Son();
16  s.sum()//abc,继承了父类的sum()方法
17  Son.fn()//hello 继承了父类的静态方法fn()
```


用父类的构造函数直接使用`super()`，并且可以传参；

子类的构造函数中，只有调用了`super`之后才可以使用`this`关键字，否则会报错;

```
 2  class Father{
 3       constructor(){
 4         console.log("bbb");
 5      }
 6  }
 7  class Son extends Father{
 8      constructor(x){
 9         this.x=x;//ReferenceError,报错
10         super();
11         this.x=x;//正确
12      }
13  }
14  let sum=new Son();//bbb
```


在属性或方法前面使用 `static`定义类的静态属性和方法；

所有的静态属性和静态方法都不能通过实例化的对象调用；

需要通过类来调用,静态属性和静态方法是类的专属属性和方法，和实例化对象无关，比如数组和数学方法中的：`Array.from();Math.random（）。`

```j
 class Mold{
          static x=0;
          y=1;
          static fn1(){
              console.log("aaa")
          }
          fn2(){
              console.log("bbb");
          }
         }
      let m=new Mold();
      console.log(m.x,m.y);//undefined , 1
      m.fn1(); // TypeError 
      m.fn2(); // bbb
      //需要通过类来调用
      Mold.fn1(); //aaa
      console.log(Mold.x);//0
```


# 十三、代理与反射
### 13-1、代理基础
13-1-1、创建空代理
最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出TypeError 。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。
```j
const target = {
id: 'target'
};
const handler = {};
const proxy = new Proxy(target, handler);
// id属性会访问同一个值
console.log(target.id); // target
console.log(proxy.id); // target
// 给目标属性赋值会反映在两个对象上
// 因为两个对象访问的是同一个值
target.id = 'foo';
console.log(target.id); // foo
console.log(proxy.id); // foo
// 给代理属性赋值会反映在两个对象上
// 因为这个赋值会转移到目标对象
proxy.id = 'bar';
console.log(target.id); // bar
console.log(proxy.id); // bar
// hasOwnProperty()方法在两个地方
// 都会应用到目标对象
console.log(target.hasOwnProperty('id')); //true
console.log(proxy.hasOwnProperty('id')); //true
// Proxy.prototype是undefined
// 因此不能使用instanceof操作符
console.log(target instanceof Proxy); //
TypeError: Function has non-object prototype
'undefined' in instanceof check
console.log(proxy instanceof Proxy); 
//TypeError: Function has non-object prototype'undefined' in instanceof check
// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false
```
13-1-2、定义捕获器
使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。
```j
const target = { foo: 'bar' };
 const handler = { // 捕获器在处理程序对象中以方法名为键 get() { return 'handler override'; } }; 
const proxy = new Proxy(target, handler);
```

13-1-3、捕获器参数和反射API
所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如， get() 捕获器会接收到目标对象、要查询的属性和代理对象三个参数。
```j
const target = {
	foo: 'bar'
};
const handler = {
get(trapTarget, property, receiver) {
	console.log(trapTarget === target);
	 console.log(property);
	console.log(receiver === proxy);
}
};
const proxy = new Proxy(target, handler);
proxy.foo;
// true
// foo
// true
有了这些参数，就可以重建被捕获方法的原始行为：
const target = {
foo: 'bar'
};
const handler = {
get(trapTarget, property, receiver) {
return trapTarget[property];
}
};
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```

13-1-4、捕获器不变式

根据ECMAScript规范，每个捕获的方法都知道目标对象上下文、 捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”
捕获器不变式因方法不同而异，但通常都会防止捕获器 定义出现过于反常的行为。

如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的值时，会抛出 TypeError ：
```j
const target = {}; 
Object.defineProperty(target, 'foo' , { configurable: false, writable: false, value: 'bar' }); 
const handler = { get() { return 'qux'; } }; 
const proxy = new Proxy(target, handler); 
console.log(proxy.foo);
 // TypeError
```


13-1-5、可撤销代理
有时候可能需要中断代理对象与目标对象之间的联系。对于使用new Proxy() 创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。
Proxy 也暴露了 revocable() 方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（ revoke() ）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError 。
撤销函数和代理对象是在实例化时同时生成的：
```j
const target = { 
	foo: 'bar' 
};
const handler = { 
	get() { 
		return 'intercepted'; 
	} 
};
const { 
	proxy, revoke 
} = 
	Proxy.revocable(target, handler); 
	console.log(proxy.foo); // intercepted 
	console.log(target.foo); // bar revoke(); 
	console.log(proxy.foo); // TypeError
```
13-1-6、实用反射API
某些情况下应该优先使用反射API，这是有一些理由的。
1. 反射API与对象API
在使用反射API时，要记住：
(1) 反射API并不限于捕获处理程序；
(2) 大多数反射API方法在 Object 类型上有对应的方法。
通常， Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。

2.状态标记
很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射API方法更有用。例如，可以使用反射API对下面的代码进行重构：
```javascript
// 初始代码
const o = {}; 
try {
 Object.defineProperty(o, 'foo', 'bar'); 
 console.log('success'); 
} catch(e) { 
	console.log('failure'); 
}
```
在定义新属性时如果发生问题，Reflect.defineProperty() 会返回 false ，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：
```javascript
// 重构后的代码
const o = {}; 
if(Reflect.defineProperty(o, 'foo', {value: 
	'bar'})) { 
	console.log('success'); 
} else { 
	console.log('failure'); 
}
```
3. 用一等函数替代操作符
以下反射方法提供只有通过操作符才能完成的操作。
Reflect.get() ：可以替代对象属性访问操作符。
Reflect.set() ：可以替代 = 赋值操作符。
Reflect.has() ：可以替代 in 操作符或 with() 。 Reflect.deleteProperty() ：可以替代 delete 操作符。
Reflect.construct() ：可以替代 new 操作符。
4. 安全地应用函数
在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如：
```j
Function.prototype.apply.call(myFunc, thisVal, argumentList);
```
这种可怕的代码完全可以使用 Reflect.apply 来避免：
```j
Reflect.apply(myFunc, thisVal, argumentsList);
```
13-1-7、代理另一个代理
代理可以拦截反射API的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网：
```j
const target = {
foo: 'bar'
};
const firstProxy = new Proxy(target, {
get() {
console.log('first proxy');
return Reflect.get(...arguments);
}
});
const secondProxy = new Proxy(firstProxy, {
get() {
console.log('second proxy');
return Reflect.get(...arguments);
}
});
console.log(secondProxy.foo);
// second proxy
// first proxy
// bar
```
13-1-8、代理的问题与不足
1. 代理中的 this
代理潜在的一个问题来源是 this 值。我们知道，方法中的this 通常指向调用这个方法的对象：
```javascript
const target = { 
	thisValEqualsProxy() { 
		return this === proxy; 
		} 
	}
const proxy = new Proxy(target, {}); 
console.log(target.thisValEqualsProxy()); // false 
console.log(proxy.thisValEqualsProxy()); // true
```
从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如proxy.outerMethod() ，而这个方法进而又会调用另一个方法，如 this.innerMethod() ，实际上都会调用proxy.innerMethod() 。多数情况下，这是符合预期的行为
2. 代理与内部槽位
代理与内置引用类型（比如 Array ）的实例通常可以很好地协同，但有些ECMAScript内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。
### 13-2、代理捕获器与反射方法
代理可以捕获13种不同的基本操作。这些操作有各自不同的反射
API方法、参数、关联ECMAScript操作和不变式。
正如前面示例所展示的，有几种不同的JavaScript操作会调用同一
个捕获器处理程序。不过，对于在代理对象上执行的任何一种操作，
只会有一个捕获处理程序被调用。不会存在重复捕获的情况。
只要在代理上调用，所有捕获器都会拦截它们对应的反射API操
作。
13-2-1、get() 
get() 捕获器会在获取属性值的操作中被调用。对应的反射API方法为 Reflect.get() 。
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	get(target, property, receiver) { 
		console.log('get()'); 
		return Reflect.get(...arguments) } 
	}); 
	proxy.foo; // get() 
```
1. 返回值
返回值无限制。
2. 拦截的操作
proxy.property
proxy[property]
Object.create(proxy)[property]
Reflect.get(proxy, property, receiver)
3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
receiver ：代理对象或继承代理对象的对象。
4. 捕获器不变式
如果 target.property 不可写且不可配置，则处理程序返回
的值必须与 target.property 匹配。

13-2-2、set()
set() 捕获器会在设置属性值的操作中被调用。对应的反射API方法为 Reflect.set() 。
```j
const myTarget = {};
const proxy = new Proxy(myTarget, {
set(target, property, value, receiver) {
console.log('set()');
return Reflect.set(...arguments)
}
});
proxy.foo = 'bar';
// set()
```
1. 返回值
返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError 。
2. 拦截的操作
proxy.property = value
proxy[property] = value
Object.create(proxy)[property] = value
Reflect.set(proxy, property, value,
receiver)
3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
value ：要赋给属性的值。
receiver ：接收最初赋值的对象。
4. 捕获器不变式
如果 target.property 不可写且不可配置，则不能修改目标属性的值。
如果 target.property 不可配置且 [[Set]] 特性为undefined ，则不能修改目标属性的值。在严格模式下，处理程序中返回 false 会抛出TypeError 。
13-2-3、 has()
has() 捕获器会在 in 操作符中被调用。对应的反射API方法为 Reflect.has() 。
```j
const myTarget = {};
const proxy = new Proxy(myTarget, {
has(target, property) {
console.log('has()');
return Reflect.has(...arguments)
}
});
'foo' in proxy;
// has()
```
1. 返回值
has() 必须返回布尔值，表示属性是否存在。返回非布尔值会
被转型为布尔值。
2. 拦截的操作
property in proxy
property in Object.create(proxy)
with(proxy) {(property);}
Reflect.has(proxy, property)
3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
4. 捕获器不变式
如果 target.property 存在且不可配置，则处理程序必须返
回 true 。
如果 target.property 存在且目标对象不可扩展，则处理程
序必须返回 true 。
13-2-4、defineProperty()
defineProperty() 捕获器会在Object.defineProperty() 中被调用。对应的反射API方法为Reflect.defineProperty() 。
```j
const myTarget = {};
const proxy = new Proxy(myTarget, {
defineProperty(target, property, descriptor) {
console.log('defineProperty()');
 return Reflect.defineProperty(...arguments)
}
});
Object.defineProperty(proxy, 'foo', { value:
'bar' });
// defineProperty()
```
1. 返回值
defineProperty() 必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值。
2. 拦截的操作
Object.defineProperty(proxy, property,descriptor)
Reflect.defineProperty(proxy, property,descriptor)
3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
descriptor ：包含可选的 enumerable 、
configurable 、 writable 、 value 、 get 和
set 定义的对象。
4. 捕获器不变式
如果目标对象不可扩展，则无法定义属性。
如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。
如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。
13-2-5、 getOwnPropertyDescriptor()
getOwnPropertyDescriptor() 捕获器会在Object.getOwnPropertyDescriptor() 中被调用。对应的反射API方法为 Reflect.getOwnPropertyDescriptor() 。
```j
const myTarget = {};
const proxy = new Proxy(myTarget, {
getOwnPropertyDescriptor(target, property) {
console.log('getOwnPropertyDescriptor()');
return
Reflect.getOwnPropertyDescriptor(...arguments)
}
});
Object.getOwnPropertyDescriptor(proxy, 'foo');
// getOwnPropertyDescriptor()
```
1. 返回值
getOwnPropertyDescriptor() 必须返回对象，或者在属性不存在时返回 undefined 。
2. 拦截的操作
Object.getOwnPropertyDescriptor(proxy,property)
Reflect.getOwnPropertyDescriptor(proxy,property)
3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
4. 捕获器不变式
如果自有的 target.property 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。
如果自有的 target.property 存在且可配置，则处理程序必须返回表示该属性可配置的对象。
如果自有的 target.property 存在且 target 不可扩展，则处理程序必须返回一个表示该属性存在的对象。
如果 target.property 不存在且 target 不可扩展，则处理程序必须返回 undefined 表示该属性不存在。
如果 target.property 不存在，则处理程序不能返回表示该属性可配置的对象。
13-2-6、 deleteProperty()
deleteProperty() 捕获器会在 delete 操作符中被调用。对应的反射API方法为 Reflect.deleteProperty() 。
```j
const myTarget = {};
const proxy = new Proxy(myTarget, {
deleteProperty(target, property) {
console.log('deleteProperty()');
return Reflect.deleteProperty(...arguments)
 }
});
delete proxy.foo
// deleteProperty()
```
1. 返回值
deleteProperty() 必须返回布尔值，表示删除属性是否成
功。返回非布尔值会被转型为布尔值。
2. 拦截的操作
delete proxy.property
delete proxy[property]
Reflect.deleteProperty(proxy, property)
3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
4. 捕获器不变式
如果自有的 target.property 存在且不可配置，则处理程序
不能删除这个属性。
13-2-7、 ownKeys()
ownKeys() 捕获器会在 Object.keys() 及类似方法中被调用。对应的反射API方法为 Reflect.ownKeys() 。
```j
const myTarget = {};
const proxy = new Proxy(myTarget, {
 ownKeys(target) {
console.log('ownKeys()');
return Reflect.ownKeys(...arguments)
}
});
Object.keys(proxy);
// ownKeys()
```
1. 返回值
ownKeys() 必须返回包含字符串或符号的可枚举对象。
2. 拦截的操作
Object.getOwnPropertyNames(proxy)
Object.getOwnPropertySymbols(proxy)
Object.keys(proxy)
Reflect.ownKeys(proxy)
3. 捕获器处理程序参数
target ：目标对象。
4. 捕获器不变式
返回的可枚举对象必须包含 target 的所有不可配置的自有属
性。
如果 target 不可扩展，则返回可枚举对象必须准确地包含自有
属性键。
13-2-8、 getPrototypeOf()
getPrototypeOf() 捕获器会在Object.getPrototypeOf() 中被调用。对应的反射API方法为
```j
Reflect.getPrototypeOf() 。
const myTarget = {};
const proxy = new Proxy(myTarget, {
getPrototypeOf(target) {
console.log('getPrototypeOf()');
return Reflect.getPrototypeOf(...arguments)
}
});
Object.getPrototypeOf(proxy);
// getPrototypeOf()
```
1. 返回值
getPrototypeOf() 必须返回对象或 null 。
2. 拦截的操作
Object.getPrototypeOf(proxy)
Reflect.getPrototypeOf(proxy)
proxy.__proto__
Object.prototype.isPrototypeOf(proxy)
proxy instanceof Object
3. 捕获器处理程序参数
target ：目标对象。
4. 捕获器不变式
如果 target 不可扩展，则
Object.getPrototypeOf(proxy) 唯一有效的返回值就是
Object.getPrototypeOf(target) 的返回值。
13-2-9、 setPrototypeOf()
setPrototypeOf() 捕获器会在Object.setPrototypeOf() 中被调用。对应的反射API方法为
```j
Reflect.setPrototypeOf() 。
const myTarget = {};
const proxy = new Proxy(myTarget, {
setPrototypeOf(target, prototype) {
console.log('setPrototypeOf()');
return Reflect.setPrototypeOf(...arguments)
}
});
Object.setPrototypeOf(proxy, Object);
// setPrototypeOf()
```
1. 返回值
setPrototypeOf() 必须返回布尔值，表示原型赋值是否成
功。返回非布尔值会被转型为布尔值。
2. 拦截的操作
Object.setPrototypeOf(proxy)
Reflect.setPrototypeOf(proxy)
3. 捕获器处理程序参数
target ：目标对象。
prototype ： target 的替代原型，如果是顶级原型则
为 null 。
4. 捕获器不变式
如果 target 不可扩展，则唯一有效的 prototype 参数就是
Object.getPrototypeOf(target) 的返回值。
13-2-10、 isExtensible()
isExtensible() 捕获器会在 Object.isExtensible()中被调用。对应的反射API方法为 Reflect.isExtensible() 。
```j
const myTarget = {};
const proxy = new Proxy(myTarget, {
isExtensible(target) {
console.log('isExtensible()');
return Reflect.isExtensible(...arguments)
}
});
Object.isExtensible(proxy);
// isExtensible()
```
1. 返回值
isExtensible() 必须返回布尔值，表示 target 是否可扩
展。返回非布尔值会被转型为布尔值。
2. 拦截的操作
Object.isExtensible(proxy)
Reflect.isExtensible(proxy)
3. 捕获器处理程序参数
target ：目标对象。
4. 捕获器不变式
如果 target 可扩展，则处理程序必须返回 true 。
如果 target 不可扩展，则处理程序必须返回 false 。
13-2-11、 preventExtensions()
preventExtensions() 捕获器会在Object.preventExtensions() 中被调用。对应的反射API方法为 Reflect.preventExtensions() 。
```j
const myTarget = {};
const proxy = new Proxy(myTarget, {
preventExtensions(target) {
console.log('preventExtensions()');
return
Reflect.preventExtensions(...arguments)
}
});
Object.preventExtensions(proxy);
// preventExtensions()
```
1. 返回值
preventExtensions() 必须返回布尔值，表示 target 是
否已经不可扩展。返回非布尔值会被转型为布尔值。
2. 拦截的操作
Object.preventExtensions(proxy)
Reflect.preventExtensions(proxy)
3. 捕获器处理程序参数
target ：目标对象。
4. 捕获器不变式
如果 Object.isExtensible(proxy) 是 false ，则处理程
序必须返回 true 。
13-2-12、 apply()
apply() 捕获器会在调用函数时中被调用。对应的反射API方法为 Reflect.apply() 。
```j
const myTarget = () => {};
const proxy = new Proxy(myTarget, {
apply(target, thisArg, ...argumentsList) {
console.log('apply()');
return Reflect.apply(...arguments)
}
});
proxy();
// apply()
```
1. 返回值
返回值无限制。
2. 拦截的操作
proxy(...argumentsList)
Function.prototype.apply(thisArg,
argumentsList)
Function.prototype.call(thisArg,
...argumentsList)
Reflect.apply(target, thisArgument,
argumentsList)
3. 捕获器处理程序参数
target ：目标对象。
thisArg ：调用函数时的 this 参数。
argumentsList ：调用函数时的参数列表
4. 捕获器不变式
target 必须是一个函数对象。
13-2-13、 construct()
construct() 捕获器会在 new 操作符中被调用。对应的反射API方法为 Reflect.construct() 。
```j
const myTarget = function() {};
const proxy = new Proxy(myTarget, {
construct(target, argumentsList, newTarget) {
console.log('construct()');
return Reflect.construct(...arguments)
}
});
new proxy;
// construct()
```
1. 返回值
construct() 必须返回一个对象。
2. 拦截的操作
new proxy(...argumentsList)
Reflect.construct(target, argumentsList,
newTarget)
3. 捕获器处理程序参数
target ：目标构造函数。
argumentsList ：传给目标构造函数的参数列表。
newTarget ：最初被调用的构造函数。
4. 捕获器不变式
target 必须可以用作构造函数。


# 十四、函数
注意：每一个类只有一个class对象！！！ 
 Java
// 1.通过对象获得
c1类= 人员。getClass（）;
系统。出来。的println（C1。的hashCode（））;
// 2.forName获得
类c2 = 类。forName（“ com.chy.reflection.Test ”）;
系统。出来。的println（C2。的hashCode（））;
// 3.通过类名.class获得
c3类=  Stu。类;
系统。出来。的println（C3。的hashCode（））;
// 4.基本内置类型的包装类都有一个类型属性
类c4 = 整数。类型;
系统。出来。的println（C4。的hashCode（））;
函数的基本概念，声明和调用；函数作用域，作用域链，闭包；此指向及修改和绑定此指向等。
//获得父类类型
类c5 =  c1。getSuperclass（）;
系统。出来。println（c5）;
        
1. 函数概念，声明及调用
JS中的函数：把一段需要重复使用的代码，用函数语法包起来，方便重复调用，分块和简化代码。复杂一点的，也会加入封装，抽象，分类等思想。
声明方式：严格意义上两种方式，但还有匿名函数
-方式一：
` ` ` javascript
function方法名（）{      //要执行的代码}
` ` `
当然也不仅仅只有类才有类对象，对于基本类型，副本，接口等也有类对象。对于上面所说的，只要排序类型和尺寸相同（与长度无关），它们都是同一个类对象。
-方式二：ES6中声明方式箭头函数，（）=> {} 
-方式三：匿名函数，将函数存储到变量里var func = function（）{};
` ` ` Java
类c1 = 对象。类;  //类
c2类= 可比较。类;  //接口
c3类= 字符串[]。类;   //一维数组
类c4 = int [] []。类;   //二维数组
c5类= 覆盖。类;  //注解
类c6 =  ElementType。类;  //枚举
c7类= 整数。类;   //基本数据类型
类c8 =  void。类;  //无效
c9类= 类。类;  //类
123456789
函数调用：两种方式调用
-调用方式一：名字（）; 函数可以多次调用
` ` ` javascript
//函数声明function fn（）{console.log（1）;} //函数的调用fn（）;
` ` `
调用方式二：在事件中调用，直接写函数名，不使用括号
` ` ` javascript
//函数声明function fn（）{console.log（1）;} //函数在事件中的调用document.onclick = fn;
` ` `
2. 利用class对象创建实例
- `对象 的newInstance（）`：创建实例化对象
- `构造getDeclaredConstructor（类...。ARGS）`：获取指定参数的构造器
函数表达式：就是把函数存到变量里。
` ` ` Java
/ *

	使用.newInstance（）方法
	最好：
		1.类中必须有一个无参构造器
		2.构造器的访问权限必须足够
* /

	类c = 测试。类;
	测试测试=（测试）c。newInstance（）;
匿名函数：没有名字的函数；
匿名函数在使用时只有两种情况：
/ *
	通过获取构造器来创造实例化对象
	注意：
		1.此时就可以无视构造器的访问权限
		2.不一定要有无参构造器
		3.可以创造指定参数的构造器
* /

	类c = 测试。类;
	构造函数con =  c。getDeclaredConstructor（字符串。类，INT。类）;
	测试test =（测试）con。newInstance（“ chy ”，18）;
1234567891011121314151617181920
-匿名函数自执行：声明后不需要调用就直接执行
` ` ` javascript
（函数（）{    控制台。登录（“匿名函数自执行”）;}）（）;
` ` `
3. 利用类对象调用方法
-函数表达式：把函数存到变量，或将函数存到数组的对应位置里等，调用时通过变量或数组对应位置进行调用。调用时需要写括号。
- `方法getDeclaredMethod （字符串方法名，类参数的类对象）` ：获取指定的方法
- `无效setAccessible （布尔标志）` ：启动和禁用访问安全的开关，默认为假，**但传参为真时，就可以调用私有方法** 
- `对象调用（对象OBJ，对象...参数）` ：激活方法，第一个参数是要调用该方法的对象，其他是参数  
` ` ` javascript
// 2，函数表达式：把函数存到变量或数组等里，调用时通过变量进行调用var fn = function（）{console.log（“函数表达式：将函数存到变量里”）;} ; fn（）; //调用时需要写括号// 2，函数表达式：把函数存到数组第0位，调用时通过数组第0位进行调用var arr = []; arr [0] = function （）{console.log（“函数表达式：将函数存储到数组的对应位置”）;}; arr [0]（）; //调用时需要写括号要写括号
` ` `
` ` ` Java
班级 用户{
私有 字符串名称；
结果：
公共 字符串 getName（）{
            返回名称；
        }
！[img]（https://img-blog.csdnimg.cn/20190711101304294.png）
        public  void  setName（字符串 名称）{
            这个。名字 =名字;
        }
}
事件函数扩展：给元素添加事件的陈述是不正确的。事件时元素本身就具有了特征，只是触发事件后，根本没有相关的一些处理。这种操作其实就是给元素的某个事件添加了一个事件处理函数。当事件被触发后，判断到属于该事件类型，就触发该事件函数的处理函数。
类c = 用户。类;
方法setName =  c。getDeclaredMethod（“的setName ”，字符串。类）;
方法getName =  c。getDeclaredMethod（“ getName ”）;
setName。setAccessible（true）;
可以通过console.dir（）把对象的所有属性和方法打印出来，查看对象或元素本身具有的事件。
setName。调用（user3，“ chy ”）;
getName。调用（user3）;
12345678910111213141516171819
` ` ` javascript
< script >        //事件时元素本身就具有了特征，只不过，触发事件后，根本没有相关的一些处理。事件函数实际上就是给元素的某个时间添加了一个事件处理函数。//可以通过控制台。 dir（）把对象的所有属性和方法打印出来document.onclick = function（）{console.log（“事件的处理函数”）; }; ///当被触发后，判断到属于该事件类型，就触发该事件函数的处理函数if（typeof document.onclick ==“ function”）{document.onclick（）; } </ script>
` ` `
**注意：一般来说` setAccessible ` 。不宜为真，因为不安全不过一旦开启这个禁用开关，则可以提高性能，对于使用频繁的方法，应该打开这个开关**
 结果：
4.利用类对象获取类的信息
- `现场getfield命令（字符串名称）`：获取类的属性，只能获取公开
- `现场getDeclaredField（字符串名称）`：获取类的属性，包括私人
- `字符串 的getName（）`：获取类的名字（全类名）
- `字符串 getSimpleName（）`：获取类的简单名字
#### 3.函数传参
` ` ` Java
		//获取类的名字
        系统。出来。的println（C1。的getName（））;  //获得包名+类名
        系统。出来。的println（C1。getSimpleName（））;  //获得类名
获取元素，最好从父级元素获取，全部从文档中获取，可能会出现混乱。
        //获得类的属性
		字段field =  c1。getField（“ name ”）;
		字段field =  c1。getDeclaredField（“ name ”）;
-形参：形式上的参数-给函数声明一个参数；
-实参：实际的参数-在函数调用时给形参赋的值
        Field [] fields =  c1。getFields（）;  //只能找到public属性
`` ` javascript
function  func（形参1，形参2）{     //函数执行代码} func（实参1，实参2）; //调用时传参
` ` `
        字段=  c1。getDeclaredFields（）;  //找到全部属性
        对于（字段字段：字段）{
            系统。出来。println（字段）；
        }
什么时候使用到传参？当有两段代码本身的功能极其相似，只有个别地方不一样时，就可以把两段代码合并成一个函数，然后把两段代码中分开的内容通过传参传进去。
案例：自定义（多个模块）选项卡封装

## 4.修改输入的值
代理模式是什么呢？以及我们有两个类，一个实现某种功能简称功能类，一个通过调用功能类来满足自身目的检查客户类，原来客户类和功能类是直接相互作用的，客户`类→功能类`。
value和innerHTML都可以获取获取并修改元素的值（或内容）； value只能获取特定的textarea和input的值，但是innerHTML可以获取所有HMTL元素的值。
**现在我们使用代理模式，就再多出一个类，代理类，它横插在客户类和功能类之间，是他们必须通过代理类来交互`客户类→代理类→功能类` ** 。这时很多人就可能会不理解了，说你这个不是多此一举吗，直接相互作用不好吗，还要加上一个新的类。
不同之处如下：
1）值可以为修改（获取）textarea和输入的值属性的值或元素的内容；
2）innerHTML重新修改（获取）HTML元素（如div）html格式的内容。
确实，我们平时确实不一定要用到这个模式，用这个确实是多次一举。但在某些场合的时候，使用这个代理模式就是一个极佳的punchline了。
下面举个例子：这样我们的WEB项目，现在需要增加一个日志功能，在我们每次调用方法的时候把它记录下来，那怎么办呢？在原来的代码上改咯？不，不能这样做，这时候代理模式就来了，我们刚刚新建一个代理类，这个代理类完全能保有原来的功能，同时这个基础上增加了日志功能，专业术语上这个过程称为增强。
##### 5.函数的不定参（可变参）—关键字参数
代理模式有两种：静态代理和动态代理。
案例：购物车商品逐步。事先不知道用户买多少商品
首先角色分析
不定参（可变参）使用关键字：arguments，代表所有实参的集合。通过下标获取参数的每一位；通过长度获取实参的个数；
-抽象角色：一般是接口或者抽象类，也就是这里面的租房这个功能
-真实角色：被代理的角色，相当于房东
-代理角色：代理类，一般会添加一些附属操作来实现增强，相当于这里面的中介
-客户：访问代理对象的类，相当于这里面的租客
集合是类表格，可以使用下标，但是没有列表中的各种方法。
##### 7.封装获取元素的方法
封装通过id / CSS选择器获取（一般在父级下获取，所以替换父级和选择器名称）获取多种元素的方法，然后返回获取到的值
静态代理实际上就是我们真正去写出一个代理类，不过缺点端也是很明显的，如果有n个真实角色，那就要写n个代理类
名义上，程序猿是一种懒惰的动物。
## 8.获取计算后样式-getComputedStyle（el）
相较于静态代理，动态代理就很方便，不过这个很绕很绕。首先要了解以下这个类：
点击时获取box的宽度，在本质基础上+100
- `的InvocationHandler `：这个叫做调用处理程序实现的接口，每一个代理角色都有一个对应的调用处理程序，**看不懂没关系，只需要知道我们是通过它的一个方法来获取代理对象（代理对象），然后复写这个接口里面的`调用`方法。**
-从样式中获取的是行间样式，但是通常样式不会写在行间；
-获取计算后样式：getComputedStyle（el）获取元素的计算后样式。属于window的方法，即window.getComputedStyle（el）。在JS中使用window下的方法时，window可以不写；
-getComputedStyle（el）方法不兼容IE6,7,8；
-计算后样式：优先级最高的样式，即当前显示出来的样式
-使用getComputedStyle（el）是获取窗口下所有样式，getComputedStyle（el）['样式名']可以获取到特定样式
-写样式名时，使用驼峰样式的名字（否则IE下会有兼容问题），如margin-left必须写成marginLeft。
-IE下获取元素的计算后样式，需要使用el.currentStyle ['样式名']
-兼容的IE和其他浏览器：判断el.currentStyle返回真即表示IE，否则就是其他浏览器，然后在对应浏览器下使用对应方法
-获取计算后样式会经常使用，因此可以封装成方法，进行替换
-getComputedStyle（el）和el.currentStyle获取不到伪元素的样式，因为伪元素不是DOM的内容
-伪类样式计算后样式可以获取到，伪元素获取不到
## 8.JS预解析机制（变量提升吊装）
在预解析时，会先预解析var，把var放在最前面，然后再预解析function，所以当var和function重名时，function会覆盖var
JS预解析机制不是良好的编码习惯，不利于代码维护，建议不要使用，编码时建议先声明，再使用。
扩展：从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。
ES6之后就不能像JS预解析这么编写JS代码了。
## 9.作用域
通常来说一段程序代码中使用的变量和函数并不总是可用的，限定其可用范围的即作用域，作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少了名称冲突。
通俗的说，作用域：数据起作用的范围（某条数据可以在什么范围内使用）
前端权威官方MDN：https：//developer.mozilla.org/zh-CN/docs/Glossary/Scope
作用域的分类：
1. \-作用域：通过var或function声明在类别（声明在任意函数之外和代码块之外）中的数据，在变量的任意地方都可以调用或修改（即变量）和在窗口中下的属性
2. \-局部作用域：
-函数作用域：声明在函数内部的某个数据（var，function，参数），就只能在函数内部使用（函数的局部作用域）
## 10.窗口
-在JS中，默认情况下var声明的变量和函数声明的变量函数会挂载在窗口上（所以要避免声明变量变量和变量函数）
-在JS中，默认的数据都会保存在window下（ES6之前）
-另外window是JS在浏览器里的某些对象，所以window的属性和方法也都是层叠的
-在JS中，调用窗口下的属性和方法，默认可以不写窗口，所以如果在函数里面声明变量没有写var，会把其当做window的一个属性；（不规范写法，要避免）
## 11.大规模污染（命名冲突问题）
ES6中代码冲突会直接报错。所以要养成好的习惯不要在身上去声明变量。12.作用域链（作用域链）
作用域链决定了某些数据能被函数访问。当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。
## 13.闭包
闭包是对作用域链的一种表现和使用。
函数对象可以通过作用域链相互关联起来，函数体内的数据（变量和函数声明）都可以保存在函数作用域内，这种特性在计算机科学文献中被称为“闭包”。既是函数体内的数据从技术角度来说，js的函数都是闭包：函数都是对象，都关联到作用域链，函数内数据被隐藏于作用于链内，看起来像是函数将数据“包裹”了起来。都被保存在函数作用域内。
fn（）（）;调用函数后的返回值还是一个函数，也可以进行进行
函数的每次执行之间没有任何关系。每次执行都相当于在JS内部吧代码重新写一遍。
面试时：闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取，所以闭包可以理解成“定义在一个内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的主轴。
闭包：
-形式：函数嵌套函数；
-作用：子函数可以访问父函数的作用域，但是父级不能访问子级的。
结果：按钮进行循环后逐步建立索引索引给fn函数，当单击按钮时，再通过父级作用域获取到父级的索引
闭包应用二：（匿名函数自执行方式）页面刷新时解析循环链接索引给给fn，并立即执行fn函数，当点击按钮时，再通过父级作用域fn获取到索引
## 14.this当前执行代码的环境对象
默认情况下：
-函数外：窗口
-函数内：函数中的这个指向谁，取决于这个函数是怎么调用的
-严格模式下，默认为未定义
1.作为对象的属性（方法，事件（方法的一种））调用，指向当前对象
2.其余情况执行窗口
## 15.严格模式下的此指向
 在脚本标签最上面加上'use strict';，加上'use strict'后预解析已经不能使用，会报错。
严格模式下的功能指向问题：在严格模式下，功能如果不是作为对象的属性和方法被调用（即直接调用方法）就指向未定义。
## 16.this指向的修改
### 16.1 function.call（）
1. function.call（this指向谁，参数1，参数2 ...）调用函数，并修改函数中的this指向；
2.执行函数的call方法，会调用该函数，并修改函数中的此指向；
3.调用中的第0个参数，代表当前函数执行时，函数中的此指向谁
4.其他参数都是给函数传的实参
5.注意修改执行为body时，一定要使用document.body
### 16.2 function.apply（）
1. function.apply（this指向谁，[参数1，参数2 ...]）调用函数，并修改函数中的this指向
2.指向函数的应用方法，会调用该函数，并修改函数中的此指向；
3. apply中的第0个参数，代表当前执行时，函数中的this指向谁；
4. apply中第1个参数是一个数组，数组中代表了我们要往函数中传递的参数；并且所有参数只能放在一个数组里，有多个分段时，除了第一个，其他数值的参数不会被接收
5. apply和call唯一的区别在于，call方法直接在方法里传参，而apply是将所有参数已数组形式进行传递；
6.注意修改执行为body时，一定要使用document.body
