# 第一章·

## JavaScript

（1）JavaScript已被公认为主流的编程语言，能够实现复杂的计算与交互，包括闭包、匿名（lambda）函数，甚至元编程等特性。不仅是桌面浏览器，手机浏览器和屏幕阅读器也支持
JavaScript，其重要性可见一斑。

（2）ES6支持类，模块，迭代器，生成器，箭头函数，期约，代理和众多新的数据类型

二，DOM

文档对象模型（DOM，Document Object Model）是一个应用编程

接口（API），用于在HTML中使用扩展的XML。DOM将整个页面抽

象为一组分层节点。HTML或XML页面的每个组成部分都是一种节

点，包含不同的数据。

例如下面的heml的页面：

```
<html> 
<head>
<title>Sample Page</title> 
</head>
<body> 
<p> Hello World!</p> 
</body> 
</html>
```

DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页

的内容和结构。使用DOM API，可以轻松地删除、添加、替换、修改

节点。

DOM的级别：

<1> DOM Core :者提供了一种映射XML文档，从而方便访问和操作文档任意部分的方式

<2> DOM HTML :后者扩展了前者，并增加了特定于HTML的对象和方法。

注意点：

（1）DOM并不是只能通过JavaScript访问，而且确实被其他很

多语言实现了。但是对于浏览器来说，DOM就是使用ECMAScript实现的，如今已经成为JavaScript语言的一大组成部分



**DOM Level 2新增的模块**

DOM Level 2新增了以下模块，以支持新的接口。

**DOM**视图：描述追踪文档不同视图（如应用CSS样式前后的

文档）的接口。

**DOM**事件：描述事件及事件处理的接口。

**DOM**样式：描述处理元素CSS样式的接口。

**DOM**遍历和范围：描述遍历和操作DOM树的接口



**BOM**

（1）BOM主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。

比如以下扩展：

1.弹出新浏览器窗口的能力；

2.移动、缩放和关闭浏览器窗口的能力；

3.navigator 对象，提供关于浏览器的详尽信息；

4.location 对象，提供浏览器加载页面的详尽信息；

5.screen 对象，提供关于用户屏幕分辨率的详尽信息；

6.performance 对象，提供浏览器内存占用、导航行为和时间统



## **HTML**中的**JavaScript**

**一 <script> 元素** 

将JavaScript插入HTML的主要方法是使用 <script> 元素。

 

<script> 元素有下列8个属性
    （1）async   ：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效
    （2）charset  ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
    （3）crossorigin ：可选。配置相关请求的CORS（跨源资源共
享）设置。默认不使用CORS。
	（4）defer ：可选。表示在文档解析和显示完成后再执行脚本是没
有问题的。只对外部脚本文件有效。在IE7及更早的版本中，对行
内脚本也可以指定这个属性。
	（5）integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络不会提供恶意内容。
    （6）language ：废弃。最初用于表示代码块中的脚本语言，大多数浏览器都会忽略这个属性，
    （7）src ：可选。表示包含要执行的代码的外部文件。
    （8）type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。


2**.使用 <script> 的方式有两种**：

通过它直接在网页中嵌入JavaScript代码，以及通过它在网页中包含外部JavaScript文件。

要嵌入行内JavaScript代码，直接把代码放在 <script> 元素中就行：

```
<script> 
function sayHi() { console.log("Hi!"); }
</script>
```

在使用行内JavaScript代码时，要注意代码中不能出现字符串</script> 。比如，下面的代码会导致浏览器报错：

```
<script> 
function consolefunction sayScript() { 
console.log("</script>");
}
</script>
```

#### 标签占位符

过去，所有 <script> 元素都被放在页面的 <head> 标签内，如下面的例子所示：

```
<!DOCTYPE html>
<html>
<head> 
<title>Example HTML Page</title> 
<script src="example1.js">
</script> 
<script src="example2.js">
</script> 
</head>
<body> <!-- 这里是页面内容 --> 
</body> 
</html>
```

## Javascript的基础语法：

**一 ：区分大小写**

（1）Script中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。换句话说，变量 test 和变量 Test 是两个不同的变量。类似地， typeof 不能作为函数名，因为它是一个关键字（后面会介绍）。但 Typeof 是一个完全有效的函数名。

**二 ：标识符**

所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成

（1）第一个字符必须是一个字母、下划线（ _ ）或美元符号（ $ ）；剩下的其他字符可以是字母、下划线、美元符号或数字。

（2）按照惯例，ECMAScript标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写，如：

```
firstSecond myCar doSomethingImportant

注意 关键字、保留字、 true 、 false 和 null 不能作为标识
符。具体内容请参考3.2节。
```

**三 ： 注释**

（3）ECMAScript采用C语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如：

```
// 单行注释

块注释以一个斜杠和一个星号（ /* ）开头，以它们的反向组合
（ */ ）结尾，如：

/* 这是多行
注释 */
```

**四 ： 严格模式**

严格模式是

一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：

```
"use strict";
```

​            虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持的JavaScript引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏ECMAScript 3语法。

​			也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可：

```
function doSomething() {
   "use strict";
   // 函数体
 }
```

严格模式会影响JavaScript执行的很多方面，因此本书在用到它时会明确指出来。所有现代浏览器都支持严格模式。

**五 ： 语句**

ECMAScript中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾，如下面的例子所示：

```
let sum = a + b // 没有分号也有效，但不推荐
let diff = a - b; // 加分号有效，推荐
```

​               即使语句末尾的分号不是必需的，也应该加上。记着加分号有助于防止省略造成的问题，比如可以避免输入内容不完整。此外，加分号也便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）。加分号也有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。

​             多条语句可以合并到一个C语言风格的代码块中。代码块由一个左花括号（ { ）标识开始，一个右花括号（ } ）标识结束：

```
if (test) {
     test = false; 
     console.log(test); 
  }
```

**六 ： 关键字与保留字**

所有

关键字如下：

![](D:\田松\笔记\原型原型链\93f815248ef8b8a6036fda67dcb0abbc.png)

严格模式下保留：

```
implements        package         public       let 
interface         protected       static      private  
```

模块代码中保留: 

```
await
```

**变量**

​             有三个关键字可以声明变量：var 、 const 和 let 。其中， var 在ECMAScript的所有版本中都可以使用，而 const 和 let 只能在ECMAScript 6及更晚的版本中使用。

1. **var 声明作用域**

   ​                    使用 var 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：

   

```
function test() { 
      var message = "hi"; // 局部变量
}
       test(); 
       console.log(message); // 出错
```

​                  这里， message 变量是在函数内部使用 var 定义的。函数叫test() ，调用它会创建这个变量并给它赋值。调用之后变量随即被销毁，因此示例中的最后一行会导致错误。不过，在函数内定义变量时省略 var 操作符，可以创建一个全局变量：

```
function test() { 
      message = "hi"; // 全局变量
  }
       test();
       console.log(message); // "hi"
```

​                 去掉之前的 var 操作符之后， message 就变成了全局变量。只要调用一次函数 test() ，就会定义这个变量，并且可以在函数外部访问到。

**（1）变量提升现象：**

即变量可以在声明之前使用，值为undefined。
var 命令会发生“变量提升”现象；let 命令不存在“变量提升”。

```
// var 的情况
console.log(foo);  // 输出 undefined
var foo = 2;

// let 的情况
console.log(bar); // 输出 ReferenceError
let bar = 2;
```

### 暂时性死区

只要块级作用域内存在let命令，他所声明的变量就绑定这个区域，不再受外部的影响。

```
var tmp = 123；

if (true) {
tmp = 'abc';

let tmp;

}

抛出错误：ReferenceError
```

注：上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。

ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。但是声明之前使用这些变量，就会报错。

在上面的代码中，let命令声明变量tmp之前，都属于变量tmp的死区。

**

暂时性死区的本质，只要一进入当前作用域，所使用的变量就已经存在了，但是不可获取。只有等到声明变量的那一行代码出现，才可以获取和使用该变量。



2. **全局声明**

与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（ var 声明的变量则会）

```
var name = 'Matt'; 
console.log(window.name); // 'Matt' let age = 26; console.log(window.age); // undefined
```

​      不过， let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免 SyntaxError ，必须确保页面不会重复声明同一个变量。



3. **条件声明**

​           在使用 var 声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。

```
<script> 
     var name = 'Nicholas'; let age = 26; 
</script>
<script> 
       // 假设脚本不确定页面中是否已经声明了同名变量
       // 那它可以假设还没有声明过
          var name = 'Matt'; // 这里没问题，因为可以被作为一个提升声明来处理
       // 不需要检查之前是否声明过同名变量
       let age = 36;  
       // 如果age之前声明过，这里会报错
</script>
```

**for 循环中的 let 声明**

在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外部

**const 声明** 

const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。

## 		数据类型

###### 基本数据类型（值类型）Number、String、Boolean、Undefined、Null、BigInt

引用数据类型:Object。包含Object、Array、 function、Date、RegExp

数据类型检测的几种方式

Typeof：

  对于基本数据类型判断是没有问题的，但是遇到引用数据类型是不起作用

instanceof

   instanceof它用来判断这个构造函数的原型是否在给定对象的原型链上。 

constructor

constructor 属性返回对象的构造函数 返回值是函数的引用，不是函数名：

```
function person(){}
undefined

var lisi = new person()
undefined

lisi instanceof person
true

Object.prototype.toString.call("aaa")
"[object String]"

Object.prototype.toString.call(function(){})
"[object Function]"
```

### 模板字符串

JavaScript中的字符串可以用单引号或双引号来表示。但是，当你想要换行时，只能手动使用`\n`来表示。有了模板字符串，我们能够以更简洁的方式进行多行处理。模板字符串使用反引号代替单引号或双引号。

```
// 用 \n 手动换行并不好
const str = 'multiline\nwith\nmanual\nhard returns'

// 有了模板字符串，这样表示就更简洁
const str = `
  multiline
  without
  the
  mess
`
```

模板字符串的另一个好处是支持字符串插值

```
// 这里 str 正在使用变量构建，但是必须用 + 连接
const something = 'ugly stuff'
const str = 'instead of ' + something + ' like this'

//这里 str 是一个模板字符串，可以使用 ${} 把变量插值到字符串中
const something = 'lovely stuff'
const str = `you can do ${something} like this`
```

**条件操作符**

​             条件操作符是ECMAScript中用途最为广泛的操作符之一，语法跟Java中一样：

```
variable = boolean_expression ? true_value : false_value;
```

​               上面的代码执行了条件赋值操作，即根据条件表达式boolean_expression 的值决定将哪个值赋给变量 variable 。

如果 boolean_expression 是 true ，则赋值 true_value ；

如果 boolean_expression 是 false ，则赋值false_value 。比如：

```
let max = (num1 > num2) ? num1 : num2
```

​                     在这个例子中， max 将被赋予一个最大值。这个表达式的意思是，如果 num1 大于 num2 （条件表达式为 true ），则将 num1赋给 max 。否则，如果 num1 小于 num2 （条件表达式为false ），则将 num2 赋给 max 。

**赋值操作符**

​		简单赋值用等于号（ = ）表示，将右手边的值赋给左手边的变量，如下所示：

```
let num = 10;
```

​		复合赋值使用乘性、加性或位操作符后跟等于号（ = ）表示。这些赋值操作符是类似如下常见赋值操作的简写形式：

```
let num = 10; num = num + 10;
```

​       以上代码的第二行可以通过复合赋值来完成：

```
let num = 10; 
num += 10;
```

每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：

```
乘后赋值（ *= ）
除后赋值（ /= ）
取模后赋值（ %= ）
加后赋值（ += ）
减后赋值（ -= ）
左移后赋值（ <<= ）
右移后赋值（ >>= ）
无符号右移后赋值（ >>>= ）
```

这些操作符仅仅是简写语法，使用它们不会提升性能



**逗号操作符**

```
let num1 = 1, 
num2 = 2, 
num3 = 3;
```

在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：

```
let num = (5, 1, 4, 8, 0); // num的值为0
```

​                 在这个例子中， num 将被赋值为0，因为0是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。

##         for···in和for···of的区别

遍历数组，字符串，for···in取下标，for···of取值； 

遍历对象，for···in取key，但for···of会直接报错 

如果要使用for…of遍历普通对象，需要配合Object.keys()一起使用。

# 第二章·

#### 1.为什么要学javascript？

  1、因为你别无选择！只有javascript可以控制所有常用的浏览器，而且javascript是世界上最重要的编程语言之一，学习web技术必须学会javascript。
  2、javascript是一种优雅的语言，她很好，所以我们要学。

#### 2.Javascript能做什么？

​	javascript可以检测表单的正确性，实现Ajax，读、写、改变HTML页面的架构DOM，对事件做出响应，检测浏览者所使用的设备，产生很酷很炫的网页效果DHTML等

#### 3.什么是javascript？

​	1、javascript是一种基于对象和事件驱动的客户端脚本语言。
​	2、javascript最初的设计师为了检验HTML表单输入的正确性
​	3、javascript起源于Netscape公司的livescript语言。

总结：JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。

#### 4.javascript的组成

完整的Javascript是由ECMAScript（语法）、Browser Objects（DOM、BOM）（特性）组成的。

![image-20210118200930742](C:\Users\浦多电脑\AppData\Roaming\Typora\typora-user-images\image-20210118200930742.png)

#### 5.javaScript语言的特点

1. JavaScript 是一种脚本语言 是使用一种特定的描述性语言，依据一定的格式编写的可执行文件

2.JavaScript 是一种基于对象的语言

简单性 动态性 安全性 跨平台型

## 我们来深入了解一下DOM 和BOM

### Dom：该语言独有的DOM方法和接口

可伸缩矢量图（SVG，Scalable Vector Graphics）

数学标记语言（MathML，Mathematical Markup Language）

同步多媒体集成语言（SMIL，Synchronized Multimedia

Integration Language）

##### 什么是DOM？其核心对象是什么？Dom能用来干什么？

Dom是文档对象模型 DOM的核心对象是document对象

 对html元素的样式(颜色、大小、位置等等)、内容、属性来进行动态的改变和操作。

##### Dom模型树

![image-20210118203014239](C:\Users\浦多电脑\AppData\Roaming\Typora\typora-user-images\image-20210118203014239.png)

### Bom:

##### 什么是BOM？其核心对象是什么？

 BOM是浏览器对象模型 BOM的核心对象是window

###### 列举BOM的五个对象并描述意思？

document  文档

History  从窗口被打开起的历史记录

Location  当前窗口中加载的文档有关的信息  地址栏信息

Navigator  浏览器本身的信息，浏览器的版本、名称等等

Screen  有关客户端屏幕的信息

### 总结

JavaScript是一门用来与网页交互的脚本语言，包含以下三个组成部分。

ECMAScript：由ECMA-262定义并提供核心功能。

文档对象模型（DOM）：提供与网页内容交互的方法和接口。

浏览器对象模（BOM）：提供与浏览器交互的方法和接口。

JavaScript的这三个部分得到了五大Web浏览器（IE、Firefox、Chrome、Safari和Opera）不同程度的支持。所有浏览器基本上对ES5（ECMAScript 5）提供了完善的支持，而对ES6（ECMAScript 6） 和ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对DOM的支持各不相同，但对Level 3的支持日益趋于规范。HTML5中收录的BOM会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。

#### 二。script元素

async ：可选。表示应该立即开始下载脚本，但不能阻止其他 页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效

charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在它的值。

crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。 

crossorigin="anonymous" 配置文件请求不必设置凭据标志。 crossorigin="usecredentials" 设置凭据标志，意味着出站请求会包含凭据。

defer ：可选。表示在文档解析和显示完成后再执行脚本是没有问题的。只对外部脚本文件有效 在IE7及更早的版本中，对行内脚本也可以指定这个属性。

integrity ：可选。允许比对接收到的资源和指定的加密签名以验证子资源完整（SRISubresource Intergrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN,Content Delivery Network）不会提供恶意内容。

language ：废弃。最初用于表示代码块中的脚本语言（如 "JavaScript" 、 "JavaScript 1.2" 或"VBScript" ）。大多数浏览器都会忽略这个属性，不应该再使用它。

src ：可选。表示包含要执行的代码的外部文件。

type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。按照例，这个值始终都是 "text/javascript" ，尽管 "text/javascript" 和 "text/ecmascript" 都已经废弃了。JavaScript文件的MIME类型通常是 "application/x- javascript" ，不过给type属性这个值有可能导致脚本被忽略。在非IE的浏览器中有效的其他值还有 "application/javascript" 和"application/ecmascript" 。如果这个值是 module ，则代码会被当成ES6模块，而且只有这时候代码中才能出现 import 和 export 关键字。使用 <script> 的方式有两种：通过它直接在网页中嵌入JavaScript代码，以及通过它在网页中包含外部JavaScript文件。

要嵌入行内JavaScript代码，直接把代码放在 <script> 元素中

就行：

<script> 
function sayHi() { 
console.log("Hi!"); 
} 
</script>



此处的转义字符指在JavaScript中使用反斜杠“ \ ”来向文本字符串添加特殊字符

<script> 
function sayScript() { 
console.log("<\/script>"); 
} 
</script>



要包含外部文件中的JavaScript，就必须使用 src 属性。这个属性的值是一个URL，指向包含JavaScript代码的文件，比如：

<script src="example.js"></script>

可以简写：<script src="example.js"/>

<script src="http://www.somewhere.com/afile.js"> 
</script>



浏览器在解析这个资源时，会向 src 属性指定的路径发送一个GET 请求，以取得相应资源，假定是一个JavaScript文件。这个初始的请求不受浏览器同源策略限制，但返回并被执行的JavaScript则受限制。当然，这个请求仍然受父页面HTTP/HTTPS协议的限制

<script src="http://www.somewhere.com/afile.js"> 
</script>



### 标签占位符

过去，所有 <script> 元素都被放在页面的 <head> 标签内，这种做法的主要目的是把外部的CSS和JavaScript文件都集中放到一起，这样一来，页面会在处理JavaScript代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了

### 推迟执行脚本

HTML 4.01为 <script> 元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行在 <script> 元素上设defer 属性，会告诉浏览器应该立即开始下载，但执行应该推迟。对 defer 属性的支持是从IE4、Firefox3.5、Safari 5和Chrome 7开始的。其他所有浏览器则会忽略这个属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在页面底部比较好

### 异步执行脚本

HTML5为 <script> 元素定义了 async 属性。从改变脚本处理方式上看， async 属性与 defer 似。当然，它们两者也都只适用于外部脚本，都会告诉浏览器立即开始下载。不过，与 defer不同是，标记为 async 的脚本并不保证能按照它们出现的次序执行。异步脚本保证会在页面的 load 事件前执行，但可能会在DOMContentLoaded之前或之后。Firefox 3.6、Safari 5和Chrome 7支持异步脚本。

### 动态加载脚本

除了 <script> 标签，还有其他方式可以加载脚本。因为JavaScript可以使用DOM API，所以通过向DOM中动态添加 script元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到DOM即可。不是所有浏览器都支持 async 属性。因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：

```js
let script = document.createElement('script'); 
script.src = 'gibberish.js'; 
script.async = false; 
document.head.appendChild(script);

以这种方式获取的资源对浏览器预加载器是不可见的。这会严重
影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及
怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些
动态请求文件的存在，可以在文档头部显式声明它们：
<link rel="preload" href="gibberish.js">
```

### 行内代码与外部文件

虽然可以直接在HTML文件中嵌入JavaScript代码，但通常认为最佳实践是尽可能将JavaScript代码放在外部文件中。不过这个最佳实践并不是明确的强制性规则。推荐使用外部文件的理由如下。

可维护性：JavaScript代码如果分散到很多HTML页面，会导致维护困难。而用一个目录保存所有JavaScript文件，则更容易维护，这样开发者就可以独立于使用它们的HTML页面来编辑代码。

缓存：浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。

适应未来：通过把JavaScript放到外部文件中，就不必考虑用XHTML或前面提到的注释黑科技。包含外部JavaScript文件的语法在HTML和XHTML中是一样的。在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在SPDY/HTTP2中，预请求的消耗已显著降低，以轻量、独立JavaScript组件形式向客户端送达脚本更具优势

### 文档模式三种

混杂模式(quirks mode)和标准模式(standards mode)准标准模式(almoststandards mode)

混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关

准标准模式通过过渡性文档类型（ Transitional ）和框架集文档类型（ Frameset ）来触发

准标准模式与标准模式非常接近，很少需要区分。人们在说到“标准模式”时，可能指其中任何一个。而对文档模式的检测（本书后面会讨论）也不会区分它们。本书后面所说的标准模式，指的就是除混杂模式以外的模式

浏览器不支持脚本；

浏览器对脚本的支持被关闭。任何一个条件被满足，包含在 <noscript> 中的内容就会被渲染。否则，浏览器不会渲染 <noscript> 中的内容

### 总结

JavaScript是通过 <script> 元素插入到HTML页面中的。这个元素可用于把JavaScript代码嵌入到HTML页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的JavaScript。

要包含外部JavaScript文件，必须将 src 属性设置为要包含文件的URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。所有 <script> 元素会依照它们在网页中出现的次序被解释。

在不使用 defer 和 async 属性的情况下，包含在 <script>元素中的代码必须严格按次序解释。对不推迟执行的脚本，浏览器必须解释完位于 <script> 元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把 <script> 元素放到页面末尾，介于主内容之后及</body> 标签之前。

可以使用 defer 属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本总是按照它们被列出的次序执行。可以使用 async 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。

通过使用 <noscript> 元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用本，则 <noscript> 元素中的任何内容都不会被渲染。

### 三。语言基础

##### 语法：

广义上是为了表述一个完整的含义，将词组有效组合的方式，人类的语法实际上是按照习惯传承下来，各种语言的语法都不相同。
计算机语言的语法：计算机不能直接识别人类的文字符号，只能识别二进制指令。各种高级、低级的语言都最终被翻译成二进制指令，被计算机执行。这些指令实际上是告诉计算机你要做什么。由于二进制指令很难被人理解和使用，因此科学家分析这些二进制指令后将这些指令翻译成人类可以识别的文字程序。例如c、 c++、java、.net等、javascript。每一种语言都有特定的使用范围。

##### 语法结构

标识符
    定义：标识符是指变量、函数、属性的名字，或者函数的参数 通俗的讲：标识符就是一个名字
 命名规则：
        标识符首字符可以是以下划线（_）、美元符($)或者字母开始，不能是数字。
        标识符中其它字符可以是下划线（_）、美元符($)、字母或数字组成的。
        普通标识符（用作变量名、函数名和循环语句中用于跳转的标记）不能是保留字符

##### Js语法的基本要素

区分大小写
变量不区分类型
每条语句结尾可以省略分号
注释与C,C++,java,php相同
代码段要封闭

##### 变量：

变量必须以字母开头 变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）

概念：正如代数一样，JavaScript 变量用于保存值或表达式。可以给变量起一个简短名称，比如 x，或者更有描述性的名称，比如 length[1]  。JavaScript 变量也可以保存文本值，比如 carname="Volvo"。变量对大小写敏感（y 和 Y 是两个不同的变量变量必须以字母或下划线开始
注释：由于 JavaScript 对大小写敏感，变量名也对大小写敏感。 

##### 区分大小写：

ECMAScript中的一切（变量、函数名和操作符）都区分大小写；
例如： var say=”Hello world”; 和 var Say=”Hello world”;
其中声明的 say和Say是两个完全不同的变量，两者没有任何关系。

##### 注释：

单行注释以 // 开头。
多行注释以 /* 开始，以 */ 结尾。

##### 关键字

javascript 中的很多内置功能用关键字标注起来了，这样好让程序员调用。程序员只需写出这些关键字就能使用这些功能。例如“var”关键字是用来定义变量的功能，程序员只需写出这个关键字然后再加入一些自己的代码就可以定义一个自己命名的变量了

##### ECMAScript的全部关键字（掌握）：

break　　do　　instanceof　　typeof　　case　　else　　new　　var　　catch　　finally　　return　　void　　continue　　for　　switch　　while　　　　　　　　debugger　 function　　this　　with　default　　if　　throw　　delete　　in　　try

![image-20210118211343619](C:\Users\浦多电脑\AppData\Roaming\Typora\typora-user-images\image-20210118211343619.png)

Javascript保留字不可以用作变量,函数名，对象名等，其中有的保留字是为以后Javascript扩展用的

![image-20210118211402115](C:\Users\浦多电脑\AppData\Roaming\Typora\typora-user-images\image-20210118211402115.png)

### 函数

函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。ECMAScript中的函数使用function 关键字声明，后跟一组参数，然后是函数体。

 最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。严格模式对函数也有一些限制：

1.函数不能以 eval 或 arguments 作为名称；

2.函数的参数不能叫 eval 或 arguments ；

3.两个函数的参数不能叫同一个名称。

### 严格模式保留字

除了正常运行模式，ECMAscript 5添加了第二种运行模式："严格模式"（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。
设立"严格模式"的目的，主要有以下几个：
　1 、消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
	2、消除代码运行的一些不安全之处，保证代码运行的安全；
    3、提高编译器效率，增加运行速度；
    4、为未来新版本的Javascript做好铺垫。

#### 如何进入严格模式:

进入"严格模式"的标志，是下面这行语句："use strict";
为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。
使用这些词作为变量名将会报错

#### 全局变量的三种声明方式：

（1）声明方式一：
使用var（关键字）+变量名(标识符)的方式在function外部声明，即为全局变量，否则在function声明的是局部变量。该方式即为显式声明详细如下：
                        var test = 5;  //全局变量
			    function a（）
			   {
                        var cc=3; //局部变量
                        alert(test);
			   }
                       function b（）{alert(test);}

（2）没有使用var，直接给标识符test赋值，这样会隐式的声明了全局变量test。即使该语句是在一个function内，当该function被执行后test变成了全局变量。
                         test = 5;//全局变量 
                         function a()
                        {
                        aa=3; //全局变量
                        alert(test);
                         }

(3)使用window全局对象来声明，全局对象的属性对应也是全局变量，详细如下：
                    window.test;
                    window.test = 5;

#### 语句

if{}esle{}语句  do-while语句  while{}语句 for{}语句 for-in语句 for-of语句  

with语句： 

```
with(location) { 
let qs = search.substring(1);let hostName = hostname; 
let url = href;
}
```

with 语句用于连接 location 对象。这意味着在这个语句内部，每个变量首先会被认为是一个局部变量。如果没有找到该局部变量，则会搜索 location 对象，看它是否有一个同名的属性。如有，则该变量会被求值为 location 对象的属性。严格模式不允许使用 with 语句，否则会抛出错误。警告 由于 with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with 语句。

switch 语句：switch 语句是与 if 语句紧密相关的一种流控制语句

break 和 continue 语句 :break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中 break 语句用于立即退循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。

### 总结

JavaScript的核心语言特性在ECMA-262中以伪语言ECMAScript的形式来定义。ECMAScript包含所有基本语法、操作符、数据类型和对象，能完成基本的计算任务，但没有提供获得输入和产生输出的机制。理解ECMAScript及其复杂的细节是完全理解浏览器中JavaScript的关键。下面总结一下ECMAScript中的基本元素。

ECMAScript中的基本数据类型包括 Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。与其他语言不同，ECMAScript不区分整数和浮点值，只有Number 一种数值数据类型。Object 是一种复杂数据类型，它是这门语言中所有对象的基类。

严格模式为这门语言中某些容易出错的部分施加了限制。

ECMAScript提供了C语言和类C语言中常见的很多基本操作符，包括数学操作符、布尔操作符、关系操作符、相等操作符和赋值操作符等。

这门语言中的流控制语句大多是从其他语言中借鉴而来的，比如if 语句、 for 语句和 switch 语句等。ECMAScript中的函数与其他语言中的函数不一样。不需要指定函数的返回值，因为任何函数可以在任何时候返回任何值。不指定返回值的函数实际上会返回特殊值 undefined 。



# 第三章

## 一。变量、作用域与内存

#### 1、什么是作用域

一段代码在程序中起作用的范围。分为全局作用域和局部作用域。

#### 2、变量的作用域链

根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。 当内部函数访问变量时就形在了作用域链，查找变量时优先查找函数内部的变量，如果找到了就使用该变量，如果找不到向父级查找，最后找到window,如果window没有这个变量，则报错

#### 3、 垃圾回收机制的方式及内存管理

​      1、标记清除

​     2、引用计数

​     内存管理：1.全局变量和全局对象通过解除引用回收

​                          2.局部变量离开执行环境时自动回收

###  js执行上下文栈/作用域

自己理解的：

代码执行或函数调用生成执行上下文(只有当前执行上下文有执行权),该执行上下文内只能访问当前执行上下文的变量、函数和上一级执行上下文中的变量、函数,激活下一个执行上下文的时候执行权转移到新的执行上下文,“形成执行上下文栈。作用域是当前执行上下文中能访问的变量、函数的集合,执行上下文中只能访问当前作用域和其上执行上下文的作用域,由此形成作用域链

上下文栈：1.代码执行或函数调用生成执行上下文栈

​     2.该执行上下文栈只能访问本栈和上一个栈

​     3.激活新栈，执行权转移新栈，这样就形成了执行上下文栈

作用域：

1.根据在内部函数可以访问外部函数变量的这种机制，当内部函数访问	变量时就形在了作用域链

2.查找变量时优先查找函数内部的变量，如果找到了就使用该变量，如	果找不到向父级查找

3.最后找到window,如果window没有这个变量，则报错

### 1.原始值与引用值

ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。在把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。上一章讨论了6种原始值： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。引用值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用（reference）而非实际的对象本身。为此，保存引用值的变量是按引用（by reference）访问的。

**注意：在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript打破了这个惯例。**

### 2.动态属性

在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来

### 3.传递参数

ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用ECMAScript的话说，就是 arguments 对象中的一个槽位）。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量，这意味着对本地变量的修改会反映到函数外部。（这在ECMAScript中是不可能的。

### 4.确定类型

typeof 操作符最适合用来判断一个变量是否为原

始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔

值或 undefined 的最好方式。如果值是对象或 null ，那么

typeof 返回 "object" ，如下面的例子所示：

```java
let s = "Nicholas"; 
let b = true;
let i = 22;
let u; 

let n = null; 

let o = new Object(); 

console.log(typeof s); *// string* 

console.log(typeof i); *// number* 

console.log(typeof b); *// boolean* 

console.log(typeof u); *// undefined* 

console.log(typeof n); *// object* 

console.log(typeof o); *// object* 
```

### 5.变量

var：使用 var 的函数作用域声明在使用 var 声明变量时，变量会被自动添加到最接近的上下

文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文

let：ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号 {} 界定。换句话说， if 块、 while 块、function

块，甚至连单独的块也是 let 声明变量的作用域。let 与 var 的另一个不同之处是在同一作用域内不能声明两次。重复的 var 声明会被忽略，而重复的 let 声明会抛出SyntaxError

const：除了 let ，ES6同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值，const 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 const 变量不能再被重新赋值为其他引用值，但对象的键则不受限制，由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。

#### 6.变量提升和暂时性死区

变量提升现象：即变量可以在声明之前使用，值为undefined。
var 命令会发生“变量提升”现象；let 命令不存在“变量提升”。

```json
// var 的情况
console.log(foo);  // 输出 undefined
var foo = 2;
// let 的情况
console.log(bar); // 输出 ReferenceError
let bar = 2;

```

暂时性死区：ES6 明确规定，如果区块中存在 let 和 const 命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前使用这些变量，就会报错。这种语法称为“暂时性死区”（temporal dead zone，简称TDZ）。

```
var tmp = 123;
if (true) {
	// TDZ 开始
	tmp = 'abc';   // ReferenceError
	let tmp;   // TDZ 结束
}
```

#### 7.var、let、const的区别

1.var声明的变量存在变量提升，值为：undefined。允许重复声明变量，var和let可以修改已经声明的变量
2.let和const不存在变量提升。但是存在暂时性死区和块级作用域
（暂时性死区：在代码块内，let命令声明之前，该变量都是不可用的）
（块级作用域是由{ }包裹的，if语句和for语句里的{ }也属于块作用域）
3.const声明一个只读的常量，值不能改变。（引用数据类型可以改变内部的值）

## 总结

JavaScript变量可以保存两种类型的值：原始值和引用值。

原始值可能是以下6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有以下特点。

原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。

引用值是对象，存储在堆内存上。包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。

从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。

typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。

任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。

执行上下文分全局上下文、函数上下文和块级上下文。

代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。

函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。

全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。

变量的执行上下文用于确定什么时候释放内存。JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript的垃圾回收程序可以总结如下。

离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。

引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。

JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）。

引用计数在代码中存在循环引用时会出现问题。

解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。

# 第四章

### 1.基本引用类型

###### 基本数据值类型： Number、String、Boolean、Undefined、Null

##### 引用数据类型: Object。包含Object、Array、 function、Date

##### 数据类型检测的几种方式

Typeof：对于基本数据类型判断是没有问题的，但是遇到引用数据类型是不起作用

Instanceof： instanceof它用来判断这个构造函数的原型是否在给定对象的原型链上。 

constructorconstructor 属性返回对象的构造函数 返回值是函数的引用，不是函数名： 

### Date

ECMAScript的 Date 类型参考了Java早期版本中的java.util.Date

辅助方法： Date.parse() 和 Date.UTC() 。 

Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。ECMA-262第5版定义了

Date.parse() 应该支持的日期格式，填充了第3版遗留的空白。所有实现都必须支持下列日期格式

“月/日/年”，如 "5/23/2019" ； 

“月名 日, 年”，如 "May 23, 2019" ； 

“周几 月名 日 年 时:分:秒 时区”，如 "Tue May 23 2019 00:00:00GMT-0700" ；

ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05- 23T00:00:00 （只适用于兼容ES5的实现）

### 继承

ES5 有 6 种方式可以实现继承，分别为：

#### **1.** 原型链继承

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps1.png) |

原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

###### 缺点

1 通过原型来实现继承时，原型会变成另一个类型的实例，原先的实例属性变成了现在的原型属性，该原型的引用类型属性会被所有的实例共享。

2 在创建子类型的实例时，没有办法在不影响所有对象实例的情况下给超类型的构造函数中传递参数。

#### **2.** 借用构造函数

借用构造函数\的技术，其基本思想为:

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps2.png) |

在子类型的构造函数中调用超类型构造函数。

###### 优点:

1 可以向超类传递参数

2 解决了原型中包含引用类型值被所有实例共享的问题

###### 缺点

• 方法都在构造函数中定义，函数复用无从谈起，另外超类型原型中定义的方法对于子类型而言都是不可见的。

#### **3.** 组合继承(原型链 + 借用构造函数)

组合继承指的是将原型链和借用构造函数技术组合到一块，从而发挥二者之长的一种继承模式。基本思路：

![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps3.png)                                                                                                                                                       使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承，既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。

###### 缺点:

• 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。

###### 优点:

• 可以向超类传递参数

• 每个实例都有自己的属性

• 实现了函数复用

##### **4.** 原型式继承

原型继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。

![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps4.png) 

在 object()  函数内部，先穿甲一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例， 从本质上讲，object() 对传入的对象执行了一次浅拷贝。

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps5.png) |



ECMAScript5 通过新增 Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。在没有必要创建构造函数，仅让一个对象与另一个对象保持相似的情况下，原型式继承是可以胜任的。

###### 缺点:同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。

#### **5.** 寄生式继承

![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps6.png)                                                                                                                                                                     寄生式继承是与原型式继承紧密相关的一种思路。寄生式继承的思路 与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数， 该函数在内部已某种方式来增强对象，最后再像真地是它做了所有工作一 样返回对象。

基于 person 返回了一个新对象 -—— person2，新对象不仅具有person 的所有属性和方法，而且还有自己的 sayHi()  方法。在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。

##### 缺点：

• 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。

• 同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。

###### **6.** 寄生组合式继承

所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法，基本思路：不必为了指定子类型的原型而调用超类型的构造函数，我们需要的仅是超类型原型的一个副本，本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：

![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps7.png) 

• 第一步：创建超类型原型的一个副本

• 第二步：为创建的副本添加 constructor  属性

• 第三步：将新创建的对象赋值给子类型的原型

至此，我们就可以通过调用 inheritPrototype  来替换为子类型原型赋值的语句：

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps8.png) |

##### 优点:只调用了一次超类构造函数，效率更高。避免在 SuberType.prototype

上面创建不必要的、多余的属性，与其同时，原型链还能保持不变。因此寄生组合继承是引用类型最理性的继承范式。

####  Es6实现继承

## ![img](file:///C:\Users\浦多电脑\AppData\Local\Temp\ksohtml9516\wps9.png)

 

## 日期格式化方法

Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：

toDateString() 显示日期中的周几、月、日、年（格式特定于实现）；

toTimeString() 显示日期中的时、分、秒和时区（格式特定于实现）；

toLocaleDateString() 显示日期中的周几、月、日、年（格式特定于实现和地区）；

toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实现）；

toUTCString() 显示完整的UTC日期（格式特定于实现）。

还有一个方法叫 toGMTString() ，这个方法跟toUTCString() 是一样的，目的是为了向后兼容。不过，规范建议新代码使用 toUTCString() 

### 日期**/**时间组件方法

getTime()返回日期的毫秒表示；与valueOf() 相同

setTime(*milliseconds*)设置日期的毫秒表示，从而修改整个日期

getFullYear()返回4位数年(即2019而不是19） 

getUTCFullYear()返回UTC日期的4位数年

setFullYear(*year*)设置日期的年（ *year* 必须是4位数）

setUTCFullYear(*year*) 设置UTC日期的年（ *year* 必须是4位数）

getMonth() 返回日期的月（0表示1月，11表 示12月）

getUTCMonth()  返回UTC日期的月（0表示1月，11表示12月）

setMonth(*month*)设置日期的月（ *month* 为大于0的数值，大于11加年）

setUTCMonth(*month*)设置UTC日期的月（ *month* 为大于0的数值，大于11加年）

getDate()返回日期中的日（1~31） 

getUTCDate()返回UTC日期中的日（1~31） 

setDate(*date*)设置日期中的日（如果 *date* 大于该月天数，则加月）

setUTCDate(*date*)设置UTC日期中的日（如果date大于该月天数，则加月）

getDay()返回日期中表示周几的数值（0表示周日，6表示周六）方法 

getUTCDay()返回UTC日期中表示周几的数值（0表示周日，6表示周六）

getHours()返回日期中的时（0~23） 

getUTCHours()返回UTC日期中的时（0~23） 

setHours(*hours*)设置日期中的时（如果 *hours*大于23，则加日）

setUTCHours(*hours*)设置UTC日期中的时（如果hours* 大于23，则加日）

getMinutes()返回日期中的分（0~59） 

getUTCMinutes()返回UTC日期中的分（0~59） 

setMinutes(*minutes*)设置日期中的分（如果minutes* 大于59，则加时）

setUTCMinutes(*minutes*)设置UTC日期中的分（如果minutes* 大于59，则加时）方法 

getSeconds()返回日期中的秒（0~59） 

getUTCSeconds()返回UTC日期中的秒（0~59） 

setSeconds(*seconds*)设置日期中的秒（如果seconds* 大于59，则加分）

setUTCSeconds(*seconds*)设置UTC日期中的秒（如果seconds* 大于59，则加分）

getMilliseconds()返回日期中的毫秒

getUTCMilliseconds()返回UTC日期中的毫秒

setMilliseconds(*milliseconds*)设置日期中的毫秒

setUTCMilliseconds(*milliseconds*)设置中的毫秒 UTC日期

getTimezoneOffset()返回以分钟计的UTC与本地时区的偏移量（如美国EST即“东部标准时间”返回300，进入夏令时的地区可能有所差异）

### 模式局限

虽然ECMAScript对正则表达式的支持有了长足的进步，但仍然缺少Perl语言中的一些高级特性。下列特性目前还没有得到ECMAScript的支持（想要了解更多信息，可以参考Regular-Expressions.info网站）：

\A 和 \Z 锚（分别匹配字符串的开始和末尾）联合及交叉类原子组

x （忽略空格）匹配模式条件式匹配

正则表达式注释 虽然还有这些局限，但ECMAScript的正则表达式已经非常强大，可以

用于大多数模式匹配任务

## 原始值包装类型

为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：

Boolean 、 Number 和 String 。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。

引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过new 实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间。这意味着不能在运行时给原始值添加属性和方法。

可以显式地使用 Boolean 、 Number 和 String 构造函数创建原始值包装对象。不过应该在确实必要时再这么做否则容易让开发者疑惑，分不清它们到底是原始值还是引用值。在原始值包装类型的实例上调用typeof 会返回 "object" ,所有原始值包装对象都会转换为布尔值true 。另外， Object 构造函数作为一个工厂方法，能够根据传入值的类型返回相应原始值包装类型的实例

###### Number 

Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值。与 Boolean 类型一样， Number 类型重写了 valueOf() 、toLocaleString() 和 toString() 方法。 valueOf() 方法返回Number 对象表示的原始数值，另外两个方法返回数值字符串。toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串。

toFixed() 方法返回包含指定小数点位数的数值字符串

toExponential() 也接收一个参数，表示结果中小数的位数

toPrecision() 方法会根据情况返回最合理的输出结果，可能是固定长度，也可能是科学记数法形式。这个方法接收一个参数，表示结果中数字的总位数（不包含指数）

isInteger() 方法与安全整数ES6新增了 Number.isInteger() 方法，用于辨别一个数值是否保存为整数。有时候，小数位的0可能会让人误以为数值是一个浮点值

String ：String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值

**JavaScript**

JavaScript字符串由16位码元（code unit）组成。对多数字符来说，每16位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少16位码元，此外， charAt() 方法返回给定索引位置的字符，由传给方法的整数参数指定。具体来说，这个方法查找指定索引位置的16位码元，并返回该码元对应的字符。

charCodeAt() 方法可以查看指定码元的字符编码。这个方法返回指定索引位置的码元值，索引以整数指定。

fromCharCode() 方法用于根据给定的UTF-16码元创建字符串中的字符。这个方法可以接受任意多个数值，并返回将所有数值对应的字符拼接起来的字符串

normalize() 方法某些Unicode字符可以有多种编码方式。有的字符既可以通过一个BMP字符表示，也可以通过一个代理对表示。通过比较字符串与其调用 normalize() 的返回值，就可以知道该字符串是否已经规范化了。

### 字符串操作方法

 concat() ：用于将一个或多个字符串拼接成一个新字符串

ECMAScript提供了3个从字符串中提取子字符串的方法：slice() 、 substr() 和 substring() 。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。对slice() 和 substring() 而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。对 substr() 而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。与 concat() 方法一样， slice() 、 substr() 和 substring() 也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值

#### 字符串位置方法

有两个方法用于在字符串中定位子字符串： 

indexOf() 和 lastIndexOf() 。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）。两者的区别在于，indexOf() 方法从字符串开头开始查找子字符串，而lastIndexOf() 方法从字符串末尾开始查找子字符串。

### 字符串包含方法

ECMAScript 6增加了3个用于判断字符串中是否包含另一个字符串的方法 startsWith() 、 endsWith() 和 includes() 。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于， startsWith() 检查开始于索引0的匹配项endsWith() 检查开始于索引 (string.length - substring.length) 的匹配项，而 includes() 检查整个字符串。

startsWith() 和 includes() 方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。

endsWith() 方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样

trim() 方法

ECMAScript在所有字符串上都提供了 trim() 方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果。比如：

let stringValue = " hello world "; 

let trimmedStringValue = stringValue.trim(); 

console.log(stringValue); *// " hello* world "

console.log(trimmedStringValue); *// "hello* world"

由于 trim() 返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。

另外， trimeLeft() 和 trimRight() 方法分别用于从字符串开始和末尾清理空格符。

repeat() 方法：

ECMAScript在所有字符串上都提供了 repeat() 方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。

 padStart() 和 padEnd() 方法：

padStart() 和 padEnd() 方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）

###### 字符串迭代与解构

字符串的原型上暴露了一个 @@iterator 方法，表示可以迭代字符串的每个字符

###### 字符串大小写转换

下一组方法涉及大小写转换，包括4个方法： toLowerCase() 、 toLocaleLowerCase() 、 toUpperCase() 和 toLocaleUpperCase() 。

toLowerCase() 和 toUpperCase() 方法是原来就有的方法，与 java.lang.String中的方法同名。 toLocaleLowerCase() 和 toLocaleUpperCase() 方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语），Unicode大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换

###### 字符串模式匹配方法

String 类型专门为在字符串中实现模式匹配设计了几个方法。第一个就是 match() 方法，这个方法本质上跟 RegExp 对象的 exec()方法相同。 match() 方法接收一个参数，可以是一个正则表达式字符串，也可以是一个 RegExp 对象

match() 方法返回的数组与 RegExp 对象的 exec() 方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。另一个查找模式的字符串方法是 search() 。这个方法唯一的参数与match() 方法一样：正则表达式字符串或 RegExp 对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。 search()始终从字符串开头向后匹配模式

$$  $   $&

匹配整个模式的子字符串。与 RegExp.lastMatch相同

$'

匹配的子字符串之前的字符串。与RegExp.rightContext 相同

$`

匹配的子字符串之后的字符串。与RegExp.leftContext 相同

$*n*

匹配第 *n* 个捕获组的字符串，其中 *n* 是0~9。比如， $1 是匹配第一个捕获组的字符串， $2 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串

$*nn*

匹配第 *nn* 个捕获组字符串，其中 *nn* 是01~99。比如， $01 是匹配第一个捕获组的字符串， $02 是匹配第二个捕获组的字符串，以此类推。如果没有捕获组，则值为空字符串

localeCompare() 方法

最后一个方法是 localeCompare() ，这个方法比较两个字符串，返回如下3个值中的一个。如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值。（通常是 -1 ，具体还要看与实际值相关的实现。）如果字符串与字符串参数相等，则返回 0 。如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值。（通常是 1 ，具体还要看与实际值相关的实现。）

## 单例内置对象

Global 对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。ECMA-262规定 Global 对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。事实上，不存在全局变量或全局函数这种东西。在全局作用域中定义的变量和函数都会变成 Global 对象的属性 。本书前面介绍的函数，包括 isNaN() 、 isFinite() 、 parseInt() 和 parseFloat() ，实际上都是 Global 对象的方法。除了这些，Global 对象上还有另外一些方法。

**URL**编码方法

encodeURI() 和 encodeURIComponent() 方法用于编码统一资源标识符（URI），以便传给浏览器。有效的URI不能包含某些字符，比如空格。使用URI编码方法来编码URI可以让浏览器能够理解它们，同时又以特殊的UTF-8编码替换掉所有无效字符。ecnodeURI() 方法用于对整个URI进行编码，比如 "www.wrox.com/illegal value.js" 。而encodeURIComponent() 方法用于编码URI中单独的组件，比如前面URL中的 "illegal value.js" 。这两个方法的主要区别是，encodeURI() 不会编码属于URL组件的特殊字符，比如冒号、斜杠、问号、井号，而 encodeURIComponent() 会编码它发现的所有非标准字符

eval() 方法

最后一个方法可能是整个ECMAScript语言中最强大的了，它就是eval() 。这个方法就是一个完整的ECMAScript解释器，它接收一个参数，即一个要执行的ECMAScript（JavaScript）字符串。

###### Global 对象属性

Global 对象有很多属性，其中一些前面已经提到过了。像

undefined 、 NaN 和 Infinity 等特殊值都是 Global 对象的属

性。此外，所有原生引用类型构造函数，比如 Object 和 

Function ，也都是 Global 对象的属性。下表列出了所有这些属性。

undefined 特殊值 undefined 

NaN 特殊值 NaN

Infinity 特殊值 Infinity 

Object  Object 的构造函数

Array  Array 的构造函数

Function  Function 的构造函数

Boolean  Boolean 的构造函数

String  String 的构造函数

Number  Number 的构造函数

Date  Date 的构造函数

RegExp  RegExp 的构造函数

Symbol  Symbol 的伪构造函数

Error  Error 的构造函数

EvalError  EvalError 的构造函数

RangeError  RangeError 的构造函数

ReferenceError  ReferenceError 的构造函数

SyntaxError  SyntaxError 的构造函数

TypeError  TypeError 的构造函数

URIError URIError 的；构造函数

window 对象虽然ECMA-262没有规定直接访问 Global 对象的方式，但浏览器将window 对象实现为 Global 对象的代理。因此，所有全局作用域中声明的变量和函数都变成window 的属性

###### Math 对象属性

Math 对象有一些属性，主要用于保存数学中的一些特殊值。下表列出了这些属性。

Math.E  自然对数的基数e的值

Math.LN10  10为底的自然对数

Math.LN2 2为底的自然对数

Math.LOG2E  以2为底e的对数

Math.LOG10E  以10为底e的对数

Math.PI  π的值

Math.SQRT1_2  1/2的平方根

Math.SQRT2  2的平方根

######  min() 和 max() 方法

Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。

min() 和 max() 方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数

######  舍入方法

接下来是用于把小数值舍入为整数的4个方法： Math.ceil() 、 Math.floor() 、 Math.round() 和 Math.fround() 。

Math.ceil() 方法始终向上舍入为最接近的整数。

Math.floor() 方法始终向下舍入为最接近的整数。

Math.round() 方法执行四舍五入。

Math.fround() 方法返回数值最接近的单精度（32位）浮点值表示

###### random() 方法

Math.random() 方法返回一个0~1范围内的随机数，其中包含0但不包含1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。可以基于如下公式使用 Math.random() 从一组整数中随机选择一个数

###### 其他方法

Math 对象还有很多涉及各种简单或高阶数运算的方法。讨论每种方法的具体细节或者它们的适用场景超出了本书的范畴。

###### 总结了 Math 对象的其他方法。

Math.abs(*x*)  返回 *x* 的绝对值

Math.e*x*p(*x*)  返回 Math.E 的 *x* 次幂

Math.e*x*pm1(*x*)  等于 Math.e*x*p(*x*) - 1Math.log(*x*)  返回 *x* 的自然对数

Math.log1p(*x*)  等于 1 + Math.log(*x*) 

Math.pow(*x*, power)  返回 *x* 的 *power* 次幂

Math.pow(*...nums*) 返回根 *nums* 中每个数平方和的平方

Math.clz32(*x*)  返回32位整数 *x* 的前置零的数量

Math.sign(*x*) 返回表示 *x* 符号的 1 、 0 、 -0 或 -1 

Math.trunc(*x*) 返回 *x* 的整数部分，删除所有小数 

Math.sqrt(*x*)  返回 *x* 的平方根

Math.cbrt(*x*)  返回 *x* 的立方根

Math.acos(*x*)  返回 *x* 的反余弦

Math.acosh(*x*)  返回 *x* 的反双曲余弦

Math.asin(*x*)  返回 *x* 的反正弦

Math.asinh(*x*)  返回 *x* 的反双曲正弦

Math.atan(*x*)  返回 *x* 的反正切

Math.atanh(*x*)  返回 *x* 的反双曲正切

Math.atan2(*y*, *x*)  返回 *y*/*x* 的反正切

Math.cos(*x*)  返回 *x* 的余弦

Math.sin(*x*)  返回 *x* 的正弦

Math.tan(*x*)  返回 *x* 的正切

## 总结

JavaScript中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。引用值与传统面向对象编程语言中的类相似，但实现不同。

Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。

RegExp 类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。

JavaScript比较独特的一点是，函数实际上是 Function 类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。

由于原始值包装类型的存在，JavaScript中的原始值可以被当成对象来使用。有3种原始值包装类型： Boolean 、 Number 和 String 。它们都具备如下特点。每种包装类型都映射到同名的原始类型。以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。涉及原始值的语句执行完毕后，包装对象就会被销毁。当代码开始执行时，全局上下文中会存在两个内置对象： Global 和 Math 。其中， Global 对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是Global 对象的属性。 Math 对象包含辅助完成复杂计算的属性和方法。

# 第五章·

## 第五章 基本引用类型

```
本章内容
1.理解对象
2.基本JavaScript数据类型
3.原始值与原始值包装类型
```

#### 1.**原始值和引用值**

在 ECMAScript 中，变量可以存在两种类型的值，即**原始值**和**引用值**。

#### 1.1 **原始值**

(1).原始值指的是原始类型的值，也叫基本类型，例如 Number、Stirng、Boolean、Null、Underfined 。

(2).存储在**栈（stack）**中的简单数据段，也就是说，它们的值直接存储在**变量访问的位置**。

(3).注意:

 在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript 打破了这一传统。

#### 1.2**引用值**

（1）引用值指的是 **引用类型** 的值，例如 Object、Function、Array、Date、RegExp 。

（2）存储在**堆（heap）**中的对象，也就是说，存储在变量处的值是一个**指针**（point），指向存储**对象的内存处**。

#### 2.**栈和堆**

#### 2.1**原始值存储在栈中**

为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的**原始类型**之一，即 Undefined、Null、Boolean、Number 和 String 型。由于这些原始类型**占据的空间是固定的**，所以可将他们存储在较小的内存区域 - **栈中**。这样存储便于迅速查寻变量的值。

#### 2.2 **引用值存储在堆中**

如果一个值是**引用类型**的，那么它的存储空间将从**堆中**分配。由于引用值的**大小会改变**，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。

## 二.原始值包装类型

为了方便操作原始值，ECMAScript有3种特殊引用类型：

Boolean,Number和String.

每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，暴露出操作原始值的各种方法。

在以读模式访问字符串的方法或者属性时，总会在后台执行以下三步：
（1）创建一个原始值类型的实例
（2）调用这个实例上的方法（或读取这个实例上的属性）
（3）销毁这个实例

用代码表示出来则为：

```
let str = new String('I love China!');
console.log(str.slice(0,6));
str = null;
```

所以在非严格模式下，当我们尝试给原始值赋值时`str.age=18`，其实是生成了一个原始值包装类型的，也是给它赋了值的，但是，这句话执行完之后，这个原始值包装类型就被销毁了。而在下一次再次读取这个属性时`console.log(str.age)`，其实又再次创建了一个原始值包装类型对象，这个对象和之前那个不是一个对象，所以`str.age`为`undefined`



## 三 基本JavaScript数据类型

在JavaScript种一共有6种数据类型：Null、Undefined、Boolean、String、Number、Object。其中Object是一种复杂数据类型。

**基本数据类型：Null、Undefined、Boolean、String、Number。**

**引用数据类型：Object、Array、Date、RegExp。**

Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关 计算。

 RegExp 类型是ECMAScript支持正则表达式的接口，提供了大多数基 础的和部分高级的正则表达式功能。

JavaScript中的对象称为引用值，几种内置的引用类型可用于创建特定 类型的对象。 引用值与传统面向对象编程语言中的类相似，但实现不同。

# 第六章

数组与定型数组：

**1.Object**

到目前为止，大多数引用值的示例使用的是 Object 类型。

Object 是ECMAScript中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，

```
let person = new Object(); 

person.name = "Nicholas"; 

person.age = 29;
```

另一种方式是使用对象字面量（object literal）表示法。对象字面量是

对象定义的简写形式，目的是为了简化包含大量属性的对象的创建。比

如，下面的代码定义了与前面示例相同的 person 对象，但使用的是对象

字面量表示法：

```
let person = { 

		name: "Nicholas", 

		age: 29 

};
```

在使用对象字面量表示法定义对象时，并不会实际调用 Object 构造函数

##### 2.Array

除了 Object ， Array 应该就是ECMAScript中最常用的类型了。

ECMAScript数组跟其他编程语言的数组有很大区别。跟其他语言中的数组一样，ECMAScript数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。这意味着可以创建一个数组，它的第一个元素是字符串，第二个元素是数值，第三个是对象。ECMAScript数组也是动态大小的，会随着数据添加而自动增长。

#### 创建数组

有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如：

let colors = new Array();

如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然

后 length 属性就会被自动创建并设置为这个值。比如创建一个初始 length 为20的数组：

let colors = new Array(20);

也可以给 Array 构造函数传入要保存的元素。比如，创建一个包含3个字符串值的数组：

let colors = new Array("red", "blue", "green");

创建数组

有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如：

let colors = new Array();

如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然

后 length 属性就会被自动创建并设置为这个值。比如，创建一个初始 length 为20的数组：

let colors = new Array(20);

也可以给 Array 构造函数传入要保存的元素。比如，创建一个包含3个字符串值的数组：

let colors = new Array("red", "blue", "green");

与对象一样，在使用数组字面量表示法创建数组不会调用Array 构造函数。

Array 构造函数还有两个ES6新增的用于创建数组的静态方法：

from() 和 of() 。 from() 用于将类数组结构转换为数组实例，而of() 用于将一组参数转换为数组实例。

Array.from() 的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性和可索引元素的结构。这种方式可用于很多场合：

```json
// 字符串会被拆分为单字符数组 console.log(Array.from("Matt")); // ["M", "a", "t", "t"] 
// 可以使用from()将集合和映射转换为一个新数组
const m = new Map().set(1, 2) .set(3, 4);
const s = new Set().add(1) .add(2) .add(3) .add(4);
console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] 
// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]; const a2 = Array.from(a1); console.log(a1); // [1, 2, 3, 4]
alert(a1 === a2); // false 
// 可以使用任何可迭代对象
const iter = { *[Symbol.iterator]() { yield 1; yield 2; yield 3; yield 4; } };console.log(Array.from(iter)); // [1, 2, 3, 4] 
// arguments对象可以被轻松地转换为数组
function getArgsArray() { return Array.from(arguments); }console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]
// from()也能转换带有必要属性的自定义对象
const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4, length: 4 };
console.log(Array.from(arrayLikeObject)); // [1, 2, 3,4]

Array.from() 还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用 Array.from().map() 那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中this 的值。但这个重写的 this 值在箭头函数中不适用。
```

```java
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1, x => x**2); 
const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2});
console.log(a2); // [1, 4, 9, 16] 
console.log(a3); // [1, 4, 9, 16] 

Array.of() 可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的Array.prototype.slice.call(arguments) ，一种异常笨拙的将 arguments 对象转换为数组的写法：
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] console.log(Array.of(undefined)); // [undefined]
```

#### 数组空位

使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规范重新定义了该如何处理这些空位

ES6新增的方法和迭代器与早期ECMAScript版本中存在的方法行为不同。ES6新增方法普遍将这些空位当成存在的元素，只不过值为undefined 

**由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 undefined 值代替**

#### 数组索引

要取得或设置数组的值，需要使用中括号并提供相应值的数字索引,数组最多可以包含4 294 967 295个元素，这对于大多数编程任务应该足够了。如果尝试添加更多项，则会导致抛出错误。以这个最大值作为初始值创建数组，可能导致脚本运行时间过长的错误。

#### 检测数组

一个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣。使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。为解决这个问题，ECMAScript提供了 Array.isArray() 方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。

#### 迭代器方法 

在ES6中， Array 的原型上暴露了3个用于检索数组内容的方法：keys() 、 values() 和 entries() 。 keys() 返回数组索引的迭代器， values() 返回数组元素的迭代器，而 entries() 返回索引/值对的迭代器。

#### 复制和填充方法

ES6新增了两个方法：批量复制方法 fill() ，以及填充数组方法copyWithin() 。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法创建的数组不能缩放。

使用 fill() 方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引

#### 转换方法

所有对象都有 toLocaleString() 、 toString() 和 valueOf() 方法。其中， valueOf() 返回的还是数组本身。而toString() 返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString() 方法，以得到最终的字符串。

继承的方法 toLocaleString() 以及 toString() 都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用 join() 方法。 join() 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。

如果数组中某一项是 null 或 undefined ，则在 join() 、 toLocaleString() 、 toString() 和 valueOf() 返回的结果中会以空字符串表示。

#### 栈方法

ECMAScript给数组提供几个方法，让它看起来像是另外一种数据结构。数组对象可以像栈一样，也就是一种限制插入和删除项的数据结构。栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为推入，push）和删除（称为弹出，pop）只在栈的一个地方发生，即栈顶。ECMAScript数组提供了 push() 和 pop() 方法，以实现类似栈的行为。push() 方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。 pop() 方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。

#### 队列方法

就像栈是以LIFO形式限制访问的数据结构一样，队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 push() 方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫shift() ，它会删除数组的第一项并返回它，然后数组长度减1。使用shift() 和 push() ，可以把数组当成队列来使用。

### 排序方法

数组有两个方法可以用来对元素重新排序： reverse() 和 sort() 。顾名思义， reverse() 方法就是将数组元素反向排列。

 

reverse() 和 sort() 都返回调用它们的数组的引用。如果数组的元素是数值，或者是其 valueOf() 方法返回数值的对象（如 Date 对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值。

object
大多数引用值的示例使用的是 Object 类型
Object 是ECMAScript中最常用的类型之一
使用方法：
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29;

let person = { 
  name: "Nicholas", age: 29
 };

array
除了 Object ， Array 应该就是ECMAScript中最常用的类型
使用array方法创建数组：
let colors = new Array();
数组长度
let colors = new Array(20);
值
let colors = new Array("1", "2", "3");

set
使用数组初始化集合
const s1 = new Set(["val1", "val2", "val3"]);

使用 new 关键字和 Set 构造函数可以创建一个空集合
const m = new Set();
可以用add网数组中添加元素
用delete删除数组中某个元素
clear可以删除数组中所有元素
用has可以查询数组中是否包含元素 返回值为 t / f

#  第七章

1.迭代器与生成器:是按照顺序反复多次执行一段程序， 通常会有明确的终止条件

迭代:计数循环就是一种最简单的迭代,循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及 每次迭代要执行什么操作

```js
for (let i = 1; i <= 10; ++i) {
console.log(i);
}

```

2.迭代器模式:它们实现 了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费

3.可迭代协议:实现 Iterable 接口（可迭代协议）要求同时具备两种能力： 支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能 力

很多内置类型都实现了 Iterable 接口：

字符串 

数组 

映射

集合 

arguments 对象

NodeList 等DOM集合类型

接收可迭代对象的原生语言特性包括： 

for-of 循环 

数组解构 

扩展操作符 

Array.from() 

创建集合

创建映射 

Promise.all() 接收由期约组成的可迭代对象 

Promise.race() 接收由期约组成的可迭代对象 

yield* 操作符，在生成器中使用

4.迭代器协议:迭代器是一种一次性使用的对象,使用 next() 方法在可迭代对象中遍历数据,每次成 功调用 next() ，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next() ，则无法知道迭代器的 当前位置。

5.自定义迭代器:，任何实现 Iterator 接口的对象都可 以作为迭代器使用

6.提前终止迭代器:可选的 return() 方法用于指定在迭代器提前关闭时执行的逻辑

7.生成器:生成器的形式是一个函数，函数名称前面加一个星号（ * ）表示 它是一个生成器。只要是可以定义函数的地方，就可以定义生成器

```js
// 生成器函数声明
function* generatorFn() {}
// 生成器函数表达式
let generatorFn = function* () {}
// 作为对象字面量方法的生成器函数
let foo = {
* generatorFn() {}
}
// 作为类实例方法的生成器函数
class Foo {
* generatorFn() {}
}
// 作为类静态方法的生成器函数
class Bar {
static * generatorFn() {}
}
```

# 第八章

1.理解对象:创建自定义对象的方式一般是创建 Object 的一个新实例，然后 再给它添加属性和方法

```js
let person = new Object();
person.name = "Nicholas";
person.sayName = function() {
console.log(this.name);
};
```

2.属性的类型:1> 数据属性 2> 访问器属性

3.定义多个属性: Object.defineProperties() 方法

这个方法可以通过多个描述符一次性定义多个属性

```js
let book = {};
Object.defineProperties(book, {
year_: {
value: 2017
},
edition: {
value: 1
},
year: {
get() {
return this.year_;
},
set(newValue) {
if (newValue > 2017) {
this.year_ = newValue;
this.edition += newValue - 2017;
}
}
}
});
```

这段代码在 book 对象上定义了两个数据属性 year_ 和 edition ，还有一个访问器属性 year 。最终的对象跟上一节示例 中的一样。唯一的区别是所有属性都是同时定义的

4.对象解构:

对象的
var obj = {name:"张三",age:16,hhh:{a:'a',b:'b',ccc:{d:'d'}}}
var {name,age,hhh:{a,b,ccc:{d}}}=obj

对象的
var obj={"employee":{"name":"Bill","age":70,"city":"Seattle"}}
var {employee:{name,age,city}}=obj

数组的
var arr={"employee":["Bill","Steve","David"]}
var {employee:[a,b,c]}=arr

数组的
var  text={"name":"Bill","birth":"1955-12-34","city":"Seattle","cxq":["ass","Steve","button"]}
var  {name,birth,city,cxq:[a,b,c]}=text

```js
let person = {
name: 'Matt',
age: 27
};
let { name: personName, age: personAge } =person;
console.log(personName); // Matt
console.log(personAge); // 27
```

```js
let person = {
name: 'Matt',
age: 27
};
let { name, age } = person;
console.log(name); // Matt
console.log(age); // 27
```

5.类定义:

定义类也有两种主要方式：类声明和类表达式.这两种方式都使用 class 关键字加大括号

```js
// 类声明
class Person {}
// 类表达式
const Animal = class {};
```

函数声明可以提升，但类定义不能

函数受函数作用域限制，而类 受块作用域限制

类构造函数:constructor 关键字用于在类定义块内部创建类的构造函数。 方法名 constructor 会告诉解释器在使用 new 操作符创建类的新 实例时，应该调用这个函数

# 第九章

##### 1.代理基础

```js
最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。

const target = { id: 'target' };const handler = {}; const proxy = new Proxy(target, handler);
// id属性会访问同一个值
console.log(target.id); 
// target console.log(proxy.id); // target // 给目标属性赋值会反映在两个对象上
// 因为两个对象访问的是同一个值
target.id = 'foo'; console.log(target.id); 
// foo console.log(proxy.id); // foo // 给代理属性赋值会反映在两个对象上
// 因为这个赋值会转移到目标对象
proxy.id = 'bar'; console.log(target.id); 
// bar console.log(proxy.id); // bar // hasOwnProperty()方法在两个地方
// 都会应用到目标对象
console.log(target.hasOwnProperty('id')); // true console.log(proxy.hasOwnProperty('id')); // true // Proxy.prototype是undefined
// 因此不能使用instanceof操作符
console.log(target instanceof Proxy); // TypeError: Function has non-object prototype
'undefined' in instanceof check
console.log(proxy instanceof Proxy); // TypeError: Function has non-object prototype
'undefined' in instanceof check
// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false
```

####  定义捕获器

```js
使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。

const target = { 
    foo: 'bar' 
};
const handler = { 
    // 捕获器在处理程序对象中以方法名为键
	get() {
        return 'handler override'; 
    } 
};
const proxy = new Proxy(target, handler);
```

#### **** 捕获器参数和反射**API**

```js
所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如， get() 捕获器会接收到目标对象、要查询的属性和代理对象三个参数.

const target = {
    foo: 'bar' 
};
const handler = { 
    get(trapTarget, property, receiver) { 
        console.log(trapTarget === target);
		console.log(property); 
        console.log(receiver === proxy); 
    } 
};
const proxy = new Proxy(target, handler);
proxy.foo; 
// true
// foo 
// true
```

####  捕获器不变式

```js
使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据ECMAScript规范，每个捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。

const target = {};
Object.defineProperty(target, 'foo', {
    configurable: false,
    writable: false, 
    value: 'bar' 
}); 
const handler = { 
    get() { 
        return 'qux'; 
    } 
};
const proxy = new Proxy(target, handler); 
console.log(proxy.foo);
// TypeError
```

#### 可撤销代理

```js
有时候可能需要中断代理对象与目标对象之间的联系。对于使用new Proxy() 创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。Proxy 也暴露了 revocable() 方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（ revoke() ）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError 。

const target = { 
    foo: 'bar' 
};
const handler = { 
    get() {
        return 'intercepted';
    } 
};
const { proxy, revoke } =
      Proxy.revocable(target, handler);
console.log(proxy.foo); // intercepted 
console.log(target.foo); // bar
revoke(); 
console.log(proxy.foo); // TypeError
```

####  实用反射**API**

```js
1. 反射API与对象API
在使用反射API时，要记住：
(1) 反射API并不限于捕获处理程序；
(2) 大多数反射API方法在 Object 类型上有对应的方法。
通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。
2. 状态标记:
很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射API方法更有用。例如，可以使用反射API对下面的代码进行重构：

// 初始代码
const o = {};
try { 
    Object.defineProperty(o, 'foo', 'bar'); 
    console.log('success'); 
} catch(e) { 
    console.log('failure'); 
}
```

#### 代理另一个代理

```js
代理可以拦截反射API的操作，而这意味着完全可以创建一个代
理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建
多层拦截网：

const target = {
    foo: 'bar'
};
const firstProxy = new Proxy(target, { 
    get() { 
        console.log('first proxy'); 
        return Reflect.get(...arguments); 
    } 
});
const secondProxy = new Proxy(firstProxy, { 
    get() { 
        console.log('second proxy');
        return Reflect.get(...arguments); 
    } 
}); 
console.log(secondProxy.foo);
// second proxy 
// first proxy
// bar
```

#### 代理的问题与不足

```js
代理是在ECMAScript现有基础之上构建起来的一套新API，因此其实现已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的ECMAScript机制很好地协同。

1. 代理中的 this
代理潜在的一个问题来源是 this 值。我们知道，方法中的this 通常指向调用这个方法的对象：
const target = { 
    thisValEqualsProxy() {
        return this === proxy; 
    } 
}
const proxy = new Proxy(target, {}); console.log(target.thisValEqualsProxy()); // false 
console.log(proxy.thisValEqualsProxy()); // true
```

### 2、 代理捕获器与反射方法

####  get() 

```js
get() 捕获器会在获取属性值的操作中被调用。对应的反射API方法为 Reflect.get().

const myTarget = {};
const proxy = new Proxy(myTarget, {
    get(target, property, receiver) { 
        console.log('get()'); 
        return Reflect.get(...arguments)
    }
}); 
proxy.foo; 
// get()
```

####  set() 

```js
set()捕获器会在设置属性值的操作中被调用。对应的反射API方法为Reflect.set() 。

const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
    set(target, property, value, receiver) { 
        console.log('set()'); 
        return Reflect.set(...arguments) 
    } 
}); 
proxy.foo = 'bar'; 
// set()
```

####  has()

```js
has() 捕获器会在 in 操作符中被调用。对应的反射API方法为 Reflect.has() 。 

const myTarget = {};
const proxy = new Proxy(myTarget, {
    has(target, property) { 
        console.log('has()'); 
        return Reflect.has(...arguments)
    } 
});
'foo' in proxy;
// has()
```

#### defineProperty()

```js
defineProperty() 捕获器会在Object.defineProperty() 中被调用。对应的反射API方法为Reflect.defineProperty()

const myTarget = {}; 
const proxy = new Proxy(myTarget, {
    defineProperty(target, property, descriptor) { 
        console.log('defineProperty()');
        return Reflect.defineProperty(...arguments)
    }
}); 
Object.defineProperty(proxy, 'foo', { value: 
                                     'bar'
                                    });
// defineProperty()
```

#### getOwnPropertyDescriptor()

```js
getOwnPropertyDescriptor() 捕获器会在Object.getOwnPropertyDescriptor() 中被调用。对应的反射API方法为 Reflect.getOwnPropertyDescriptor() 。

const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
    getOwnPropertyDescriptor(target, property) { console.log('getOwnPropertyDescriptor()');                                       return
      Reflect.getOwnPropertyDescriptor(...arguments)
                                               } 
});
Object.getOwnPropertyDescriptor(proxy, 'foo'); 
// getOwnPropertyDescriptor()
```

#### deleteProperty()

```js
deleteProperty() 捕获器会在 delete 操作符中被调用。对应的反射API方法为 Reflect.deleteProperty() 。

const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
    deleteProperty(target, property) {
        console.log('deleteProperty()'); 
        return Reflect.deleteProperty(...arguments)
    }
});
delete proxy.foo 
// deleteProperty()
```

#### ownKeys() 

```js
ownKeys() 捕获器会在 Object.keys() 及类似方法中被调用。对应的反射API方法为 Reflect.ownKeys()

const myTarget = {};
const proxy = new Proxy(myTarget, {
    ownKeys(target) {
        console.log('ownKeys()');
        return Reflect.ownKeys(...arguments)
    } 
});
Object.keys(proxy);
// ownKeys()
```

#### getPrototypeOf() 

```js
getPrototypeOf() 捕获器会在Object.getPrototypeOf() 中被调用。对应的反射API方法为Reflect.getPrototypeOf()

const myTarget = {};
const proxy = new Proxy(myTarget, {
    getPrototypeOf(target) {
        console.log('getPrototypeOf()');
        return Reflect.getPrototypeOf(...arguments)
    } 
});
Object.getPrototypeOf(proxy);
// getPrototypeOf()
```

#### setPrototypeOf() 

```js
setPrototypeOf() 捕获器会在Object.setPrototypeOf() 中被调用。对应的反射API方法为Reflect.setPrototypeOf() 。

const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
    setPrototypeOf(target, prototype) {
        console.log('setPrototypeOf()'); 
        return Reflect.setPrototypeOf(...arguments) 
    }
});
Object.setPrototypeOf(proxy, Object); 
// setPrototypeOf()
```

####  isExtensible()

```js
isExtensible() 捕获器会在 Object.isExtensible()中被调用。对应的反射API方法为 Reflect.isExtensible() 。

const myTarget = {};
const proxy = new Proxy(myTarget, {
    isExtensible(target) { 
        console.log('isExtensible()');
        return Reflect.isExtensible(...arguments)
    } 
});
Object.isExtensible(proxy);
// isExtensible()
```

#### preventExtensions() 

```js
preventExtensions() 捕获器会在Object.preventExtensions() 中被调用。对应的反射API方法为 Reflect.preventExtensions() 。

const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
    preventExtensions(target) {
        console.log('preventExtensions()'); 
        return Reflect.preventExtensions(...arguments)
    }
});

Object.preventExtensions(proxy);
// preventExtensions()
```

####  apply() 

```js
apply() 捕获器会在调用函数时中被调用。对应的反射API方法为 Reflect.apply() 。

const myTarget = () => {}; 
const proxy = new Proxy(myTarget, { 
    apply(target, thisArg, ...argumentsList) { 
        console.log('apply()'); 
        return Reflect.apply(...arguments) 
    }
});
proxy(); 
// apply()
```

####  construct() 

```js
construct() 捕获器会在 new 操作符中被调用。对应的反射API方法为Reflect.construct() 。

const myTarget = function() {};
const proxy = new Proxy(myTarget, {
    construct(target, argumentsList, newTarget) { 
        console.log('construct()'); 
        return Reflect.construct(...arguments) 
    }
});
new proxy; 
// construct()
```

### 3。代理模式

```js
通过捕获 get 、 set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过.

const user = { name: "Jake" };
    const proxy = new Proxy(user, {
      get(target, property, receiver) {
        console.log("Getting ${property}");
        return Reflect.get(...arguments);
      },
      set(target, property, value, receiver) {
        console.log("Setting ${property}=${value}");
        return Reflect.set(...arguments);
      },
    });
    proxy.name; // Getting name proxy.age = 27; // Setting age=27
```

#### 隐藏属性

```js
代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。

const hiddenProperties = ['foo', 'bar']; 
const targetObject = { 
    foo: 1, 
    bar: 2,
    baz: 3 
};
const proxy = new Proxy(targetObject, {
        get(target, property) { 
            if (hiddenProperties.includes(property)) { 
                return undefined; 
            } else { 
                return Reflect.get(...arguments);
            }
        },
    has(target, property) { 
        if (hiddenProperties.includes(property)) {
            return false;
        } else { 
            return Reflect.has(...arguments);
        } 
    }
    });
// get() 
console.log(proxy.foo); // undefined 
console.log(proxy.bar); // undefined 
console.log(proxy.baz); // 3 
// has() 
console.log('foo' in proxy); // false
console.log('bar' in proxy); // false
console.log('baz' in proxy); // true
```

#### 属性验证

```js
因为所有赋值操作都会触发 set() 捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：

const target = { onlyNumbersGoHere: 0 };
    const proxy = new Proxy(target, {
      set(target, property, value) {
        if (typeof value !== "Number") {
          return false;
        } else {
          return Reflect.set(...arguments);
        }
      },
    });
    proxy.onlyNumbersGoHere = 1;
    console.log(proxy.onlyNumbersGoHere); // 1
    proxy.onlyNumbersGoHere = '2';
    console.log(proxy.onlyNumbersGoHere); // 1
```

####  函数与构造函数参数验证

```js
跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值：

    function median(...nums) {
      return nums.sort()[Math.floor(nums.length / 2)];
    }
    const proxy = new Proxy(median, {
      apply(target, thisArg, ...argumentsList) {
        for (const arg of argumentsList) {
          if (typeof arg !== "number") {
            throw "Non-number argument provided";
          }
        }
        return Reflect.apply(...arguments);
      },
    });
    console.log(proxy(4, 7, 1)); // 4 
    console.log(proxy(4, '7', 1)); 
    // Error: Non-number argument provided
```

####  数据绑定与可观察对象

```js
通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的代码互操作。比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：

const userList = [];
    class User {
      constructor(name) {
        this.name_ = name;
      }
    }
    const proxy = new Proxy(User, {
      construct() {
        const newUser = Reflect.construct(...arguments);
        userList.push(newUser);
        return newUser;
      },
    });
    new proxy("John");
    new proxy("Jacob");
    new proxy("Jingleheimerschmidt");
    console.log(userList); // [User {}, User {}, User{}]
```

# 第十章·

​		函数是ECMAScript中最有意思的部分之一，这主要是因为函数实际上是对象。每个函数都是 Function 类型的实例，而 Function也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。函数通常以函数声明的方式定义，

### 1. 箭头函数

​		ECMAScript 6新增了使用胖箭头（ => ）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数

​		箭头函数没有自己的this，arguments，super或new.target。箭头函数适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。

```js
//通常函数的定义方法
var fn1 = function(a, b) {
    return a + b
}
function fn2(a, b) {
    return a + b
}
//使用ES6箭头函数语法定义函数，将原函数的“function”关键字和函数名都删掉，并使用“=>”连接参数列表和函数体。
var fn1 = (a, b) => {
    return a + b
}
(a, b) => {
    return a + b
}
```

### 2.函数名

​		因为函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个名称，如下所示：

```js
function sum(num1, num2) {
    return num1 + num2; 
}
console.log(sum(10, 10)); // 20 
let anotherSum = sum; console.log(anotherSum(10, 10)); // 20 
sum = null; console.log(anotherSum(10, 10)); // 20
```

​		以上代码定义了一个名为 sum() 的函数，用于求两个数之和。然后又声明了一个变量 anotherSum ，并将它的值设置为等于sum 。注意，使用不带括号的函数名会访问函数指针，而不会执行函数。此时， anotherSum 和 sum 都指向同一个函数。调用anotherSum() 也可以返回结果。把 sum 设置为 null 之后，就切断了它与函数之间的关联。而 anotherSum() 还是可以照常调用，没有问题。

### 3. 理解参数

​		ECMAScript函数不介意 传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数的时候也未必一定要传递两个参数。可以 传递一个，三个或是不传。

​		之所以会这样，原因是ECMAscript中的参数在内部是用一个数组来表示。函数接收到的始终是这介 数组，而不关心数组中 包含哪些参数。如果数组中不 包含任何元素，无所谓；如果包含多个元素，也没有问题。

​		在函数体内可以通过arguments对象来访问这个数组，从而获取传递给函数的每一个参数。

​		arguments对象与数组类似，可以使用方括号语法访问它的每一个元素。即第一个元素是arguments[0],第二个元素是arguments[1],以此类推。

```js
function howManyArgs() {
   alert(arguments.length);
}
howManyArgs(); //0
howManyArgs(1); //1
howManyArgs("string", 22); //2
```

```js
function doAdd() {
            if (arguments.length == 1) {
                alert(arguments[0] + 10);
            } else if (arguments.length == 2) {
                alert(arguments[0] + arguments[1]);
            }
        }
        doAdd(10); //20
        doAdd(20, 30); //50
```

等同于以下例子：

```js
function doAdd(num1, num2) {
            if (arguments.length == 1) {
                alert(num1 + 10);
            } else if (arguments.length == 2) {
                alert(arguments[0] + num2);
            }
        }
        doAdd(10); //20
        doAdd(20, 30); //50
```

### 4.没有重载

ECMAScript函数不能像传统编程那样重载。在其他语言比如Java

中，一个函数可以有两个定义，只要签名（接收参数的类型和数量）

不同就行。如前所述，ECMAScript函数没有签名，因为参数是由包含

零个或多个值的数组表示的。没有函数签名，自然也就没有重载。

如果在ECMAScript中定义了两个同名函数，则后定义的会覆盖先

定义的。来看下面的例子：

function addSomeNumber(num) { 

return num + 100; 

}function addSomeNumber(num) { 

return num + 200; 

}

let result = addSomeNumber(100); *// 300*

这里，函数 addSomeNumber() 被定义了两次。第一个版本给

参数加100，第二个版本加200。最后一行调用这个函数时，返回了

300，因为第二个定义覆盖了第一个定义。

前面也提到过，可以通过检查参数的类型和数量，然后分别执行

不同的逻辑来模拟函数重载。

把函数名当成指针也有助于理解为什么ECMAScript没有函数重

载。在前面的例子中，定义两个同名的函数显然会导致后定义的重写

先定义的。而那个例子几乎跟下面这个是一样的：

let addSomeNumber = function(num) { 

return num + 100; 

};

addSomeNumber = function(num) { 

return num + 200; 

};

let result = addSomeNumber(100); *// 300*

看这段代码应该更容易理解发生了什么。在创建第二个函数时，

变量 addSomeNumber 被重写成保存第二个函数对象了。

### 5.默认参数值 

在ECMAScript5.1及以前，实现默认参数的一种常用方式就是检测

某个参数是否等于 undefined ，如果是则意味着没有传这个参数，

那就给它赋一个值：

function makeKing(name) { 

name = (typeof name !== 'undefined') ? name : 

'Henry'; 

return `King ${name} VIII`; 

}

console.log(makeKing()); *// 'King Henry* 

*VIII'* 

console.log(makeKing('Louis')); *// 'King Louis* 

*VIII'*

ECMAScript 6之后就不用这么麻烦了，因为它支持显式定义默认

参数了。下面就是与前面代码等价的ES6写法，只要在函数定义中的

参数后面用 = 就可以为参数赋一个默认值：

function makeKing(name = 'Henry') { 

return `King ${name} VIII`; 

}

console.log(makeKing('Louis')); *// 'King Louis* 

*VIII'* 

console.log(makeKing()); *// 'King Henry* 

*VIII'*给参数传 undefined 相当于没有传值，不过这样可以利用多个

独立的默认值：

function makeKing(name = 'Henry', numerals = 

'VIII') { 

return `King ${name} ${numerals}`; 

}

console.log(makeKing()); *//* 

*'King Henry VIII'* 

console.log(makeKing('Louis')); *//* 

*'King Louis VIII'* 

console.log(makeKing(undefined, 'VI')); *//* 

*'King Henry VI'*

在使用默认参数时， arguments 对象的值不反映参数的默认

值，只反映传给函数的参数。当然，跟ES5严格模式一样，修改命名

参数也不会影响 arguments 对象，它始终以调用函数时传入的值为

准：

function makeKing(name = 'Henry') { 

name = 'Louis'; 

return `King ${arguments[0]}`; 

}

console.log(makeKing()); *// 'King* 

*undefined'* 

console.log(makeKing('Louis')); *// 'King Louis'*默认参数值并不限于原始值或对象类型，也可以使用调用函数返

回的值：

let romanNumerals = ['I', 'II', 'III', 'IV', 

'V', 'VI']; 

let ordinality = 0; 

function getNumerals() { 

*//* *每次调用后递增*

return romanNumerals[ordinality++]; 

}

function makeKing(name = 'Henry', numerals = 

getNumerals()) { 

return `King ${name} ${numerals}`; 

}

console.log(makeKing()); *// 'King* 

*Henry I'* 

console.log(makeKing('Louis', 'XVI')); *// 'King* 

*Louis XVI'* 

console.log(makeKing()); *// 'King* 

*Henry II'* 

console.log(makeKing()); *// 'King* 

*Henry III'*

函数的默认参数只有在函数被调用时才会求值，不会在函数定义

时求值。而且，计算默认值的函数只有在调用函数但未传相应参数时

才会被调用。箭头函数同样也可以这样使用默认参数，只不过在只有一个参数

时，就必须使用括号而不能省略了：

let makeKing = (name = 'Henry') => `King 

${name}`; 

console.log(makeKing()); *// King Henry* 

默认参数作用域与暂时性死区

因为在求值默认参数时可以定义对象，也可以动态调用函数，所

以函数参数肯定是在某个作用域中求值的。

给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量

一样。来看下面的例子：

function makeKing(name = 'Henry', numerals = 

'VIII') { 

return `King ${name} ${numerals}`; 

}

console.log(makeKing()); *// King Henry VIII*

这里的默认参数会按照定义它们的顺序依次被初始化。可以依照

如下示例想象一下这个过程：

function makeKing() { 

let name = 'Henry'; 

let numerals = 'VIII';return `King ${name} ${numerals}`; 

}

因为参数是按顺序初始化的，所以后定义默认值的参数可以引用

先定义的参数。看下面这个例子：

function makeKing(name = 'Henry', numerals = 

name) { 

return `King ${name} ${numerals}`; 

}

console.log(makeKing()); *// King Henry Henry*

参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能

引用后面定义的。像这样就会抛出错误：

*//* *报错*

function makeKing(name = numerals, numerals = 

'VIII') { 

return `King ${name} ${numerals}`; 

}

参数也存在于自己的作用域中，它们不能引用函数体的作用域：

*//* *报错*

function makeKing(name = 'Henry', numerals = 

defaultNumeral) { 

let defaultNumeral = 'VIII';return `King ${name} ${numerals}`; 

}

### 6.参数扩展与收集

ECMAScript 6新增了扩展操作符，使用它可以非常简洁地操作和

组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列

表，在这里它可以充分利用这门语言的弱类型及参数长度可变的特

点。扩展操作符既可以用于调用函数时传参，也可以用于定义函数参

数。

**10.6.1** 扩展参数

在给函数传参时，有时候可能不需要传一个数组，而是要分别传

入数组的元素。

假设有如下函数定义，它会将所有传入的参数累加起来：

let values = [1, 2, 3, 4]; 

function getSum() { 

let sum = 0; 

for (let i = 0; i < arguments.length; ++i) { 

sum += arguments[i]; 

}

return sum; 

}

这个函数希望将所有加数逐个传进来，然后通过迭代

arguments 对象来实现累加。如果不使用扩展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于 apply() 方法：

console.log(getSum.apply(null, values)); *// 10*

但在ECMAScript 6中，可以通过扩展操作符极为简洁地实现这种

操作。对可迭代对象应用扩展操作符，并将其作为一个参数传入，可

以将可迭代对象拆分，并将迭代返回的每个值单独传入。

比如，使用扩展操作符可以将前面例子中的数组像这样直接传给

函数：

console.log(getSum(...values)); *// 10*

因为数组的长度已知，所以在使用扩展操作符传参的时候，并不

妨碍在其前面或后面再传其他的值，包括使用扩展操作符传其他参

数：

console.log(getSum(-1, ...values)); *//* 

*9*

console.log(getSum(...values, 5)); *//* 

*15*

console.log(getSum(-1, ...values, 5)); *//* 

*14*

console.log(getSum(...values, ...[5,6,7])); *//* 

*28*

对函数中的 arguments 对象而言，它并不知道扩展操作符的存

在，而是按照调用函数时传入的参数接收每一个值：let values = [1,2,3,4] 

function countArguments() { 

console.log(arguments.length); 

}

countArguments(-1, ...values); *// 5* 

countArguments(...values, 5); *// 5* 

countArguments(-1, ...values, 5); *// 6* 

countArguments(...values, ...[5,6,7]); *// 7* 

arguments 对象只是消费扩展操作符的一种方式。在普通函数

和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以

使用默认参数：

function getProduct(a, b, c = 1) { 

return a * b * c; 

}

let getSum = (a, b, c = 0) => { 

return a + b + c; 

}

console.log(getProduct(...[1,2])); *// 2* 

console.log(getProduct(...[1,2,3])); *// 6* 

console.log(getProduct(...[1,2,3,4])); *// 6* 

console.log(getSum(...[0,1])); *// 1*console.log(getSum(...[0,1,2])); *// 3* 

console.log(getSum(...[0,1,2,3])); *// 3* 

**10.6.2** 收集参数

在构思函数定义时，可以使用扩展操作符把不同长度的独立参数

组合为一个数组。这有点类似 arguments 对象的构造机制，只不过

收集参数的结果会得到一个 Array 实例。

function getSum(...values) { 

*//* *顺序累加**values**中的所有值* 

*//* *初始值的总和为**0* 

return values.reduce((x, y) => x + y, 0); 

}

console.log(getSum(1,2,3)); *// 6*

收集参数的前面如果还有命名参数，则只会收集其余的参数；如

果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作

为最后一个参数：

*//* *不可以*

function getProduct(...values, lastValue) {} 

*//* *可以*

function ignoreFirst(firstValue, ...values) { 

console.log(values); 

}ignoreFirst(); *// []* 

ignoreFirst(1); *// []* 

ignoreFirst(1,2); *// [2]* 

ignoreFirst(1,2,3); *// [2, 3]*

箭头函数虽然不支持 arguments 对象，但支持收集参数的定义

方式，因此也可以实现与使用 arguments 一样的逻辑：

let getSum = (...values) => { 

return values.reduce((x, y) => x + y, 0); 

}

console.log(getSum(1,2,3)); *// 6*

另外，使用收集参数并不影响 arguments 对象，它仍然反映调

用时传给函数的参数：

function getSum(...values) { 

console.log(arguments.length); *// 3* 

console.log(arguments); *// [1, 2, 3]* 

console.log(values); *// [1, 2, 3]* 

}

console.log(getSum(1,2,3)); 

### 7.函数声明与函数表达式

本章到现在一直没有把函数声明和函数表达式区分得很清楚。事

实上，JavaScript引擎在加载数据时对它们是区别对待的。JavaScript引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成

函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行

上下文中生成函数定义。来看下面的例子：

*//* *没问题*

console.log(sum(10, 10)); 

function sum(num1, num2) { 

return num1 + num2; 

}

以上代码可以正常运行，因为函数声明会在任何代码执行之前先

被读取并添加到执行上下文。这个过程叫作函数声明提升（function

declaration hoisting）。在执行代码时，JavaScript引擎会先执行一遍扫

描，把发现的函数声明提升到源代码树的顶部。因此即使函数定义出

现在调用它们的代码之后，引擎也会把函数声明提升到顶部。如果把

前面代码中的函数声明改为等价的函数表达式，那么执行的时候就会

出错：

*//* *会出错*

console.log(sum(10, 10)); 

let sum = function(num1, num2) { 

return num1 + num2; 

};

上面的代码之所以会出错，是因为这个函数定义包含在一个变量

初始化语句中，而不是函数声明中。这意味着代码如果没有执行到加

粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码

会出错。这并不是因为使用 let 而导致的，使用 var 关键字也会碰

到同样的问题：console.log(sum(10, 10)); 

var sum = function(num1, num2) { 

return num1 + num2; 

};

除了函数什么时候真正有定义这个区别之外，这两种语法是等价

的。

注意 在使用函数表达式初始化变量时，也可以给函数一个名称，

比如 let sum = function sum() {} 。这一点在10.11节讨论

函数表达式时会再讨论。

### 8.函数作为值

因为函数名在ECMAScript中就是变量，所以函数可以用在任何可

以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函

数，而且还可以在一个函数中返回另一个函数。来看下面的例子：

function callSomeFunction(someFunction, 

someArgument) { 

return someFunction(someArgument); 

}

这个函数接收两个参数。第一个参数应该是一个函数，第二个参

数应该是要传给这个函数的值。任何函数都可以像下面这样作为参数

传递：

function add10(num) { 

return num + 10;}

let result1 = callSomeFunction(add10, 10); 

console.log(result1); *// 20* 

function getGreeting(name) { 

return "Hello, " + name; 

}

let result2 = callSomeFunction(getGreeting, 

"Nicholas"); 

console.log(result2); *// "Hello, Nicholas"* 

callSomeFunction() 函数是通用的，第一个参数传入的是

什么函数都可以，而且它始终返回调用作为第一个参数传入的函数的

结果。要注意的是，如果是访问函数而不是调用函数，那就必须不带

括号，所以传给 callSomeFunction() 的必须是 add10 和 

getGreeting ，而不能是它们的执行结果。

从一个函数中返回另一个函数也是可以的，而且非常有用。例

如，假设有一个包含对象的数组，而我们想按照任意对象属性对数组

进行排序。为此，可以定义一个 sort() 方法需要的比较函数，它接

收两个参数，即要比较的值。但这个比较函数还需要想办法确定根据

哪个属性来排序。这个问题可以通过定义一个根据属性名来创建比较

函数的函数来解决。比如：

function createComparisonFunction(propertyName) 

{ 

return function(object1, object2) {let value1 = object1[propertyName]; 

let value2 = object2[propertyName]; 

if (value1 < value2) { 

return -1; 

} else if (value1 > value2) { 

return 1; 

} else { 

return 0; 

} 

}; 

}

这个函数的语法乍一看比较复杂，但实际上就是在一个函数中返

回另一个函数，注意那个 return 操作符。内部函数可以访问

propertyName 参数，并通过中括号语法取得要比较的对象的相应

属性值。取得属性值以后，再按照 sort() 方法的需要返回比较值就

行了。这个函数可以像下面这样使用：

let data = [ 

{name: "Zachary", age: 28}, 

{name: "Nicholas", age: 29} 

];

data.sort(createComparisonFunction("name")); 

console.log(data[0].name); *// Nicholas* 

data.sort(createComparisonFunction("age")); 

console.log(data[0].name); *// Zachary*在上面的代码中，数组 data 中包含两个结构相同的对象。每个

对象都有一个 name 属性和一个 age 属性。默认情况下， sort()

方法要对这两个对象执行 toString() ，然后再决定它们的顺序，

但这样得不到有意义的结果。而通过调用

createComparisonFunction("name") 来创建一个比较函数，

就可以根据每个对象 name 属性的值来排序，结果 name 属性值

为 "Nicholas" 、 age 属性值为 29 的对象会排在前面。而调用

createComparisonFunction("age") 则会创建一个根据每个对

象 age 属性的值来排序的比较函数，结果 name 属性值

为 "Zachary" 、 age 属性值为 28 的对象会排在前面。

### 9.函数内部 

在ECMAScript 5中，函数内部存在两个特殊的对象：

arguments 和 this 。ECMAScript 6又新增了 new.target 属

性。

**10.9.1** arguments 

arguments 对象前面讨论过多次了，它是一个类数组对象，包

含调用函数时传入的所有参数。这个对象只有以 function 关键字

定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于

包含函数参数，但 arguments 对象其实还有一个 callee 属性，

是一个指向 arguments 对象所在函数的指针。来看下面这个经典的

阶乘函数：

function factorial(num) { 

if (num <= 1) { 

return 1;} else { 

return num * factorial(num - 1); 

} 

}

阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要

给函数一个名称，而且这个名称不会变，这样定义就没有问题。但

是，这个函数要正确执行就必须保证函数名是 factorial ，从而导

致了紧密耦合。使用 arguments.callee 就可以让函数逻辑与函数

名解耦：

function factorial(num) { 

if (num <= 1) { 

return 1; 

} else { 

return num * arguments.callee(num - 1); 

} 

}

这个重写之后的 factorial() 函数已经用

arguments.callee 代替了之前硬编码的 factorial 。这意味

着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：

let trueFactorial = factorial; 

factorial = function() { 

return 0; 

};console.log(trueFactorial(5)); *// 120* 

console.log(factorial(5)); *// 0*

这里， trueFactorial 变量被赋值为 factorial ，实际上

把同一个函数的指针又保存到了另一个位置。然后， factorial 函

数又被重写为一个返回 0 的函数。如果像 factorial() 最初的版

本那样不使用 arguments.callee ，那么像上面这样调用

trueFactorial() 就会返回 0 。不过，通过将函数与名称解

耦， trueFactorial() 就可以正确计算阶乘，而 factorial()

则只能返回0。 

**10.9.2** this

另一个特殊的对象是 this ，它在标准函数和箭头函数中有不同

的行为。

在标准函数中， this 引用的是把函数当成方法调用的上下文对

象，这时候通常称其为 this 值（在网页的全局上下文中调用函数

时， this 指向 windows ）。来看下面的例子：

window.color = 'red'; 

let o = { 

color: 'blue' 

};

function sayColor() { 

console.log(this.color); 

}

sayColor(); *// 'red'*o.sayColor = sayColor; 

o.sayColor(); *// 'blue'*

定义在全局上下文中的函数 sayColor() 引用了 this 对象。

这个 this 到底引用哪个对象必须到函数被调用时才能确定。因此这

个值在代码执行的过程中可能会变。如果在全局上下文中调用

sayColor() ，这结果会输出 "red" ，因为 this 指向

window ，而 this.color 相当于 window.color 。而在把

sayColor() 赋值给 o 之后再调用 o.sayColor() ， this 会指

向 o ，即 this.color 相当于 o.color ，所以会显

示 "blue" 。

在箭头函数中， this 引用的是定义箭头函数的上下文。下面的

例子演示了这一点。在对 sayColor() 的两次调用中， this 引用

的都是 window 对象，因为这个箭头函数是在 window 上下文中定

义的：

window.color = 'red'; 

let o = { 

color: 'blue' 

};

let sayColor = () => console.log(this.color); 

sayColor(); *// 'red'* 

o.sayColor = sayColor; 

o.sayColor(); *// 'red'*有读者知道，在事件回调或定时回调中调用某个函数时， this

值指向的并非想要的对象。此时将回调函数写成箭头函数就可以解决

问题。这是因为箭头函数中的 this 会保留定义该函数时的上下文：

function King() { 

this.royaltyName = 'Henry'; 

*// this**引用**King**的实例*

setTimeout(() => 

console.log(this.royaltyName), 1000); 

}

function Queen() { 

this.royaltyName = 'Elizabeth'; 

*// this**引用**window**对象*

setTimeout(function() { 

console.log(this.royaltyName); }, 1000); 

}

new King(); *// Henry* 

new Queen(); *// undefined*

注意 函数名只是保存指针的变量。因此全局定义的

sayColor() 函数和 o.sayColor() 是同一个函数，只不过执

行的上下文不同。

**10.9.3** callerECMAScript 5也会给函数对象上添加一个属性： caller 。虽然

ECMAScript 3中并没有定义，但所有浏览器除了早期版本的Opera都支

持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在

全局作用域中调用的则为 null 。比如：

function outer() { 

inner(); 

}

function inner() { 

console.log(inner.caller); 

}

outer();

以上代码会显示 outer() 函数的源代码。这是因为

ourter() 调用了 inner() ， inner.caller 指向

outer() 。如果要降低耦合度，则可以通过

arguments.callee.caller 来引用同样的值：

function outer() { 

inner(); 

}

function inner() { 

console.log(arguments.callee.caller); 

}

outer();在严格模式下访问 arguments.callee 会报错。ECMAScript 5

也定义了 arguments.caller ，但在严格模式下访问它会报错，在

非严格模式下则始终是 undefined 。这是为了分清

arguments.caller 和函数的 caller 而故意为之的。而作为对

这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文

中运行的其他代码。

严格模式下还有一个限制，就是不能给函数的 caller 属性赋

值，否则会导致错误。

**10.9.4** new.target

ECMAScript中的函数始终可以作为构造函数实例化一个新对象，

也可以作为普通函数被调用。ECMAScript 6新增了检测函数是否使用

new 关键字调用的 new.target 属性。如果函数是正常调用的，

则 new.target 的值是 undefined ；如果是使用 new 关键字调

用的，则 new.target 将引用被调用的构造函数。

function King() { 

if (!new.target) { 

throw 'King must be instantiated using

"new"' 

}

console.log('King instantiated using "new"'); 

}

new King(); *// King instantiated using "new"*

King(); *// Error: King must be instantiated*

*using "new"*

### 10,函数属性与方法

前面提到过，ECMAScript中的函数是对象，因此有属性和方法。

每个函数都有两个属性： length 和 prototype 。其中，

length 属性保存函数定义的命名参数的个数，如下例所示：

function sayName(name) { 

console.log(name); 

}

function sum(num1, num2) { 

return num1 + num2; 

}

function sayHi() { 

console.log("hi"); 

}

console.log(sayName.length); *// 1* 

console.log(sum.length); *// 2* 

console.log(sayHi.length); *// 0*

以上代码定义了3个函数，每个函数的命名参数个数都不一样。

sayName() 函数有1个命名参数，所以其 length 属性为1。类似

地， sum() 函数有两个命名参数，所以其 length 属性是2。而

sayHi() 没有命名参数，其 length 属性为0。 

prototype 属性也许是ECMAScript核心中最有趣的部分。

prototype 是保存引用类型所有实例方法的地方，这意味着

toString() 、 valueOf() 等方法实际上都保存在 prototype上，进而由所有实例共享。这个属性在自定义类型时特别重要。（相

关内容已经在第8章详细介绍过了。）在ECMAScript 5中，

prototype 属性是不可枚举的，因此使用 for-in 循环不会返回

这个属性。

函数还有两个方法： apply() 和 call() 。这两个方法都会以

指定的 this 值来调用函数，即会设置调用函数时函数体内 this 对

象的值。 apply() 方法接收两个参数：函数内 this 的值和一个参

数数组。第二个参数可以是 Array 的实例，但也可以是

arguments 对象。来看下面的例子：

```js
function sum(num1, num2) { 

return num1 + num2; 

}

function callSum1(num1, num2) { 

return sum.apply(this, arguments); *//* *传入*

*arguments**对象*

}

function callSum2(num1, num2) { 

return sum.apply(this, [num1, num2]); *//* 传入数组

}

console.log(callSum1(10, 10)); *// 20* 

console.log(callSum2(10, 10)); *// 20
```

在这个例子中， callSum1() 会调用 sum() 函数，将 this

作为函数体内的 this 值（这里等于 window ，因为是在全局作用

域中调用的）传入，同时还传入了 arguments 对象。

callSum2() 也会调用 sum() 函数，但会传入参数的数组。这两

个函数都会执行并返回正确的结果。

注意 在严格模式下，调用函数时如果没有指定上下文对象，则

this 值不会指向 window 。除非使用 apply() 或 call() 把

函数指定给一个对象，否则 this 的值会变成 undefined 。 

call() 方法与 apply() 的作用一样，只是传参的形式不同。

第一个参数跟 apply() 一样，也是 this 值，而剩下的要传给被调

用函数的参数则是逐个传递的。换句话说，通过 call() 向函数传参

时，必须将参数一个一个地列出来，比如：

function sum(num1, num2) { 

return num1 + num2; 

}

function callSum(num1, num2) { 

return sum.call(this, num1, num2); 

}

console.log(callSum(10, 10)); *// 20*

这里的 callSum() 函数必须逐个地把参数传给 call() 方

法。结果跟 apply() 的例子一样。到底是使用 apply() 还是

call() ，完全取决于怎么给要调用的函数传参更方便。如果想直接

传 arguments 对象或者一个数组，那就用 apply() ；否则，就用 call() 。当然，如果不用给被调用的函数传参，则使用哪个方法

都一样。

apply() 和 call() 真正强大的地方并不是给函数传参，而是

控制函数调用上下文即函数体内 this 值的能力。考虑下面的例子：

window.color = 'red'; 

let o = { 

color: 'blue' 

};

function sayColor() { 

console.log(this.color); 

}

sayColor(); *// red* 

sayColor.call(this); *// red* 

sayColor.call(window); *// red* 

sayColor.call(o); *// blue*

这个例子是在之前那个关于 this 对象的例子基础上修改而成

的。同样， sayColor() 是一个全局函数，如果在全局作用域中调

用它，那么会显示 "red" 。这是因为 this.color 会求值为

window.color 。如果在全局作用域中显式调用

sayColor.call(this) 或者 sayColor.call(window) ，则

同样都会显示 "red" 。而在使用 sayColor.call(o) 把函数的执

行上下文即 this 切换为对象 o 之后，结果就变成了显

示 "blue" 了。使用 call() 或 apply() 的好处是可以将任意对象设置为任意

函数的作用域，这样对象可以不用关心方法。在前面例子最初的版本

中，为切换上下文需要先把 sayColor() 直接赋值为 o 的属性，然

后再调用。而在这个修改后的版本中，就不需要这一步操作了。

ECMAScript 5出于同样的目的定义了一个新方法： bind() 。 

bind() 方法会创建一个新的函数实例，其 this 值会被绑定到传

给 bind() 的对象。比如：

window.color = 'red'; 

var o = { 

color: 'blue' 

};

function sayColor() { 

console.log(this.color); 

}

let objectSayColor = sayColor.bind(o); 

objectSayColor(); *// blue*

这里，在 sayColor() 上调用 bind() 并传入对象 o 创建了

一个新函数 objectSayColor() 。 objectSayColor() 中的

this 值被设置为 o ，因此直接调用这个函数，即使是在全局作用

域中调用，也会返回字符串 "blue" 。

对函数而言，继承的方法 toLocaleString() 和 

toString() 始终返回函数的代码。返回代码的具体格式因浏览器

而异。有的返回源代码，包含注释，而有的只返回代码的内部形式，

会删除注释，甚至代码可能被解释器修改过。由于这些差异，因此不能在重要功能中依赖这些方法返回的值，而只应在调试中使用它们。

继承的方法 valueOf() 返回函数本身。

### 11.函数表达式

函数表达式虽然更强大，但也更容易让人迷惑。我们知道，定义

函数有两种方式：函数声明和函数表达式。函数声明是这样的：

function functionName(arg0, arg1, arg2) { 

*//* *函数体*

}

函数声明的关键特点是函数声明提升，即函数声明会在代码执行

之前获得定义。这意味着函数声明可以出现在调用它的代码之后：

sayHi(); 

function sayHi() { 

console.log("Hi!"); 

}

这个例子不会抛出错误，因为JavaScript引擎会先读取函数声明，

然后再执行代码。

第二种创建函数的方式就是函数表达式。函数表达式有几种不同

的形式，最常见的是这样的：

let functionName = function(arg0, arg1, arg2) { 

*//* *函数体*

};函数表达式看起来就像一个普通的变量定义和赋值，即创建一个

函数再把它赋值给一个变量 functionName 。这样创建的函数叫作

匿名函数（anonymous funtion），因为 function 关键字后面没有标

识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变

量的匿名函数的 name 属性是空字符串。

函数表达式跟JavaScript中的其他表达式一样，需要先赋值再使

用。下面的例子会导致错误：

sayHi(); *// Error! function doesn't exist yet*

let sayHi = function() { 

console.log("Hi!"); 

};

理解函数声明与函数表达式之间的区别，关键是理解提升。比

如，以下代码的执行结果可能会出乎意料：

*//* *千万别这样做！*

if (condition) { 

function sayHi() { 

console.log('Hi!'); 

} 

} else { 

function sayHi() { 

console.log('Yo!'); 

} 

}

这段代码看起来很正常，就是如果 condition 为 true ，则使

用第一个 sayHi() 定义；否则，就使用第二个。事实上，这种写法在ECAMScript中不是有效的语法。JavaScript引擎会尝试将其纠正为适

当的声明。问题在于浏览器纠正这个问题的方式并不一致。多数浏览

器会忽略 condition 直接返回第二个声明。Firefox会在

condition 为 true 时返回第一个声明。这种写法很危险，不要使

用。不过，如果把上面的函数声明换成函数表达式就没问题了：

*//* *没问题*

let sayHi; 

if (condition) { 

sayHi = function() { 

console.log("Hi!"); 

}; 

} else { 

sayHi = function() { 

console.log("Yo!"); 

}; 

}

这个例子可以如预期一样，根据 condition 的值为变量

sayHi 赋予相应的函数。

创建函数并赋值给变量的能力也可以用于在一个函数中把另一个

函数当作值返回：

function createComparisonFunction(propertyName) 

{ 

return function(object1, object2) { 

let value1 = object1[propertyName]; 

let value2 = object2[propertyName];if (value1 < value2) { 

return -1; 

} else if (value1 > value2) { 

return 1; 

} else { 

return 0; 

} 

}; 

}

这里的 createComparisonFunction() 函数返回一个匿名函

数，这个匿名函数要么被赋值给一个变量，要么可以直接调用。但在

createComparisonFunction() 内部，那个函数是匿名的。任何

时候，只要函数被当作值来使用，它就是一个函数表达式。本章后面

会介绍，这并不是使用函数表达式的唯一方式。

### 12.递归

递归函数通常的形式是一个函数通过名称调用自己，如下面的例

子所示：

function factorial(num) { 

if (num <= 1) { 

return 1; 

} else { 

return num * factorial(num - 1); 

} 

}这是经典的递归阶乘函数。虽然这样写是可以的，但如果把这个

函数赋值给其他变量，就会出问题：

let anotherFactorial = factorial; 

factorial = null; 

console.log(anotherFactorial(4)); *//* *报错*

这里把 factorial() 函数保存在了另一个变量

anotherFactorial 中，然后将 factorial 设置为 null ，于

是只保留了一个对原始函数的引用。而在调用

anotherFactorial() 时，要递归调用 factorial() ，但因为

它已经不是函数了，所以会出错。在写递归函数时使用

arguments.callee 可以避免这个问题。

arguments.callee 就是一个指向正在执行的函数的指针，因

此可以在函数内部递归调用，如下所示：

function factorial(num) { 

if (num <= 1) { 

return 1; 

} else { 

return num * arguments.callee(num - 1); 

} 

}

像这里加粗的这一行一样，把函数名称替换成

arguments.callee ，可以确保无论通过什么变量调用这个函数都

不会出问题。因此在编写递归函数时， arguments.callee 是引用

当前函数的首选。不过，在严格模式下运行的代码是不能访问

arguments.callee 的，因为访问会出错。此时，可以使用命名函

数表达式（named function expression）达到目的。比如：

const factorial = (function f(num) { 

if (num <= 1) { 

return 1; 

} else { 

return num * f(num - 1); 

} 

});

这里创建了一个命名函数表达式 f() ，然后将它赋值给了变量

factorial 。即使把函数赋值给另一个变量，函数表达式的名称

f 也不变，因此递归调用不会有问题。这个模式在严格模式和非严格

模式下都可以使用。

### 13.尾调用优化

ECMAScript 6规范新增了一项内存管理优化机制，让JavaScript引

擎在满足条件时可以重用栈帧。具体来说，这项优化非常适合“尾调

用”，即外部函数的返回值是一个内部函数的返回值。比如：

function outerFunction() { 

return innerFunction(); *//* *尾调用*

} 

在ES6优化之前，执行这个例子会在内存中发生如下操作。

(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。(2) 执行 outerFunction 函数体，到 return 语句。计算返回

值必须先计算 innerFunction 。

(3) 执行到 innerFunction 函数体，第二个栈帧被推到栈上。

(4) 执行 innerFunction 函数体，计算其返回值。

(5) 将返回值传回 outerFunction ，然后 outerFunction

再返回值。

(6) 将栈帧弹出栈外。

在ES6优化之后，执行这个例子会在内存中发生如下操作。

(1) 执行到 outerFunction 函数体，第一个栈帧被推到栈上。

(2) 执行 outerFunction 函数体，到达 return 语句。为求值

返回语句，必须先求值 innerFunction 。

(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为

innerFunction 的返回值也是 outerFunction 的返回值。

(4) 弹出 outerFunction 的栈帧。

(5) 执行到 innerFunction 函数体，栈帧被推到栈上。

(6) 执行 innerFunction 函数体，计算其返回值。

(7) 将 innerFunction 的栈帧弹出栈外。

很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个

栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。

这就是ES6尾调用优化的关键：如果函数的逻辑允许基于尾调用将其

销毁，则引擎就会那么做。

注意 现在还没有办法测试尾调用优化是否起作用。不过，因为这

是ES6规范所规定的，兼容的浏览器实现都能保证在代码满足条件

的情况下应用这个优化。

**10.13.1** 尾调用优化的条件尾调用优化的条件就是确定外部栈帧真的没有必要存在了。涉及

的条件如下：

代码在严格模式下执行；

外部函数的返回值是对尾调用函数的调用；

尾调用函数返回后不需要执行额外的逻辑；

尾调用函数不是引用外部函数作用域中自由变量的闭包。

下面展示了几个违反上述条件的函数，因此都不符号尾调用优化

的要求：

"use strict"; 

*//* *无优化：尾调用没有返回*

function outerFunction() { 

innerFunction(); 

}

*//* *无优化：尾调用没有直接返回* 

function outerFunction() { 

let innerFunctionResult = innerFunction(); 

return innerFunctionResult; 

}

*//* *无优化：尾调用返回后必须转型为字符串*

function outerFunction() { 

return innerFunction().toString(); 

}*//* *无优化：尾调用是一个闭包*

function outerFunction() { 

let foo = 'bar'; 

function innerFunction() { return foo; } 

return innerFunction(); 

}

下面是几个符合尾调用优化条件的例子：

"use strict"; 

*//* *有优化：栈帧销毁前执行参数计算*

function outerFunction(a, b) { 

return innerFunction(a + b); 

}

*//* *有优化：初始返回值不涉及栈帧*

function outerFunction(a, b) { 

if (a < b) { 

return a; 

}

return innerFunction(a + b); 

}

*//* *有优化：两个内部函数都在尾部*

function outerFunction(condition) { 

return condition ? innerFunctionA() :innerFunctionB(); 

}

差异化尾调用和递归尾调用是容易让人混淆的地方。无论是递归

尾调用还是非递归尾调用，都可以应用优化。引擎并不区分尾调用中

调用的是函数自身还是其他函数。不过，这个优化在递归场景下的效

果是最明显的，因为递归代码最容易在栈内存中迅速产生大量栈帧。

注意 之所以要求严格模式，主要因为在非严格模式下函数调用中

允许使用 f.arguments 和 f.caller ，而它们都会引用外部函

数的栈帧。显然，这意味着不能应用优化了。因此尾调用优化要求

必须在严格模式下有效，以防止引用这些属性。

**10.13.2** 尾调用优化的代码

可以通过把简单的递归函数转换为待优化的代码来加深对尾调用

优化的理解。下面是一个通过递归计算斐波纳契数列的函数：

function fib(n) { 

if (n < 2) { 

return n; 

}

return fib(n - 1) + fib(n - 2); 

}

console.log(fib(0)); *// 0* 

console.log(fib(1)); *// 1* 

console.log(fib(2)); *// 1*console.log(fib(3)); *// 2* 

console.log(fib(4)); *// 3* 

console.log(fib(5)); *// 5* 

console.log(fib(6)); *// 8*

显然这个函数不符合尾调用优化的条件，因为返回语句中有一个

相加的操作。结果， fib(n) 的栈帧数的内存复杂度是。因此，即使

这么一个简单的调用也可以给浏览器带来麻烦：

fib(1000);

当然，解决这个问题也有不同的策略，比如把递归改写成迭代循

环形式。不过，也可以保持递归实现，但将其重构为满足优化条件的

形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部

函数执行递归：

"use strict"; 

*//* *基础框架*

function fib(n) { 

return fibImpl(0, 1, n); 

}

*//* *执行递归*

function fibImpl(a, b, n) { 

if (n === 0) { 

return a; 

}return fibImpl(b, a + b, n - 1); 

}

这样重构之后，就可以满足尾调用优化的所有条件，再调用

fib(1000) 就不会对浏览器造成威胁了。

### 14 .闭包

匿名函数经常被人误认为是闭包（closure）。闭包指的是那些引

用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。

比如，下面是之前展示的 createComparisonFunction() 函数，

注意其中加粗的代码：

function createComparisonFunction(propertyName) 

{ 

return function(object1, object2) { 

let value1 = object1[propertyName]; 

let value2 = object2[propertyName]; 

if (value1 < value2) { 

return -1; 

} else if (value1 > value2) { 

return 1; 

} else { 

return 0; 

} 

}; 

}这里加粗的代码位于内部函数（匿名函数）中，其中引用了外部

函数的变量 propertyName 。在这个内部函数被返回并在其他地方

被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包

含 createComparisonFunction() 函数的作用域。要理解为什么

会这样，可以想想第一次调用这个函数时会发生什么。

本书在第4章曾介绍过作用域链的概念。理解作用域链创建和使用

的细节对理解闭包非常重要。在调用一个函数时，会为这个函数调用

创建一个执行上下文，并创建一个作用域链。然后用 arguments 和

其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是

内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所

有包含函数的活动对象，直到全局执行上下文才终止。

在函数执行时，要从作用域链中查找变量，以便读、写值。来看

下面的代码：

function compare(value1, value2) { 

if (value1 < value2) { 

return -1; 

} else if (value1 > value2) { 

return 1; 

} else { 

return 0; 

} 

}

let result = compare(5, 10);

这里定义的 compare() 函数是在全局上下文中调用的。第一次

调用 compare() 时，会为它创建一个包含 arguments 、value1 和 value2 的活动对象，这个对象是其作用域链上的第一

个对象。而全局上下文的变量对象则是 compare() 作用域链上的第

二个对象，其中包含 this 、 result 和 compare 。
