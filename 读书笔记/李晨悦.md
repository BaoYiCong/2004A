# 第一章 

# 什么是JavaScript；第二章HTML中的JavaScript；第三章语言基础

## 1、完整的JavaScript实现包含哪几个部分？
核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）
	   1、文档对象模型（DOM）：一个应用编程接口（API），用在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层节点。HTML或XML页面的每个组成部分都是一种节点，包含不同的数据。
		2、浏览器对象模型（BOM） API，用于支持访问和操作浏览器的窗口。

## 2、script 元素
1、async：表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，只对外部脚本文件有效。
2、charset ：可选。使用 src 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。
3、crossorigin ：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。
4、src ：可选。表示包含要执行的代码的外部文件。
5、type ：可选。代替 language ，表示代码块中脚本语言的内容类型（也称MIME类型）。
## 3、推迟的脚本
 script 元素定义了一个叫 defer 的属性。这个属性表示脚本在执行的时候不会改变页面的结构。因此，这个脚本完全可以在整个页面解析完之后再运行。在 script>元素上设置defer 属性，会告诉浏览器应该立即开始下载，但执行应该推迟。
## 4、异步执行脚本
  async 属性从改变脚本处理方式上看defer 类似，两者只适用于外部脚本，会告诉浏览器立即开始下载；不过，与 defer不同的是，标记为 async 的脚本并不保证能按照它们出现的次序执行。
## 5、动态加载脚本
通过向DOM中动态添加 script元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到DOM即可。
## 6、行内代码与外部文件
推荐使用外部文件，理由：
1、可维护性，用一个目录保存所有JavaScript文件更容易维护。
2、缓存，浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。
3、适应未来。通过把JavaScript放到外部文件中，就不必考虑用XHTML或前面提到的注释黑科技。包含外部JavaScript文件的语法在HTML和XHTML中是一样的。
## 7、文档模式
概念：即可以使用 doctype 切换文档模式。
混杂模式、标准模式、准标准模式：
主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）；
混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关；
准标准模式通过过渡性文档类型和框架集文档类型来触发。
## 8、区分大小写
 typeof 不能作为函数名，因为它是一个关键字；但 Typeof 是一个完全有效的函数名。
## 9、标识符
标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：
第一个字符必须是一个字母、下划线（ _ ）或$ ；剩下的其他字符可以是字母、下划线、美元符号或数字。
## 10.严格模式
1、ECMAScript 5增加了严格模式（strict mode）的概念。严格模式是一种不同的JavaScript解析和执行模型，ECMAScript 3的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行："use strict";
2、虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持JavaScrip引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏ECMAScript 3语法。
3、也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可。
## 11、变量
var 声明作用域：，使用 var 操作符定义的变量会成为包含它的函数的局部变量。
## 12、var 声明提升
使用这个关键字声明的变量会自动提升到函数作用域顶部；也就是把所有变量声明都拉到函数作用域的顶部；此外，反复多次使用 var 声明同一个变量也没有问题。
## 13、let 声明
let 跟 var 的作用差不多，但有着非常重要的区别。最明显的区别是， let 声明的范围是块作用域，而var 声明的范围是函数作用域。
## 14、 暂时性死区
let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升。
## 15、 全局声明
与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（ var 声明的变量则会）。
为了避免 SyntaxError ，必须确保页面不会重复声明同一个变量。
## 16、条件声明
在使用 var 声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。
使用 try / catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。
## 17、for 循环中的 let 声明
在 let 出现之前， for 循环定义的迭代变量会渗透到循环体外部。
改成使用 let 之后，这个问题就消失了，因为迭代变量的作用域仅限于 for 循环块内部。
## 18、const和let的区别
1、const 声明 const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。
2、const 声明的限制只适用于它指向的变量的引用。如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。
## 19、数据类型
ECMAScript有6种简单数据类型（也称为原始类型）：
Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。 Symbol （符号）是ECMAScript 6新增的。还有一种复杂数据类型叫 Object （对象）。 Object 是一种无序名值对的集合。因为ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部数据。
## 20、typeof 操作符
"undefined" 表示值未定义；
"boolean" 表示值为布尔值；
"string" 表示值为字符串；
"number" 表示值为数值；
"object" 表示值为对象（而不是函数）或 null ； "function" 表示值为函数；
"symbol" 表示值为符号。
## 21、Undefined 类型 
Undefined 类型只有一个值，就是特殊值 undefined 。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值。
## 22、Null 类型
 1、Null 类型同样只有一个值，即特殊值 null 。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回 "object" 的原因。
2、用等于操作符（ == ）比较 null 和 undefined 始终返回true 。
## 23、Boolean 类型 
Boolean （布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值： true 和 false 。这两个布尔值不同于数值，因此 true 不等于1， false 不等于0。
## 24、 NaN
有一个特殊的数值叫 NaN ，意思是“不是数值”（Not aNumber），用于表示本来要返回数值的操作失败了（而不是抛出错误）。
## 25、数值转换
有3个函数可以将非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。 Number() 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。Number() 函数基于如下规则执行转换。布尔值， true 转换为1， false 转换为0。
数值，直接返回。null ，返回0。 undefined ，返回 NaN 。
## 26、String 类型 
String （字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（"）、单引号（'）或反引号（`）标示。
## 27、Symbol.isConcatSpreadable
根据ECMAScript规范，这个符号作为一个属性表示“一个布尔值，如果是 true ，则意味着对象应该用Array.prototype.concat() 打平其数组元素”。ES6中的Array.prototype.concat() 方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖Symbol.isConcatSpreadable 的值可以修改这个行为。数组对象默认情况下会被打平到已有的数组， false 或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾， true 或真值会导致这个类数组对象被打平到数
组实例。其他不是类数组对象的对象在Symbol.isConcatSpreadable 被设置为 true 的情况下将被忽略。
## 28、Symbol.iterator
根据ECMAScript规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用”。换句话说，这个符号表示实现迭代器API的函数。
## 29、Symbol.split
根据ECMAScript规范，这个符号作为一个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由String.prototype.split() 方法使用”。 String.prototype.split() 方法会使用以
Symbol.split 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数。
## 30、 Symbol.toStringTag
根据ECMAScript规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法Object.prototype.toString() 使用”。通过 toString() 方法获取对象标识时，会检索由Symbol.toStringTag 指定的实例标识符，默认为 "Object" 。内置类型已经指定了这个值，但自定义类实例还需要明确定义。
## 31、Object 实例都有的属性和方法
constructor ：用于创建当前对象的函数，这个属性的值就是 Object() 函数。
hasOwnProperty(propertyName) ：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 o.hasOwnProperty("name") ）。
isPrototypeof(object) ：用于判断当前对象是否为另一个对象的原型。
propertyIsEnumerable(propertyName) ：用于判断给定的属性是否可以使用（本章稍后讨论的） for-in 语句枚举。与 hasOwnProperty() 一样，属性名必须是字符串。
toLocaleString() ：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。
toString() ：返回对象的字符串表示。
valueOf() ：返回对象对应的字符串、数值或布尔值表示。通常与 toString() 的返回值相同。

## 32、break 和 continue 语句
 break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中， break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行
## 33、with 语句 
with 语句的用途是将代码作用域设置为特定的对象，其语法是：with (expression) statement;
## 34、switch 语句 
switch 语句是与 if 语句紧密相关的一种流控制语句，从其他语言借鉴而来。ECMAScript中 switch 语句跟C语言中 switch 语句的语法非常相似
## 35、函数
可以通过函数名来调用函数，要传给函数的参数放在括号里（如果有多个参数，则用逗号隔开）。
严格模式对函数也有一些限制：函数不能以 eval 或 arguments 作为名称；
函数的参数不能叫 eval 或 arguments ；两个函数的参数不能叫同一个名称。
如果违反上述规则，则会导致语法错误，代码也不会执行。

# 第四章 变量、作用域与内存
## 1、传递参数
ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。
## 2、确定类型
1、typeof 虽然对原始值很有用，但它对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象，所以ECMAScript提供了 instanceof 操作符。
2、如果变量是给定引用类型的实例，则 instanceof 操作符返回 true 。
3、按照定义，所有引用值都是 Object 的实例，因此通过instanceof 操作符检测任何引用值和 Object 构造函数都会返回 true 。类似地，如果用 instanceof 检测原始值，则始终会返回 false ，因为原始值不是对象。
## 3、执行上下文
1、全局上下文是最外层的上下文，在浏览器中，全局上下文就是我们常说的 window 对象，因此所有通过var 定义的全局变量和函数都会成为 window 对象的属性和方法。
2、使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。
3、上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。
##### 总分类：
全局上下文、 changeColor() 的局部上下文和 swapColors() 的局部上下文。
全局上下文中有一个变量 color 和一个函数 chageColor() 。
 changeColor() 的局部上下文中有一个变量 anotherColor 和一个函数swapColors() ，但在这里可以访问全局上下文中的变量color 。
  swapColors() 的局部上下文中有一个变量tempColor ，只能在这个上下文中访问到。
  全局上下文和changeColor() 的局部上下文都无法访问到 tempColor 。而在swapColors() 中则可以访问另外两个上下文中的变量，因为它们都是父上下文。
## 4、作用域链
1、虽然执行上下文主要有全局上下文和函数上下文两种，但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。
2、try / catch 语句的 catch 块 with 语句：都会在作用域链前端添加一个变量对象。
对with 语句来说，会向作用域链前端添加指定的对象；对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。
## 5、变量声明
1、使用 var 的函数作用域声明：
在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文。
2. 使用 let 的块级作用域声明
ES6新增的 let 关键字跟 var 很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号 {} 界定。换句话说， if 块、 while 块、 function块，甚至连单独的块也是 let 声明变量的作用域。
3. 使用 const 的常量声明
除了 let ，ES6同时还增加了 const 关键字。使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。
## 6、垃圾回收
1、标记清理
JavaScript最常用的垃圾回收策略是标记清理。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。
2 、引用计数
另一种没那么常用的垃圾回收策略是引用计数，其思路是对每个值都记录它被引用的次数。
3 、性能
垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。
## 7、内存管理
1、通过 const 和 let 声明提升性能；
2、 隐藏类和删除操作；
3. 内存泄漏；
4. 静态分配与对象池
## 8、小结
1、JavaScript变量可以保存两种类型的值：原始值和引用值。原始值可能是以下6种原始数据类型之一： Undefined 、 Null 、Boolean 、 Number 、 String 和 Symbol 。
2、原始值和引用值有以下特点:
原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。

# 第五章 基本引用类型
## 1、基本引用类型
引用值（或者对象）是某个特定引用类型的实例。引用类型有时候也被称为对象定义，因为它们描述了自己的对象应有的属性和方法。
对象被认为是某个特定引用类型的实例。新对象通过使用 new 操作符后跟一个构造函（constructor）来创建，构造函数就是用来创建新对象的函数。
## 2、Date
1、要创建日期对象，就使用 new 操作符来调用 Date 构造函数：let now = new Date();
在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示。
2、ECMAScript为此提供了两个辅助方法： Date.parse() 和 Date.UTC() 。
3、Date.parse() 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。
4、Date.UTC() 方法也返回日期的毫秒表示，但使用的是跟Date.parse() 不同的信息来生成这个值。
## 3、继承的方法
与其他类型一样， Date 类型重写了 toLocaleString() 、 toString() 和 valueOf() 方法。但与其他类型不同，重写后这些方法的返回值不一样。 Date 类型的 toLocaleString() 方法返回与浏览器运行的本地环境一致的日期和时间。
## 4、日期格式化方法
Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：
toDateString() 显示日期中的周几、月、日、年（格式特定于实现）；
toTimeString() 显示日期中的时、分、秒和时区（格式特定于实现）；
toLocaleDateString() 显示日期中的周几、月、日、年（格式特定于实现和地区）；
toLocaleTimeString() 显示日期中的时、分、秒（格式特定于实现）；
toUTCString() 显示完整的UTC日期（格式特定于实现）。
这些方法的输出与 toLocaleString() 和 toString() 一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。
## 5、RegExp
1、正则表达式使用类似Perl的简洁语法来创建：let expression = /pattern/flags;
这个正则表达式的 pattern （模式）可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 flags （标记），用于控制正则表达式的行为。
2、g ：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
i ：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
m ：多行模式，表示查找到一行文本末尾时会继续查找。
y ：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
u ：Unicode模式，启用Unicode匹配。
s ： dotAll 模式，表示元字符 . 匹配任何字符（包括 \n 或 \r ）。
## 6、RegExp 实例属性
每个 RegExp 实例都有下列属性：
global ：布尔值，表示是否设置了 g 标记。
ignoreCase ：布尔值，表示是否设置了 i 标记。
unicode ：布尔值，表示是否设置了 u 标记。
sticky ：布尔值，表示是否设置了 y 标记。
lastIndex ：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。
multiline ：布尔值，表示是否设置了 m 标记。
dotAll ：布尔值，表示是否设置了 s 标记。
source ：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
flags ：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。
## 7、RegExp 实例方法
1、RegExp 实例的主要方法是 exec() ，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回 null 。
2、返回的数组虽然是 Array 的实例，但包含两个额外的属性： index 和 input 。 index 是字符串中匹配模式的起始位置， input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。
## 8、RegExp 构造函数属性
1、RegExp 构造函数本身也有几个属性。这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。每个属性都有一个全名和一个简写。
2、例：全名/ 简写 /说明
input $_ 最后搜索的字符串
lastMatch $& 最后匹配的文本
lastParen $+ 最后匹配的捕获组
leftContext $` input 字符串中出现在
lastMatch 前面的文本
rightContext $' input 字符串中出现在lastMatch 后面的文本
3、input 属性中包含原始的字符串。
leftConext 属性包含原始字符串中 "short" 之前的内容，
rightContext 属性包含 "short" 之后的内容。
lastMatch 属性包含匹配整个正则表达式的上一个字符串，即 "short" 。 lastParen 属性包含捕获组的上一次匹配，即 "s" 。
## 9、原始值包装类型
为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：
Boolean 、 Number 和 String 。这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。
## 10、Boolean 
1、Boolean 是对应布尔值的引用类型。要创建一个 Boolean 对象，就使用 Boolean 构造函数并传入 true 或 false：let booleanObject = new Boolean(true);
2、Boolean 的实例会重写 valueOf() 方法，返回一个原始值 true 或 false 。 toString() 方法被调用时也会被覆盖，返回字符串 "true" 或 "false" 。不过， Boolean 对象在ECMAScript中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用Boolean 对象时。
## 11、Number 
1、Number 是对应数值的引用类型。要创建一个 Number 对象，就使用 Number 构造函数并传入一个数值：let numberObject = new Number(10);
2、与 Boolean 类型一样， Number 类型重写了 valueOf() 、 toLocaleString() 和 toString() 方法。 valueOf() 方法返回Number 对象表示的原始数值，另外两个方法返回数值字符串。toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串。
## 12、String 
1、String 是对应字符串的引用类型。要创建一个 String 对象，使用 String 构造函数并传入一个数值：let stringObject = new String("hello world");
2、String 对象的方法可以在所有字符串原始值上调用。3个继承的方法 valueOf() 、toLcaleString() 和 toString() 都返回对象的原始字符串值。每个 String 对象都有一个 length 属性，表示字符串中字符的数量。
## 13、单例内置对象
1、内置对象包括 Object 、 Array 和 String ，单例内置对象： Global 和 Math 。
2、Global 对象是ECMAScript中最特别的对象，因为代码不会显式地访问它。
isNaN() 、 isFinite() 、 parseInt() 和 parseFloat() ，实际上都是 Global 对象的方法。
3、Global 对象属性：
Global 对象有很多属性：undefined 、 NaN 和 Infinity 等特殊值都是 Global 对象的属性。此外，所有原生引用类型构造函数，比如 Object 和 Function ，也都是 Global 对象的属性。
4、例：
属性 / 说明
undefined 特殊值 undefined 
NaN 特殊值 NaN
 Infinity 特殊值 Infinity 
 Object Object 的构造函数
 Array Array 的构造函数
Function Function 的构造函数
Boolean Boolean 的构造函数
String String 的构造函数
Number Number 的构造函数
Date Date 的构造函数
RegExp RegExp 的构造函数
Symbol Symbol 的伪构造函数
Error Error 的构造函数
EvalError EvalError 的构造函数
RangeError RangeError 的构造函数
ReferenceError ReferenceError 的构造函数
SyntaxError SyntaxError 的构造函数
TypeError TypeError 的构造函数
URIError URIError 的构造函数
## 14、Math
1、ECMAScript提供了 Math 对象作为保存数学公式、信息和计算的地方。 Math 对象提供了一些辅助计算的属性和方法。
2、Math 对象属性
Math 对象有一些属性，主要用于保存数学中的一些特殊值。
3、min() 和 max() 方法
Math 对象也提供了很多辅助执行简单或复杂数学计算的方法。min() 和 max() 方法用于确定一组数值中的最小值和最大值。这两个方法都接收任意多个参数。
4、 舍入方法
接下来是用于把小数值舍入为整数的4个方法： Math.ceil() 、 Math.floor() 、 Math.round() 和 Math.fround() 。这几个方法处理舍入的方式如下：
Math.ceil() 方法始终向上舍入为最接近的整数。
Math.floor() 方法始终向下舍入为最接近的整数。
Math.round() 方法执行四舍五入。
## 15、random() 方法
Math.random() 方法返回一个0~1范围内的随机数，其中包含0但不包含1。对于希望显示随机名言或随机新闻的网页，这个方法是非常方便的。
## 16、总：
1、引用值与传统面向对象编程语言中的类相似，但实现不同。Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。
RegExp 类型是ECMAScript支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。
2、由于原始值包装类型的存在，JavaScript中的原始值可以被当成对象来使用。有3种原始值包装类型： Boolean 、 Number 和 String 。它们都具备如下特点。
每种包装类型都映射到同名的原始类型。
以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。
涉及原始值的语句执行完毕后，包装对象就会被销毁。
3、当代码开始执行时，全局上下文中会存在两个内置对象： Global 和 Math 。其中， Global 对象在大多数ECMAScript实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函数都是Global 对象的属性。 Math 对象包含辅助完成复杂计算的属性和方法。

# 第六章 集合引用类型
## 1、Object
1、显式地创建 Object 的实例有两种方式。第一种是使用 new 操作符和 Object 构造函数，另一种方式是使用对象字面量表示法。
2、虽然属性一般是通过点语法来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式。
3、通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。
## 2、Array
1、有几种基本的方式可以创建数组。一种是使用 Array 构造函数，比如：let colors = new Array();也可以给 Array 构造函数传入要保存的元素
2、创建数组时可以给构造函数传一个值。这时候就有点问题了，因为如果这个值是数值，则会创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组。
3、在使用 Array 构造函数时，也可以省略 new 操作符，结果是一样的：
let colors = Array(3); // 创建一个包含3个元素的数组
let names = Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组
4、另一种创建数组的方式是使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表：
let colors = ["red", "blue", "green"]; // 创建一个包：含3个元素的数组
let names = []; // 创建一个空数组
let values = [1,2,]; // 创建一个包
含2个元素的数组
## 3、数组空位
const options = [,,,,,]; // 创建包含5个元素的数组
console.log(options.length); // 5
console.log(options); // [,,,,,]
## 4、数组索引
要取得或设置数组的值，需要使用中括号并提供相应值的数字索引：
let colors = ["red", "blue", "green"]; // 定义一个字符串数组
alert(colors[0]); // 显示第一项
colors[2] = "black"; // 修改第三项
colors[3] = "brown"; // 添加第四项
## 5、检测数组
1、在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣：
if (value instanceof Array){ // 操作数组}
2、如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。为解决这个问题，ECMAScript提供了 Array.isArray() 方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的：
if (Array.isArray(value)){ // 操作数组}
## 6、迭代器方法
在ES6中， Array 的原型上暴露了3个用于检索数组内容的方法：keys() 、 values() 和 entries() 。 keys() 返回数组索引的迭代器， values() 返回数组元素的迭代器，而 entries() 返回索引/值对的迭代器：
const a = ["foo", "bar", "baz", "qux"]; // 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys());
 const aValues = Array.from(a.values()); 
 const aEntries = Array.from(a.entries()); 
 console.log(aKeys); // [0, 1, 2, 3] 
 console.log(aValues); // ["foo", "bar", "baz", "qux"]
 console.log(aEntries); // [[0, "foo"], [1, "bar"],[2, "baz"], [3, "qux"]]
## 7、转换方法
1、所有对象都有 toLocaleString() 、 toString() 和 valueOf() 方法。其中， valueOf() 返回的还是数组本身。而toString() 返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString() 方法，以得到最终的字符串。
例子：
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组
alert(colors.toString()); // red,blue,green 
alert(colors.valueOf()); // red,blue,green 
alert(colors); // red,blue,green
2、toLocaleString() 方法也可能返回跟 toString() 和 valueOf() 相同的结果，但也不一定。在调用数组的toLocaleString() 方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的 toLocaleString() 方法，而不是 toString() 方法：

```javascript
let person1 = { 
	toLocaleString() { 
		return "Nikolaos"; 
		},
	toString() { 
		return "Nicholas"; 
		} 
	};
	let person2 = { 
	toLocaleString() { 
		return "Grigorios"; 
		},toString() {
		 return "Greg"; 
		 } 
		};
		 let people = [person1, person2]; 
		 alert(people); // Nicholas,Greg alert(people.toString()); // Nicholas,Greg
		alert(people.toLocaleString()); // Nikolaos,Grigorios
```
## 8、队列方法
队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 push() 方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫shift() ，它会删除数组的第一项并返回它，然后数组长度减1。使用shift() 和 push() ，可以把数组当成队列来使用：

```javascript
let colors = new Array(); // 创建一个数组
let count = colors.push("red", "green"); // 推入两项
alert(count); // 2 count = colors.push("black"); // 再推入一项
alert(count); // 3 let item = colors.shift(); // 取得第一项
alert(item); // red alert(colors.length); // 2
```
## 9、排序方法
1、数组有两个方法可以用来对元素重新排序： reverse() 和 sort() 。
reverse() 方法就是将数组元素反向排列：let values = [1, 2, 3, 4, 5]; values.reverse(); alert(values); // 5,4,3,2,1
2、 sort() 会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此， sort() 会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序：
let values = [0, 1, 5, 10, 15]; values.sort(); alert(values); // 0,1,10,15,5
## 10、splice
splice() 的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法：
1.删除：需要给 splice() 传2个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如splice(0, 2) 会删除前两个元素。
2.插入：需要给 splice() 传3个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元
素。比如， splice(2, 0, "red", "green") 会从数组位置2开始插入字符串 "red" 和 "green" 。
3.替换： splice() 在删除元素的同时可以在指定位置插入新元素，同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，splice(2, 1, "red", "green") 会在位置2删除一个元素，然后从该位置开始向数组中插入 "red" 和 "green" 。 splice() 方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。
## 11、基本API
1、使用 new 关键字和 Set 构造函数可以创建一个空集合：const m = new Set();
2、初始化之后，可以使用 add() 增加值，使用 has() 查询，通过size 取得元素数量，以及使用 delete() 和 clear() 删除元素：
const s = new Set(); alert(s.has("Matt")); // false 
alert(s.size); // 0 
s.add("Matt") .add("Frisbie");
 alert(s.has("Matt")); // true 
 alert(s.size); // 2 
 s.delete("Matt");
alert(s.has("Matt")); // false
 alert(s.has("Frisbie")); // true 
 alert(s.size); // 1 
 s.clear(); // 销毁集合实例中的所有值
alert(s.has("Matt")); // false 
alert(s.has("Frisbie")); // false 
alert(s.size); // 0
## 12、总结
引用类型与传统面向对象编程语言中的类相似，但实现不同。
Object 类型是一个基础类型，所有引用类型都从它继承了基本的行为。
Array 类型表示一组有序的值，并提供了操作和转换值的能力。
定型数组包含一套不同的引用类型，用于管理数值在内存中的类型。
Date 类型提供了关于日期和时间的信息，包括当前日期和时间以及计算。
RegExp 类型是ECMAScript支持的正则表达式的接口，提供了大多数基本正则表达式以及一些高级正则表达式的能力。

# 第 8 章 对象、类与面向对象编程
## 1、理解对象
 1、创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法：
```javascript
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29; 
person.job = "Software Engineer"; 
person.sayName = function() { console.log(this.name); };
```
### 1.1、属性的类型：
属性分两种：数据属性和访问器属性。
#### 1.1.1、数据属性
数据属性包含一个保存数据值的位置，值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为。
[[Configurable]] ：表示属性是否可以通过 delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
[[Enumberable]] ：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。
[[Writable]] ：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是true 。
[[Value]] ：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为undefined 。
##### 例子：
```javascript
let person = {}; 
Object.defineProperty(person, "name", { 
	writable: false, 
	value: "Nicholas" 
}); 
console.log(person.name); // "Nicholas" 
person.name = "Greg"; 
console.log(person.name); // "Nicholas"
```
这个例子创建了一个名为 name 的属性并给它赋予了一个只读的值 "Nicholas" 。这个属性的值就不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略。在严格模式下，尝试修改只读属性的值会抛出错误。
#### 1.1.2.、访问器属性
访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为。
[[Configurable]] ：表示属性是否可以通过 delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。 
[[Enumerable]] ：表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true 。 
[[Get]] ：获取函数，在读取属性时调用。默认值为undefined 。 
[[Set]] ：设置函数，在写入属性时调用。默认值为undefined 。
访问器属性是不能直接定义的，必须使用Object.defineProperty() 。
##### 例子：
```javascript
// 定义一个对象，包含伪私有成员year_和公共成员edition 
let book = { 
	year_: 2017, 
	edition: 1
};
Object.defineProperty(book, "year", { 
	get() { 
		return this.year_; 
	},
	set(newValue) { 
		if (newValue > 2017) { 
			this.year_ = newValue; 
			this.edition += newValue - 2017; 
		} 
	}
}); 
book.year = 2018; 
console.log(book.edition); // 2
```
### 1.2、定义多个属性
在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript提供了Object.defineProperties() 方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。
#### 例子：
```javascript
let book = {}; 
Object.defineProperties(book, { 
	year_: { 
		value: 2017 
	},
	edition: { 
		value: 1 
	},
	year: {
	 get() { 
	    return this.year_; 
	 },
	 set(newValue) { 
	 	if (newValue > 2017) { 
	 		this.year_ = newValue; 
	 		this.edition += newValue - 2017; 
	 	}
	 } 
	} 
});
```
### 1.3、读取属性的特性
使用 Object.getOwnPropertyDescriptor() 方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable 、 enumerable 、 get 和 set 属性，对于数据属性包含 configurable 、 enumberable 、 writable 和 value 属性。
## 2、创建对象
虽然使用 Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具有同样接口的多个对象需要重复编写很多代码。
### 2.2、构造函数模式
构造函数是用于创建特定类型对象的，像 Object 和 Array 这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。
#### 2.2.1、例子：
```javascript
function Person(name, age, job){ 
	this.name = name; 
	this.age = age; 
	this.job = job; 
	this.sayName = function() { 
		console.log(this.name); 
		}; 
	}
	let person1 = new Person("Nicholas", 29, "Software Engineer"); 
	let person2 = new Person("Greg", 27, "Doctor"); 
	person1.sayName(); // Nicholas 
	person2.sayName(); // Greg
```
在这个例子中， Person() 构造函数代替了createPerson() 工厂函数。实际上， Person() 内部的代码跟
createPerson() 基本是一样的，只是有如下区别：
没有显式地创建对象；
属性和方法直接赋值给了this ；
没有 return 。
#### 2.2.2、小总结
要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作：
(1) 在内存中创建一个新对象。
(2) 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数的 prototype 属性。
(3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。
(4) 执行构造函数内部的代码（给新对象添加属性）。
(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。
### 2.3、原型模式
每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。
#### 2.3.1、例子
```javascript
function Person() {} 
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function() { 
	console.log(this.name); 
	};
	let person1 = new Person(); 
	person1.sayName(); // "Nicholas" 
	let person2 = new Person(); 
	person2.sayName(); // "Nicholas"
	console.log(person1.sayName == person2.sayName); // true
```
## 3、继承
### 3.1、原型链
基本思想：通过原型继承多个引用类型的属性和方法。
```javascript
function SuperType() { 
	this.property = true; 
}
SuperType.prototype.getSuperValue = function() { 
	return this.property; 
};
function SubType() { 
	this.subproperty = false; 
}
// 继承SuperType 
SubType.prototype = new SuperType(); 
SubType.prototype.getSubValue = function () { 
	return this.subproperty; 
};
let instance = new SubType(); 
console.log(instance.getSuperValue()); // true
```
上代码定义了两个类型： SuperType 和 SubType ，这两个类型分别定义了一个属性和一个方法。
这两个类型的主要区别是SubType 通过创建 SuperType 的实例并将其赋值给自己的原型SubTtype.prototype 实现了对 SuperType 的继承。这个赋值重写了 SubType 最初的原型，将其替换为 SuperType 的实例。这意味着 SuperType 实例可以访问的所有属性和方法也会存在于SubType.prototype 。这样实现继承之后，代码紧接着又给SubType.prototype 也就是这个 SuperType 的实例添加了一个新方法。最后又创建了 SubType 的实例并调用了它继承的getSuperValue() 方法。
### 3.2、组合继承
组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。
### 3.3、原型式继承
```javascript
function object(o) { 
	function F() {} 
	F.prototype = o; return new F(); 
}
```
这个 object() 函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上， object() 是对传入的对象执行了一次浅复制。
### 3.4、寄生式继承
与原型式继承比较接近的一种继承方式是寄生式继承。
寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。
#### 3.4.1、基本的寄生继承模式如下：
```javascript
function createAnother(original){ 
	let clone = object(original); // 通过调用函数创建一个新对象
	clone.sayHi = function() { // 以某种方式增强这个对象
	console.log("hi"); 
	};
	return clone; // 返回这个对象
}
```
### 3.5、寄生式组合继承
组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。
## 4、类
 class 关键字具有正式定义类的能力，类是ECMAScript中新的基础性语法糖结构。
### 4.1、类定义
与函数类型相似，定义类也有两种主要方式：类声明和类表达式，这两种方式都使用 class 关键字加大括号。
```javascript
// 类声明
class Person {}
// 类表达式
const Animal = class {};
```
#### 4.1.1、类的构成
类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。
### 4.2、类构造函数
constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。
#### 4.2.1、 实例化
使用 new 操作符实例化 Person 的操作等于使用 new 调用其构造函数。唯一可感知的不同之处就是，JavaScript解释器知道使用 new 和类意味着应该使用 constructor 函数进行实例化。
使用new调用类的构造函数会执行如下操作。
(1) 在内存中创建一个新对象。
(2) 这个新对象内部的 [[Prototype]] 指针被赋值为构造函数的 prototype 属性。
(3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。
(4) 执行构造函数内部的代码（给新对象添加属性）。
(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。
#### 4.2.2、 把类当成特殊函数
ECMAScript中没有正式的类这个类型。从各方面来看，ECMAScript类就是一种特殊函数。声明一个类之后，通过typeof 操作符检测类标识符，表明它是一个函数：
```javascript
class Person {}
console.log(Person); // class Person {}
console.log(typeof Person); // function
```
类标签符有 prototype 属性，而这个原型也有一个constructor 属性指向类自身：
```javascript
class Person{} 
console.log(Person.prototype); // { constructor: f() } 
console.log(Person === Person.prototype.constructor); //true
```
## 5、继承
### 5.1、继承基础
ES6类支持单继承。使用 extends 关键字，就可以继承任何拥有 [[Construct]] 和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：
```javascript
class Vehicle {} // 继承类
class Bus extends Vehicle {} 
let b = new Bus(); 
console.log(b instanceof Bus); // true 
console.log(b instanceof Vehicle); // true 
function Person() {} // 继承普通构造函数
class Engineer extends Person {} 
let e = new Engineer(); 
console.log(e instanceof Engineer); // true 
console.log(e instanceof Person); // true
```
### 5.2、 构造函数、 HomeObject 和 super()
派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造函数。
```javascript
class Vehicle { 
	constructor() { 
		this.hasEngine = true; 
		} 
	}
	class Bus extends Vehicle { 
		constructor() { // 不要在调用super()之前引用this，否则会抛出ReferenceError 
		super(); // 相当于super.constructor()
		console.log(this instanceof Vehicle); // true 
		console.log(this); // Bus { hasEngine: true } 
		} 
	}
	new Bus()
```

# 第 9 章 代理与反射
## 1、代理基础
代理是目标对象的抽象
### 1.1、创建空代理
最简单的代理是空代理，即除了作为一个抽象的目标对象，什么也不做。默认情况下，在代理对象上执行的所有操作都会无障碍地传播到目标对象。因此，在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。
#### 重点
代理是使用 Proxy 构造函数创建的。这个构造函数接收两个参数：目标对象和处理程序对象。缺少其中任何一个参数都会抛出TypeError 。要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。
### 1.2、定义捕获器
使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。
#### 例
```javascript
const target = { foo: 'bar' };
const handler = { // 捕获器在处理程序对象中以方法名为键
get() { 
	return 'handler override'; 
	} 
};
const proxy = new Proxy(target, handler);
```
这样，当通过代理对象执行 get() 操作时，就会触发定义的get() 捕获器。当然， get() 不是ECMAScript对象可以调用的方法。这个操作在JavaScript代码中可以通过多种形式触发并被 get()捕获器拦截到。 proxy[property] 、 proxy.property 或 Object.create(proxy)[property] 等操作都会触发基本的get() 操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发 get() 捕获器。注意，只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。
### 1.3、可撤销代理
有时候可能需要中断代理对象与目标对象之间的联系。对于使用new Proxy() 创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。
Proxy 也暴露了 revocable() 方法，这个方法支持撤销代理对象与目标对象的关联。撤销代理的操作是不可逆的。而且，撤销函数（ revoke() ）是幂等的，调用多少次的结果都一样。撤销代理之后再调用代理会抛出 TypeError 。
#### 例
撤销函数和代理对象是在实例化时同时生成的：
```javascript
const target = { 
	foo: 'bar' 
};
const handler = { 
	get() { 
		return 'intercepted'; 
	} 
};
const { 
	proxy, revoke 
} = 
	Proxy.revocable(target, handler); 
	console.log(proxy.foo); // intercepted 
	console.log(target.foo); // bar revoke(); 
	console.log(proxy.foo); // TypeError
```
### 1.4、实用反射API
某些情况下应该优先使用反射API，这是有一些理由的。
#### 1.4.1、 反射API与对象API
在使用反射API时，要记住：
(1) 反射API并不限于捕获处理程序；
(2) 大多数反射API方法在 Object 类型上有对应的方法。
通常， Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。
#### 1.4.2、 状态标记
很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误（取决于方法）的反射API方法更有用。例如，可以使用反射API对下面的代码进行重构：
```javascript
// 初始代码
const o = {}; 
try {
 Object.defineProperty(o, 'foo', 'bar'); 
 console.log('success'); 
} catch(e) { 
	console.log('failure'); 
}
```
在定义新属性时如果发生问题，Reflect.defineProperty() 会返回 false ，而不是抛出错误。因此使用这个反射方法可以这样重构上面的代码：
```javascript
// 重构后的代码
const o = {}; 
if(Reflect.defineProperty(o, 'foo', {value: 
	'bar'})) { 
	console.log('success'); 
} else { 
	console.log('failure'); 
}
```
##### 以下反射方法都会提供状态标记：
Reflect.defineProperty() 
Reflect.preventExtensions()
Reflect.setPrototypeOf() 
Reflect.set() 
Reflect.deleteProperty()
#### 1.4.3、 用一等函数替代操作符
以下反射方法提供只有通过操作符才能完成的操作。
Reflect.get() ：可以替代对象属性访问操作符。
Reflect.set() ：可以替代 = 赋值操作符。
Reflect.has() ：可以替代 in 操作符或 with() 。 Reflect.deleteProperty() ：可以替代 delete 操作符。
Reflect.construct() ：可以替代 new 操作符。
#### 1.4.4、安全地应用函数
在通过 apply 方法调用函数时，被调用的函数可能也定义了自己的 apply 属性（虽然可能性极小）。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法，比如：
```javascript
Function.prototype.apply.call(myFunc, thisVal, argumentList);
```
这种可怕的代码完全可以使用 Reflect.apply 来避免：
```javascript
Reflect.apply(myFunc, thisVal, argumentsList);
```
### 1.5、代理的问题与不足
#### 1.5.1、代理中的 this
代理潜在的一个问题来源是 this 值。我们知道，方法中的this 通常指向调用这个方法的对象：
```javascript
const target = { 
	thisValEqualsProxy() { 
		return this === proxy; 
		} 
	}
const proxy = new Proxy(target, {}); 
console.log(target.thisValEqualsProxy()); // false 
console.log(proxy.thisValEqualsProxy()); // true
```
从直觉上讲，这样完全没有问题：调用代理上的任何方法，比如proxy.outerMethod() ，而这个方法进而又会调用另一个方法，如 this.innerMethod() ，实际上都会调用proxy.innerMethod() 。多数情况下，这是符合预期的行为。
#### 1.5.2、代理与内部槽位
代理与内置引用类型（比如 Array ）的实例通常可以很好地协同，但有些ECMAScript内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。
##### 一个典型的例子就是 Date 类型
根据ECMAScript规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]] 。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get() 和 set() 操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出TypeError ：
```javascript
const target = new Date(); 
const proxy = new Proxy(target, {}); 
console.log(proxy instanceof Date); // true 
proxy.getDate(); // TypeError: 'this' is nota Date object
```
## 2、代理捕获器与反射方法
### 2.1、get() 
get() 捕获器会在获取属性值的操作中被调用。对应的反射API方法为 Reflect.get() 。
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	get(target, property, receiver) { 
		console.log('get()'); 
		return Reflect.get(...arguments) } 
	}); 
	proxy.foo; // get() 
```
#### 2.1.1. 返回值
返回值无限制。
#### 2.1.2. 拦截的操作
proxy.property 
proxy[property]
Object.create(proxy)[property]
Reflect.get(proxy, property, receiver)
#### 2.1.3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
receiver ：代理对象或继承代理对象的对象。
#### 2.1.4. 捕获器不变式
如果 target.property 不可写且不可配置，则处理程序返回的值必须与 target.property 匹配。
如果 target.property 不可配置且 [[Get]] 特性为undefined ，处理程序的返回值也必须是 undefined 
### 2.2 set() 
set() 捕获器会在设置属性值的操作中被调用。对应的反射API方法为 Reflect.set() 。 
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	set(target, property, value, receiver) { 
		console.log('set()'); 
		return Reflect.set(...arguments) } 
	}); 
	proxy.foo = 'bar'; // set() 
```
#### 2.2.1. 返回值
返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError 。 
#### 2.2.2. 拦截的操作
proxy.property = value 
proxy[property] = value
 Object.create(proxy)[property] = value
Reflect.set(proxy, property, value,receiver)
#### 2.2.3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
value ：要赋给属性的值。
receiver ：接收最初赋值的对象。
#### 2.2.4. 捕获器不变式
如果 target.property 不可写且不可配置，则不能修改目标属性的值。
如果 target.property 不可配置且 [[Set]] 特性为undefined ，则不能修改目标属性的值。
在严格模式下，处理程序中返回 false 会抛出 TypeError 。
### 2.3 has() 
has() 捕获器会在 in 操作符中被调用。对应的反射API方法为 Reflect.has() 。 
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	has(target, property) { 
		console.log('has()'); 
		return Reflect.has(...arguments) } 
	}); 
	'foo' in proxy; // has()
```
#### 2.3.1. 返回值
has() 必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值。
#### 2.3.2. 拦截的操作
property in proxy property in Object.create(proxy)
with(proxy) {(property);}
Reflect.has(proxy, property)
#### 2.3.3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
#### 2.3.4. 捕获器不变式
如果 target.property 存在且不可配置，则处理程序必须返回 true 。
如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true 。 
### 2.4 defineProperty() 
defineProperty() 捕获器会在Object.defineProperty() 中被调用。对应的反射API方法为Reflect.defineProperty() 。 
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	defineProperty(target, property, descriptor) { 
		console.log('defineProperty()');
		return Reflect.defineProperty(...arguments) } 
	}); 
	Object.defineProperty(proxy, 'foo', { value: 'bar' }); // defineProperty()
```

#### 2.4.1. 返回值
defineProperty() 必须返回布尔值，表示属性是否成功定
义。返回非布尔值会被转型为布尔值。
#### 2.4.2. 拦截的操作
Object.defineProperty(proxy, property,
descriptor) Reflect.defineProperty(proxy, property,
descriptor) 
#### 2.4.3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
descriptor ：包含可选的 enumerable 、 configurable 、 writable 、 value 、 get 和 set 定义的对象。
#### 2.4.4. 捕获器不变式
如果目标对象不可扩展，则无法定义属性。
如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性。
如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性。
### 2.5 getOwnPropertyDescriptor() 
getOwnPropertyDescriptor() 捕获器会在Object.getOwnPropertyDescriptor() 中被调用。对应的反
射API方法为 Reflect.getOwnPropertyDescriptor() 。 
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	getOwnPropertyDescriptor(target, property) { 
		console.log('getOwnPropertyDescriptor()'); 
		return Reflect.getOwnPropertyDescriptor(...arguments) } 
	});
	 Object.getOwnPropertyDescriptor(proxy, 'foo'); // getOwnPropertyDescriptor()
```

#### 2.5.1. 返回值
getOwnPropertyDescriptor() 必须返回对象，或者在属性不存在时返回 undefined 。 
#### 2.5.2. 拦截的操作
Object.getOwnPropertyDescriptor(proxy,property)
Reflect.getOwnPropertyDescriptor(proxy,property) 
#### 2.5.3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
#### 2.5.4. 捕获器不变式
如果自有的 target.property 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象。
如果自有的 target.property 存在且可配置，则处理程序必须返回表示该属性可配置的对象。
如果自有的 target.property 存在且 target 不可扩展，则处理程序必须返回一个表示该属性存在的对象。
如果 target.property 不存在且 target 不可扩展，则处理程序必须返回 undefined 表示该属性不存在。
如果 target.property 不存在，则处理程序不能返回表示该属性可配置的对象。
### 2.6 deleteProperty() 
deleteProperty() 捕获器会在 delete 操作符中被调用。对应的反射API方法为 Reflect.deleteProperty() 。 
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	deleteProperty(target, property) { 
		console.log('deleteProperty()'); 
		return Reflect.deleteProperty(...arguments)
	} 
});
delete proxy.foo // deleteProperty() 
```
#### 2.6.1. 返回值
deleteProperty() 必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。
#### 2.6.2. 拦截的操作
delete proxy.property delete proxy[property] Reflect.deleteProperty(proxy, property)
#### 2.6.3. 捕获器处理程序参数
target ：目标对象。
property ：引用的目标对象上的字符串键属性。
#### 2.6.4. 捕获器不变式
如果自有的 target.property 存在且不可配置，则处理程序不能删除这个属性。
### 2.7 ownKeys() 
ownKeys() 捕获器会在 Object.keys() 及类似方法中被调用。对应的反射API方法为 Reflect.ownKeys() 。 
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, {
	ownKeys(target) { 
		console.log('ownKeys()'); 
		return Reflect.ownKeys(...arguments) 
		} 
	});
	Object.keys(proxy); // ownKeys() 
```
#### 2.7.1. 返回值
ownKeys() 必须返回包含字符串或符号的可枚举对象。
#### 2.7.2. 拦截的操作
Object.getOwnPropertyNames(proxy)
Object.getOwnPropertySymbols(proxy)
Object.keys(proxy) Reflect.ownKeys(proxy) 3. 捕获器处理程序参数
target ：目标对象。
#### 2.7.4. 捕获器不变式
返回的可枚举对象必须包含 target 的所有不可配置的自有属性。
如果 target 不可扩展，则返回可枚举对象必须准确地包含自有属性键。
### 2.8 getPrototypeOf() 
getPrototypeOf() 捕获器会在Object.getPrototypeOf() 中被调用。对应的反射API方法为
Reflect.getPrototypeOf() 。 
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	getPrototypeOf(target) { 
		console.log('getPrototypeOf()'); 
		return Reflect.getPrototypeOf(...arguments) } 
	}); 
	Object.getPrototypeOf(proxy); // getPrototypeOf() 
```
#### 2.8.1. 返回值
getPrototypeOf() 必须返回对象或 null 。 
#### 2.8.2. 拦截的操作
Object.getPrototypeOf(proxy)
Reflect.getPrototypeOf(proxy)
proxy.__proto__ Object.prototype.isPrototypeOf(proxy)
proxy instanceof Object 
#### 2.8.3. 捕获器处理程序参数
target ：目标对象。
#### 2.8.4. 捕获器不变式
如果 target 不可扩展，则
Object.getPrototypeOf(proxy) 唯一有效的返回值就是
Object.getPrototypeOf(target) 的返回值。
### 2.9 setPrototypeOf() 
setPrototypeOf() 捕获器会在Object.setPrototypeOf() 中被调用。对应的反射API方法为Reflect.setPrototypeOf() 。 
```javascript
const myTarget = {}; 
const proxy = new Proxy(myTarget, { 
	setPrototypeOf(target, prototype) { 
		console.log('setPrototypeOf()'); 
		return Reflect.setPrototypeOf(...arguments) 
		} 
	}); 
	Object.setPrototypeOf(proxy, Object); // setPrototypeOf() 
```
#### 2.9.1. 返回值
setPrototypeOf() 必须返回布尔值，表示原型赋值是否成功。返回非布尔值会被转型为布尔值。
#### 2.9.2. 拦截的操作
Object.setPrototypeOf(proxy)
Reflect.setPrototypeOf(proxy)
#### 2.9.3. 捕获器处理程序参数
target ：目标对象。
prototype ： target 的替代原型，如果是顶级原型则为 null 。
#### 2.9.4. 捕获器不变式
如果 target 不可扩展，则唯一有效的 prototype 参数就是Object.getPrototypeOf(target) 的返回值。
### 2.10 isExtensible()
 isExtensible() 捕获器会在 Object.isExtensible()中被调用。对应的反射API方法为Reflect.isExtensible() 。 
```javascript
 const myTarget = {}; 
 const proxy = new Proxy(myTarget, { 
 	isExtensible(target) { 
 		console.log('isExtensible()'); 
 		return Reflect.isExtensible(...arguments)
 		 } 
 	 });
 	Object.isExtensible(proxy); // isExtensible() 
```
#### 2.10.1. 返回值
isExtensible() 必须返回布尔值，表示 target 是否可扩展。返回非布尔值会被转型为布尔值。
#### 2.10.2. 拦截的操作
Object.isExtensible(proxy)
Reflect.isExtensible(proxy)
#### 2.10.3. 捕获器处理程序参数
target ：目标对象。
#### 2.10.4. 捕获器不变式
如果 target 可扩展，则处理程序必须返回 true 。
如果 target 不可扩展，则处理程序必须返回 false 。
### 2.11 preventExtensions() 
preventExtensions() 捕获器会在Object.preventExtensions() 中被调用。对应的反射API方法为 Reflect.preventExtensions() 。
```javascript
 const myTarget = {}; 
 const proxy = new Proxy(myTarget, { 
 	preventExtensions(target) { 
 		console.log('preventExtensions()'); 
 		return Reflect.preventExtensions(...arguments) 
 		} 
 	});
 	Object.preventExtensions(proxy); // preventExtensions() 
```
#### 2.11.1. 返回值
preventExtensions() 必须返回布尔值，表示 target 是否已经不可扩展。返回非布尔值会被转型为布尔值。
#### 2.11.2. 拦截的操作
Object.preventExtensions(proxy)
Reflect.preventExtensions(proxy)
#### 2.11.3. 捕获器处理程序参数
target ：目标对象。
#### 2.11.4. 捕获器不变式
如果 Object.isExtensible(proxy) 是 false ，则处理程序必须返回 true 。 
### 2.12 apply() 
apply() 捕获器会在调用函数时中被调用。对应的反射API方法为 Reflect.apply() 。 
```javascript
const myTarget = () => {}; 
const proxy = new Proxy(myTarget, { 
	apply(target, thisArg, ...argumentsList) { 
		console.log('apply()'); 
		return Reflect.apply(...arguments) 
		} 
	});
	proxy(); // apply() 
```
#### 2.12.1. 返回值
返回值无限制。
#### 2.12.2. 拦截的操作
proxy(...argumentsList) Function.prototype.apply(thisArg,argumentsList) Function.prototype.call(thisArg,...argumentsList) Reflect.apply(target, thisArgument,argumentsList) 
#### 2.12.3. 捕获器处理程序参数
target ：目标对象。
thisArg ：调用函数时的 this 参数。
argumentsList ：调用函数时的参数列表
#### 2.12.4. 捕获器不变式
target 必须是一个函数对象。
### 2.13 construct() 
construct() 捕获器会在 new 操作符中被调用。对应的反射API方法为 Reflect.construct() 。
```javascript
 const myTarget = function() {}; 
 const proxy = new Proxy(myTarget, {
 	 construct(target, argumentsList, newTarget) { 
 	 console.log('construct()'); 
 	 return Reflect.construct(...arguments) 
 	 } 
 });
 new proxy; // construct() 
```
#### 2.13.1. 返回值
construct() 必须返回一个对象。
#### 2.13.2. 拦截的操作
new proxy(...argumentsList)
Reflect.construct(target, argumentsList,newTarget) 
#### 2.13.3. 捕获器处理程序参数
target ：目标构造函数。
argumentsList ：传给目标构造函数的参数列表。
newTarget ：最初被调用的构造函数。
#### 2.13.4. 捕获器不变式
target 必须可以用作构造函数。

# 第 10 章 函数
## 1、函数
函数实际上是对象，每个函数都是 Function 类型的实例，而 Function也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定：
```javascript
function sum (num1, num2) { 
	return num1 + num2;
 }
```
另一种定义函数的语法是函数表达式：
```javascript
let sum = function(num1, num2) { 
	return num1 + num2;
};
```
## 2、箭头函数
ECMAScript 6新增了使用胖箭头（ => ）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数：
```javascript
let arrowSum = (a, b) => { 
	return a + b; 
};
let functionExpressionSum = function(a, b) { 
	return a + b; 
};
console.log(arrowSum(5, 8)); // 13 
console.log(functionExpressionSum(5, 8)); // 13
```
箭头函数简洁的语法非常适合嵌入函数的场景：
```javascript
let ints = [1, 2, 3]; 
console.log(ints.map(function(i) { 
	return i + 1; 
})); // [2, 3, 4] 
console.log(ints.map((i) => { return i + 1 })); // [2, 3, 4]
```
如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号：
```javascript
// 以下两种写法都有效
let double = (x) => { return 2 * x; }; 
let triple = x => { return 3 * x; }; // 没有参数需要括号
let getRandom = () => { return Math.random(); }; // 多个参数需要括号
let sum = (a, b) => { return a + b; }; // 无效的写法：
let multiply = a, b => { return a * b; };
```
箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式。而且，省略大括号会隐式返回这行代码的值：
```javascript
// 以下两种写法都有效，而且返回相应的值
let double = (x) => { return 2 * x; }; 
let triple = (x) => 3 * x; // 可以赋值
let value = {}; 
let setName = (x) => x.name = "Matt"; setName(value); 
console.log(value.name); // "Matt"
// 无效的写法：
let multiply = (a, b) => return a * b;
```
箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 arguments 、 super 和 new.target ，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。
## 3、理解参数
定义函数时要接收两个参数，并不意味着调用时就传两个参数，你可以传一个、三个，甚至一个也不传，解释器都不会报错，主要是因为函数的参数在内部表现为一个数组。
在使用 function 关键字定义（非箭头）函数时，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值。
arguments 对象是一个类数组对象（但不是 Array 的实例），因此可以使用中括号语法访问其中的元素（第一个参数是arguments[0] ，第二个参数是 arguments[1] ）。而要确定传进来多少个参数，可以访问 arguments.length 属性。
例：
```javascript
function sayHi(name, message) { 
	console.log("Hello " + name + ", " + message);
}
```
可以通过 arguments[0] 取得相同的参数值。因此，把函数重写成不声明参数也可以：
```javascript
function sayHi() { 
	console.log("Hello " + arguments[0] + ", " + arguments[1]); 
	}
```
在重写后的代码中，没有命名参数。 name 和 message 参数都不见了，但函数照样可以调用。这就表明，ECMAScript函数的参数只是为了方便才写出来的，并不是必须写出来的。与其他语言不同，在ECMAScript中的命名参数不会创建让之后的调用必须匹配的函数签名。这是因为根本不存在验证命名参数的机制。
也可以通过 arguments 对象的 length 属性检查传入的参数个数。下面的例子展示了在每调用一个函数时，都会打印出传入的参数个数：
```javascript
function howManyArgs() { 
	console.log(arguments.length);
}
howManyArgs("string", 45); // 2 
howManyArgs(); // 0 
howManyArgs(12); // 1
```
## 4、箭头函数中的参数
如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。
```javascript
function foo() { 
	console.log(arguments[0]); 
}
foo(5); // 5 
let bar = () => { 
	console.log(arguments[0]); 
};
bar(5); // ReferenceError: arguments is not defined
```
虽然箭头函数中没有 arguments 对象，但可以在包装函数中把它提供给箭头函数：
```javascript
function foo() { 
	let bar = () => { 
		console.log(arguments[0]); // 5 
	};
	bar(); 
}
foo(5);
```
## 5、默认参数值
实现默认参数的一种常用方式就是检测某个参数是否等于 undefined ，如果是则意味着没有传这个参数，那就给它赋一个值：
```javascript
function makeKing(name) { 
	name = (typeof name !== 'undefined') ? name : 'Henry'; 
	return `King ${name} VIII`; 
}
console.log(makeKing()); // 'King Henry VIII' 
console.log(makeKing('Louis')); // 'King Louis VIII'
```
给参数传 undefined 相当于没有传值，不过这样可以利用多个独立的默认值：
```javascript
function makeKing(name = 'Henry', numerals = 'VIII') { 
	return `King ${name} ${numerals}`; 
}
console.log(makeKing()); // 'King Henry VIII' 
console.log(makeKing('Louis')); // 'King Louis VIII' 
console.log(makeKing(undefined, 'VI')); // 'King Henry VI'
```
在使用默认参数时， arguments 对象的值不反映参数的默认值，只反映传给函数的参数。当然，跟ES5严格模式一样，修改命名参数也不会影响 arguments 对象，它始终以调用函数时传入的值为准：
```javascript
function makeKing(name = 'Henry') { 
	name = 'Louis'; 
	return `King ${arguments[0]}`; 
}
console.log(makeKing()); // 'King undefined' 
console.log(makeKing('Louis')); // 'King Louis'
```
## 6、默认参数作用域与暂时性死区
因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的。给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。
```javascript
function makeKing(name = 'Henry', numerals = 'VIII') { 
	return `King ${name} ${numerals}`; 
}
console.log(makeKing()); // King Henry VIII
```
这里的默认参数会按照定义它们的顺序依次被初始化。可以依照示例想象一下这个过程：
```javascript
function makeKing() { 
	let name = 'Henry'; 
	let numerals = 'VIII';
	return `King ${name} ${numerals}`; 
}
```
因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。
## 7、收集参数
在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似 arguments 对象的构造机制，只不过收集参数的结果会得到一个 Array 实例。
```javascript
function getSum(...values) { 
	// 顺序累加values中的所有值 // 初始值的总和为0 
	return values.reduce((x, y) => x + y, 0); 
}
console.log(getSum(1,2,3)); // 6
```
收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：
```javascript
// 不可以
function getProduct(...values, lastValue) {} 
// 可以
function ignoreFirst(firstValue, ...values) { 
	console.log(values); 
}
ignoreFirst(); // [] 
ignoreFirst(1); // [] 
ignoreFirst(1,2); // [2] 
ignoreFirst(1,2,3); // [2, 3]
```
箭头函数虽然不支持 arguments 对象，但支持收集参数的定义方式，因此也可以实现与使用 arguments 一样的逻辑：
```javascript
let getSum = (...values) => { 
	return values.reduce((x, y) => x + y, 0); 
}
console.log(getSum(1,2,3)); // 6
```
另外，使用收集参数并不影响 arguments 对象，它仍然反映调用时传给函数的参数：
```javascript
function getSum(...values) { 
	console.log(arguments.length); // 3 
	console.log(arguments); // [1, 2, 3] 
	console.log(values); // [1, 2, 3] 
}
console.log(getSum(1,2,3));
```
## 7、arguments
arguments 对象前面讨论过多次了，它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的针。来看下面这个经典的阶乘函数：
```javascript
function factorial(num) { 
	if (num <= 1) { 
		return 1;
	} 
	else {
	 	return num * factorial(num - 1); 
	 }
 }
```
阶乘函数一般定义成递归调用的，就像上面这个例子一样。只要给函数一个名称，而且这个名称不会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是 factorial ，从而导致了紧密耦合。使用 arguments.callee 就可以让函数逻辑与函数名解耦：
```javascript
function factorial(num) { 
	if (num <= 1) { 
		return 1; 
	} else { 
		return num * arguments.callee(num - 1); 
	}
 }
```
这个重写之后的 factorial() 函数已经用arguments.callee 代替了之前硬编码的 factorial 。这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：
```javascript
let trueFactorial = factorial; 
factorial = function() { return 0; };
console.log(trueFactorial(5)); // 120 
console.log(factorial(5)); // 0
```
这里， trueFactorial 变量被赋值为 factorial ，实际上把同一个函数的指针又保存到了另一个位置。然后， factorial 函数又被重写为一个返回 0 的函数。如果像 factorial() 最初的版本那样不使用 arguments.callee ，那么像上面这样调用trueFactorial() 就会返回 0 。不过，通过将函数与名称解耦， trueFactorial() 就可以正确计算阶乘，而 factorial()则只能返回0。
## 8、caller
这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null 。比如：
```javascript
function outer() { 
	inner(); 
}
function inner() { 
	console.log(inner.caller); 
}
outer();
```
以上代码会显示 outer() 函数的源代码。这是因为ourter() 调用了 inner() ， inner.caller 指向outer() 。如果要降低耦合度，则可以通过arguments.callee.caller 来引用同样的值：
```javascript
function outer() { 
	inner(); 
}
function inner() { 
	console.log(arguments.callee.caller); 
}
outer();
```
在严格模式下访问 arguments.callee 会报错。ECMAScript 5也定义了 arguments.caller ，但在严格模式下访问它会报错，在非严格模式下则始终是 undefined 。这是为了分清arguments.caller 和函数的 caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码。
严格模式下还有一个限制，就是不能给函数的 caller 属性赋值，否则会导致错误。

## 9、递归
递归函数通常的形式是一个函数通过名称调用自己，如下面的例子所示：
```javascript
function factorial(num) { 
	if (num <= 1) { 
		return 1; 
	} else { 
		return num * factorial(num - 1); 
		} 
	}
```
这是经典的递归阶乘函数。虽然这样写是可以的，但如果把这个函数赋值给其他变量，就会出问题：
```javascript
let anotherFactorial = factorial; 
factorial = null;
console.log(anotherFactorial(4)); // 报错
```
这里把 factorial() 函数保存在了另一个变量anotherFactorial 中，然后将 factorial 设置为 null ，于
是只保留了一个对原始函数的引用。而在调用anotherFactorial() 时，要递归调用 factorial() ，但因为它已经不是函数了，所以会出错。在写递归函数时使用arguments.callee 可以避免这个问题。arguments.callee 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，如下所示：

```javascript
function factorial(num) { 
	if (num <= 1) { 
		return 1; 
	} else { 
		return num * arguments.callee(num - 1);//把函数名称替换成arguments.callee
	 } 
}
```
在编写递归函数时， arguments.callee 是引用当前函数的首选。不过，在严格模式下运行的代码是不能访问arguments.callee 的，因为访问会出错。此时，可以使用命名函数表达式（named function expression）达到目的。比如：
```javascript
const factorial = (function f(num) { 
	if (num <= 1) { 
		return 1; 
	} else { 
		return num * f(num - 1); 
	} 
});
```
这里创建了一个命名函数表达式 f() ，然后将它赋值给了变量factorial 。即使把函数赋值给另一个变量，函数表达式的名称f 也不变，因此递归调用不会有问题。这个模式在严格模式和非严格模式下都可以使用。
## 10、闭包
匿名函数经常被人误认为是闭包（closure）。闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction() 函数，注意其中加粗的代码：
```javascript
function createComparisonFunction(propertyName) { 
	return function(object1, object2) { 
		let value1 = object1[propertyName]; 
		let value2 = object2[propertyName]; 
		if (value1 < value2) {
			 return -1; 
		} else if (value1 > value2) { 
			return 1; 
		} else { 
		return 0; 
		} 
	}; 
}
```
这里加粗的代码位于内部函数（匿名函数）中，其中引用了外部函数的变量 propertyName 。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含 createComparisonFunction() 函数的作用域。要理解为什么会这样，可以想想第一次调用这个函数时会发生什么。
理解作用域链创建和使用的细节对理解闭包非常重要。在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用 arguments 和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。在函数执行时，要从作用域链中查找变量，以便读、写值。来看下面的代码：

```javascript
function compare(value1, value2) { 
	if (value1 < value2) { 
		return -1; 
	} else if (value1 > value2) { 
		return 1; 
		} else { 
		return 0; 
	} 
}
let result = compare(5, 10);
```
这里定义的 compare() 函数是在全局上下文中调用的。第一次调用 compare() 时，会为它创建一个包含 arguments 、value1 和 value2 的活动对象，这个对象是其作用域链上的第一个对象。而全局上下文的变量对象则是 compare() 作用域链上的第二个对象，其中包含 this 、 result 和 compare 。

# 第 11 章 期约与异步函数
## 1、异步编程
同步行为和异步行为的对立统一是计算机科学的一个基本概念。在JS这种单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。
### 1.1、同步与异步
同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行，而每条指令执行后也能立即获得存储在系统本地的信息。这样的执行流程容易分析程序在执行到代码任意位置时的状态。同步操作的例子可以是执行一次简单的数学计算：
```javascript
let x = 3;
x = x + 4;
```
#### 1.1.1
在程序执行的每一步，都可以推断出程序的状态。这是因为后面的指令总是在前面的指令完成后才会执行。等到最后一条指定执行完毕，存储在 x 的值就立即可以使用。
操作系统会在栈内存上分配一个存储浮点数值的空间，然后针对这个值做一次数学计算，再把计算结果写回之前分配的内存中。所有这些指令都是在单个线程中按顺序执行的。在低级指令的层面，有充足的工具可以确定系统状态。
#### 1.1.2
相对地，异步行为类似于系统中断，即当前进程外部的实体可以触发代码执行。异步操作经常是必要的，因为强制进程等待一个长时间的操作通常是不可行的（同步操作则必须要等）。如果代码要访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。
#### 1.1.3
异步操作的例子可以是在定时回调中执行一次简单的数学计算：
```javascript
let x = 3; 
setTimeout(() => x = x + 4, 1000);
```
### 1.2、以往的异步编程模式
异步行为是JavaScript的基础，但以前的实现不理想。在早期的JavaScript中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决。
假设有以下异步函数，使用了 setTimeout 在一秒钟之后执行某些操作：
```javascript
function double(value) { 
	setTimeout(() => setTimeout(
		console.log, 0, value * 2
	), 1000); 
}
double(3); // 6（大约1000毫秒之后）
```
 setTimeout 可以定义一个在指定时间之后会被调度执行的回调函数。对这个例子而言，1000毫秒之后，JavaScript运行时会把回调函数推到自己的消息队列上去等待执行。推到队列之后，回调什么时候出列被执行对JavaScript代码就完全不可见了。还有一点，double() 函数在 setTimeout 成功调度异步操作之后会立即退出。
#### 1.2.1、 异步返回值
假设 setTimeout 操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）。
```javascript
function double(value, callback) { 
	setTimeout(() => callback(value * 2), 1000); 
}
double(3, (x) => console.log(`I was given: ${x}`)); // I was given: 6（大约1000毫秒之后）
```
这里的 setTimeout 调用告诉JavaScript运行时在1000毫秒之后把一个函数推到消息队列上。这个函数会由运行时负责异步调度执行。而位于函数闭包中的回调及其参数在异步执行时仍然是可用的。
#### 1.2.2、失败处理
异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调：
```javascript
function double(value, success, failure) { 
	setTimeout(() => { 
		try { 
			if (typeof value !== 'number') { 
				throw 'Must provide number as first argument'; 
			}
			success(2 * value); 
		} catch (e) { 
			failure(e); 
		} 
	}, 1000); 
}
const successCallback = (x) =>console.log(`Success: ${x}`);
const failureCallback = (e) => console.log(`Failure: ${e}`); 
double(3, successCallback, failureCallback); 
double('b', successCallback, failureCallback); 
// Success: 6（大约1000毫秒之后）
// Failure: Must provide number as first argument（大约1000毫秒之后）
```
这种模式已经不可取了，因为必须在初始化异步操作时定义回调。异步函数的返回值只在短时间内存在，只有预备好将这个短时间内存在的值作为参数的回调才能接收到它。
#### 1.2.3、嵌套异步回调
如果异步返值又依赖另一个异步返回值，那么回调的情况还会进一步变复杂。在实际的代码中，这就要求嵌套回调：
```javascript
function double(value, success, failure) { 
	setTimeout(() => { 
		try { 
			if (typeof value !== 'number') { 
				throw 'Must provide number as first argument'; 
			}
			success(2 * value); 
		} catch (e) {
			failure(e); 
		} 
	}, 1000); 
}
const successCallback = (x) => { 
	double(x, (y) => console.log(`Success: ${y}`)); 
};
const failureCallback = (e) => console.log(`Failure: ${e}`); 
double(3, successCallback, failureCallback); // Success: 12（大约1000毫秒之后）
```
显然，随着代码越来越复杂，回调策略是不具有扩展性的。“回调地狱”这个称呼可谓名至实归。嵌套回调的代码维护起来就是噩梦。
## 2、期约
Promise成为了主导性的异步编程机制。
### 2.1、期约基础
ECMAScript 6新增的引用类型 Promise ，可以通过 new 操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数，下面的例子使用了一个空函数对象来应付解释器：
```javascript
let p = new Promise(() => {}); 
setTimeout(console.log, 0, p); // Promise <pending>
```
之所以说是应付解释器，是因为如果不提供执行器函数，就会抛出 SyntaxError 。
#### 2.1.1、期约状态机
在把一个期约实例传给 console.log() 时，控制台输出表明该实例处于待定（pending）状态。如前所述，期约是一个有状态的对象，可能处于如下3种状态之一：
待定（pending）
兑现（fulfilled，有时候也称为“解决”，resolved）
拒绝（rejected）
待定（pending）是期约的最初始状态。在待定状态下，期约可以落定（settled）为代表成功的兑现（fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定状态。因此，组织合理的代码无论期约解决（resolve）还是拒绝（reject），甚至永远处于待定（pending）状态，都应该具有恰当的行为。
重要的是，期约的状态是私有的，不能直接通过JavaScript检测到。这主要是为了避免根据读取到的期约状态，以同步方式处理期约对象。另外，期约的状态也不能被外部JavaScript代码修改。这与不能读取该状态的原因是一样的：期约故意将异步行为封装起来，从而隔离外部的同步代码。
#### 2.1.2、解决值、拒绝理由及期约用例
##### 2.1.2.1
期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。“待定”表示尚未开始或者正在执行中。“兑现”表示已经成功完成，而“拒绝”则表示没有成功完成。某些情况下，这个状态机就是期约可以提供的最有用的信息。知道一段异步代码已经完成，对于其他代码而言已经足够了。比如，假设期约要向服务器发送一个HTTP请求。请求返回200-299范围内的状态码就足以让期约的状态变为“兑现”。类似地，如果请求返回的状态码不在200~299这个范围内，那么就会把期约状态切换为“拒绝”。
##### 2.1.2.2
在另外一些情况下，期约封装的异步操作会实际生成某个值，而程序期待期约状态改变时可以访问这个值。相应地，如果期约被拒绝，程序就会期待期约状态改变时可以拿到拒绝的理由。比如，假设期约向服务器发送一个HTTP请求并预定会返回一个JSON。如果请求返回范围在200-299的状态码，则足以让期约的状态变为兑现。此时期约内部就可以收到一个JSON字符串。类似地，如果请求返回的状态码不在200~299这个范围内，那么就会把期约状态切换为拒绝。此时拒绝的理由可能是一个 Error 对象，包含着HTTP状态码及相关错误消息。
##### 2.1.2.3
为了支持这两种用例，每个期约只要状态切换为兑现，就会有一个私有的内部值（value）。类似地，每个期约只要状态切换为拒绝，就会有一个私有的内部理由（reason）。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined 。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。
#### 2.1.3、通过执行函数控制期约状态
由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数参数通常都命名为 resolve() 和 reject() 。调用 resolve() 会把状态切换为兑现，调用 reject() 会把状态切换为拒绝。另外，调用 reject() 也会抛出错误（后面会讨论这个错误）。
```javascript
let p1 = new Promise((resolve, reject) => resolve()); 
setTimeout(console.log, 0, p1); // Promise <resolved> 
let p2 = new Promise((resolve, reject) => reject()); 
setTimeout(console.log, 0, p2); // Promise <rejected> 
// Uncaught error (in promise)
```
在前面的例子中，并没有什么异步操作，因为在初始化期约时，执行器函数已经改变了每个期约的状态。这里的关键在于，执行器函数是同步执行的。这是因为执行器函数是期约的初始化程序。通过下面的例子可以看出上面代码的执行顺序：
```javascript
new Promise(() => setTimeout(console.log, 0, 'executor')); 
setTimeout(console.log, 0, 'promise initialized'); // executor 
// promise initialized
```
添加 setTimeout 可以推迟切换状态：
```javascript
let p = new Promise((resolve, reject) => setTimeout(resolve, 1000));
// 在console.log打印期约实例的时候，还不会执行超时回调（即resolve()） 
setTimeout(console.log, 0, p); // Promise <pending>
```
无论 resolve() 和 reject() 中的哪个被调用，状态转换都不可撤销了。于是继续修改状态会静默失败，如下所示：
```javascript
let p = new Promise((resolve, reject) => { 
	resolve(); 
	reject(); // 没有效果
}); 
setTimeout(console.log, 0, p); // Promise <resolved>
```
为避免期约卡在待定状态，可以添加一个定时退出功能。比如，可以通过 setTimeout 设置一个10秒钟后无论如何都会拒绝期约的回调：
```javascript
let p = new Promise((resolve, reject) => { 
	setTimeout(reject, 10000); // 10秒后调用
	reject() // 执行函数的逻辑
}); 
setTimeout(console.log, 0, p); // Promise <pending> 
setTimeout(console.log, 11000, p); // 11秒后再检查状态
// (After 10 seconds) Uncaught error
// (After 11 seconds) Promise <rejected>
```
因为期约的状态只能改变一次，所以这里的超时拒绝逻辑中可以放心地设置让期约处于待定状态的最长时间。如果执行器中的代码在超时之前已经解决或拒绝，那么超时回调再尝试拒绝也会静默失败。
#### 2.1.4、Promise.resolve()
期约并非一开始就必须处于待定状态，然后通过执行器函数才能转换为落定状态。通过调用 Promise.resolve() 静态方法，可以实例化一个解决的期约。下面两个期约实例实际上是一样的：
```javascript
let p1 = new Promise((resolve, reject) => resolve()); 
let p2 = Promise.resolve();
```
这个解决的期约的值对应着传给 Promise.resolve() 的第一个参数。使用这个静态方法，实际上可以把任何值都转换为一个期约：
```javascript
setTimeout(console.log, 0, Promise.resolve()); 
// Promise <resolved>: undefined
setTimeout(console.log, 0, Promise.resolve(3));
// Promise <resolved>: 3 // 多余的参数会忽略
setTimeout(console.log, 0, Promise.resolve(4, 5, 6)); 
// Promise <resolved>: 4
```
对这个静态方法而言，如果传入的参数本身是一个期约，那它的行为就类似于一个空包装。因此， Promise.resolve() 可以说是一个幂等方法，如下所示：
```javascript
let p = Promise.resolve(7); 
setTimeout(console.log, 0, p === Promise.resolve(p)); // true 
setTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p))); // true
```
这个幂等性会保留传入期约的状态：
```javascript
let p = new Promise(() => {}); 
setTimeout(console.log, 0, p); // Promise <pending> 
setTimeout(console.log, 0, Promise.resolve(p)); // Promise <pending>
setTimeout(console.log, 0, p === Promise.resolve(p)); // true
```
注意，这个静态方法能够包装任何非期约值，包括错误对象，并将其转换为解决的期约。因此，也可能导致不符合预期的行为：
```javascript
let p = Promise.resolve(new Error('foo')); 
setTimeout(console.log, 0, p); // Promise <resolved>: Error: foo
```
#### 2.1.5、Promise.reject()
与 Promise.resolve() 类似， Promise.reject() 会实例化一个拒绝的期约并抛出一个异步错误（这个错误不能通过try / catch 捕获，而只能通过拒绝处理程序捕获）。下面的两个期约实例实际上是一样的：
```javascript
let p1 = new Promise((resolve, reject) => reject()); 
let p2 = Promise.reject();
```
这个拒绝的期约的理由就是传给 Promise.reject() 的第一个参数。这个参数也会传给后续的拒绝处理程序：
```javascript
let p = Promise.reject(3); 
setTimeout(console.log, 0, p); // Promise <rejected>: 3
p.then(null, (e) => setTimeout(console.log, 0, e)); // 3
```
关键在于， Promise.reject() 并没有照搬Promise.resolve() 的幂等逻辑。如果给它传一个期约对象，则这个期约会成为它返回的拒绝期约的理由：
```javascript
setTimeout(console.log, 0, Promise.reject(Promise.resolve())); 
// Promise <rejected>: Promise <resolved>
```
#### 2.1.6、 同步/异步执行的二元性
Promise 的设计很大程度上会导致一种完全不同于JavaScript的计算模式。下面的例子完美地展示了这一点，其中包含了两种模式下抛出错误的情形：
```javascript
try { 
	throw new Error('foo'); 
} catch(e) { 
	console.log(e); // Error: foo 
}try { 
	Promise.reject(new Error('bar'));
} catch(e) { 
	console.log(e); // Uncaught (in promise) Error: bar
}
```
第一个 try / catch 抛出并捕获了错误，第二个 try / catch抛出错误却没有捕获到。乍一看这可能有点违反直觉，因为代码中确实是同步创建了一个拒绝的期约实例，而这个实例也抛出了包含拒绝理由的错误。这里的同步代码之所以没有捕获期约抛出的错误，是因为它没有通过异步模式捕获错误。从这里就可以看出期约真正的异步特性：它们是同步对象（在同步执行模式中使用），但也是异步执行模式的媒介。
在前面的例子中，拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try / catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。
### 2.2、期约的实例方法
期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁。这些方法可以访问异步操作返回的数据，处理期约成功和失败的输出，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。
#### 2.2.1、实现 Thenable 接口
在ECMAScript暴露的异步结构中，任何对象都有一个 then()方法。这个方法被认为实现了 Thenable 接口。下面的例子展示了实现这一接口的最简单的类：
```javascript
class MyThenable { then() {} }
```
ECMAScript的 Promise 类型实现了 Thenable 接口。这个简化的接口跟TypeScript或其他包中的接口或类型定义不同，它们都设定了 Thenbale 接口更具体的形式。
#### 2.2.2、Promise.prototype.then()
Promise.prototype.then() 是为期约实例添加处理程序的主要方法。这个 then() 方法接收最多两个参数：onResolved 处理程序和 onRejected 处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入“兑现”和“拒绝”状态时执行。
```javascript
function onResolved(id) { 
	setTimeout(console.log, 0, id, 'resolved'); 
}
function onRejected(id) { 
	setTimeout(console.log, 0, id, 'rejected'); 
}
let p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) => setTimeout(reject, 3000)); p1.then(() => onResolved('p1'), () => onRejected('p1')); 
p2.then(() => onResolved('p2'),() => onRejected('p2'));
//（3秒后）
// p1 resolved 
// p2 rejected
```
因为期约只能转换为最终状态一次，所以这两个操作一定是互斥的。
如前所述，两个处理程序参数都是可选的。而且，传给 then()的任何非函数类型的参数都会被静默忽略。如果想只提供onRejected 参数，那就要在 onResolved 参数的位置上传入 undefined 。这样有助于避免在内存中创建多余的对象，对期待函数参数的类型系统也是一个交代。
```javascript
function onResolved(id) { 
	setTimeout(console.log, 0, id, 'resolved'); 
}
function onRejected(id) { 
	setTimeout(console.log, 0, id, 'rejected'); 
}
let p1 = new Promise((resolve, reject) => setTimeout(resolve, 3000)); let p2 = new Promise((resolve, reject) => setTimeout(reject, 3000)); 
// 非函数处理程序会被静默忽略，不推荐
p1.then('gobbeltygook');
// 不传onResolved处理程序的规范写法
p2.then(null, () => onRejected('p2')); // p2 rejected（3秒后）
```
Promise.prototype.then() 方法返回一个新的期约实例：
```javascript
let p1 = new Promise(() => {}); 
let p2 = p1.then(); 
setTimeout(console.log, 0, p1); // Promise <pending>
setTimeout(console.log, 0, p2); // Promise <pending> 
setTimeout(console.log, 0, p1 === p2); // false
```
这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，该处理程序的返回值会通过 Promise.resolve() 包装来生成新期约。如果没有提供这个处理程序，则Promise.resolve() 就会包装上一个期约解决之后值。如果没有显式的返回语句，则 Promise.resolve() 会包装默认的返回值 undefined 。
```javascript
let p1 = Promise.resolve('foo'); 
// 若调用then()时不传处理程序，则原样向后传
let p2 = p1.then(); 
setTimeout(console.log, 0, p2); 
// Promise<resolved>: foo // 这些都一样
let p3 = p1.then(() => undefined); 
let p4 = p1.then(() => {}); 
let p5 = p1.then(() => Promise.resolve()); 
setTimeout(console.log, 0, p3); // Promise <resolved>: undefined 
setTimeout(console.log, 0, p4); // Promise <resolved>: undefined 
setTimeout(console.log, 0, p5); // Promise <resolved>: undefined
```
如果有显式的返回值，则 Promise.resolve() 会包装这个值：
```javascript
... 
// 这些都一样
let p6 = p1.then(() => 'bar'); 
let p7 = p1.then(() => Promise.resolve('bar')); 
setTimeout(console.log, 0, p6); // Promise <resolved>: bar 
setTimeout(console.log, 0, p7); // Promise <resolved>: bar
// Promise.resolve()保留返回的期约
let p8 = p1.then(() => new Promise(() => {})); 
let p9 = p1.then(() => Promise.reject()); 
// Uncaught (in promise): undefined
setTimeout(console.log, 0, p8); // Promise <pending> 
setTimeout(console.log, 0, p9); // Promise <rejected>: undefined
```
抛出异常会返回拒绝的期约：
```javascript
... 
let p10 = p1.then(() => { throw 'baz'; }); 
// Uncaught (in promise) baz
setTimeout(console.log, 0, p10); 
// Promise <rejected> baz
```
注意，返回错误值不会触发上面的拒绝行为，而会把错误对象包装在一个解决的期约中：
```javascript
... 
let p11 = p1.then(() => Error('qux'));
setTimeout(console.log, 0, p11); // Promise <resolved>: Error: qux
```
onRejected 处理程序也与之类似： onRejected 处理程序返回的值也会被 Promise.resolve() 包装。乍一看这可能有点违反直觉，但是想一想， onRejected 处理程序的任务不就是捕获异步错误吗？因此，拒绝处理程序在捕获错误后不抛出异常是符合期约的行为，应该返回一个解决期约。
下面的代码片段展示了用 Promise.reject() 替代之前例子中的 Promise.resolve() 之后的结果：
```javascript
let p1 = Promise.reject('foo'); 
// 调用then()时不传处理程序则原样向后传
let p2 = p1.then(); 
// Uncaught (in promise) foo
setTimeout(console.log, 0, p2); 
// Promise <rejected>: foo // 这些都一样
let p3 = p1.then(null, () => undefined); 
let p4 = p1.then(null, () => {}); 
let p5 = p1.then(null, () => Promise.resolve()); 
setTimeout(console.log, 0, p3); // Promise <resolved>: undefined
setTimeout(console.log, 0, p4); // Promise <resolved>: undefined 
setTimeout(console.log, 0, p5); // Promise <resolved>: undefined 
// 这些都一样
let p6 = p1.then(null, () => 'bar'); 
let p7 = p1.then(null, () => Promise.resolve('bar')); setTimeout(console.log, 0, p6); // Promise <resolved>: bar 
setTimeout(console.log, 0, p7); // Promise <resolved>: bar 
// Promise.resolve()保留返回的期约
let p8 = p1.then(null, () => new Promise(() => {})); 
let p9 = p1.then(null, () => Promise.reject()); 
// Uncaught (in promise): undefined
setTimeout(console.log, 0, p8); // Promise <pending> 
setTimeout(console.log, 0, p9); // Promise <rejected>: undefined
let p10 = p1.then(null, () => { throw 'baz'; }); 
// Uncaught (in promise) baz
setTimeout(console.log, 0, p10); // Promise <rejected>: baz 
let p11 = p1.then(null, () => Error('qux')); 
setTimeout(console.log, 0, p11); // Promise <resolved>: Error: qux
```
#### 2.2.3、Promise.prototype.catch()
Promise.prototype.catch() 方法用于给期约添加拒绝处理程序。这个方法只接收一个参数： onRejected 处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用Promise.prototype.then(null, onRejected) 。下面的代码展示了这两种同样的情况：
```javascript
let p = Promise.reject(); 
let onRejected = function(e) { 
	setTimeout(console.log, 0, 'rejected'); 
};
// 这两种添加拒绝处理程序的方式是一样的：
p.then(null, onRejected);
// rejected p.catch(onRejected); 
// rejected
```
Promise.prototype.catch() 返回一个新的期约实例：
```javascript
let p1 = new Promise(() => {}); 
let p2 = p1.catch(); 
setTimeout(console.log, 0, p1); // Promise <pending> 
setTimeout(console.log, 0, p2); // Promise <pending> 
setTimeout(console.log, 0, p1 === p2); // false
```
在返回新期约实例方面， Promise.prototype.catch() 的行为与 Promise.prototype.then() 的 onRejected 处理程序是一样的。
#### 2.2.4、Promise.prototype.finally()
Promise.prototype.finally() 方法用于给期约添加onFinally 处理程序，这个处理程序在期约转换为解决或拒绝状态时都会执行。这个方法可以避免 onResolved 和 onRejected 处理程序中出现冗余代码。但 onFinally 处理程序没有办法知道期约的状态是解决还是拒绝，所以这个方法主要用于添加清理代码。
```javascript
let p1 = Promise.resolve(); 
let p2 = Promise.reject();
let onFinally = function() { 
	setTimeout(console.log, 0, 'Finally!') 
}
p1.finally(onFinally); // Finally
p2.finally(onFinally); // Finally
```
Promise.prototype.finally() 方法返回一个新的期约实例：
```javascript
let p1 = new Promise(() => {}); 
let p2 = p1.finally(); 
setTimeout(console.log, 0, p1); // Promise <pending> 
setTimeout(console.log, 0, p2); // Promise <pending> 
setTimeout(console.log, 0, p1 === p2); // false
```
这个新期约实例不同于 then() 或 catch() 方式返回的实例。因为 onFinally 被设计为一个状态无关的方法，所以多数情况下它都会原样后传父期约。无论父期约是解决还是拒绝，都会原样后传。
```javascript
let p1 = Promise.resolve('foo'); // 这里都会原样后传
let p2 = p1.finally(); 
let p3 = p1.finally(() => undefined);
let p4 = p1.finally(() => {}); 
let p5 = p1.finally(() => Promise.resolve()); 
let p6 = p1.finally(() => 'bar'); 
let p7 = p1.finally(() => Promise.resolve('bar')); 
let p8 = p1.finally(() => Error('qux')); 
setTimeout(console.log, 0, p2); // Promise <resolved>: foo 
setTimeout(console.log, 0, p3); // Promise <resolved>: foo 
setTimeout(console.log, 0, p4); // Promise <resolved>: foo 
setTimeout(console.log, 0, p5); // Promise <resolved>: foo 
setTimeout(console.log, 0, p6); // Promise <resolved>: foo 
setTimeout(console.log, 0, p7); // Promise <resolved>: foo 
setTimeout(console.log, 0, p8); // Promise <resolved>: foo
```
如果返回的是一个待定的期约，或者 onFinally 处理程序抛出了错误（显式抛出或返回了一个拒绝期约），则会返回相应的期约（待定或拒绝），如下所示：
```javascript
... 
// Promise.resolve()保留返回的期约
let p9 = p1.finally(() => new Promise(() => {})); 
let p10 = p1.finally(() => Promise.reject()); 
// Uncaught (in promise): undefined
setTimeout(console.log, 0, p9); // Promise <pending> 
setTimeout(console.log, 0, p10); 
// Promise <rejected>: undefined 
let p11 = p1.finally(() => { throw 'baz'; }); 
// Uncaught (in promise) baz
setTimeout(console.log, 0, p11); // Promise <rejected>: baz
```
返回待定期约的情形并不常见，这是因为只要期约一解决，新期约仍然会原样后传初始的期约：
```javascript
let p1 = Promise.resolve('foo'); // 忽略解决的值
let p2 = p1.finally( () => new Promise((resolve, reject) => setTimeout(() => resolve('bar'), 100))); 
setTimeout(console.log, 0, p2); // Promise <pending>
setTimeout(() => setTimeout(console.log, 0, p2), 200); 
// 200毫秒后：
// Promise <resolved>: foo
```
#### 2.2.5、邻近处理程序的执行顺序
如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 then() 、 catch() 还是 finally() 添加的处理程序都是如此。
```javascript
let p1 = Promise.resolve(); 
let p2 = Promise.reject(); 
p1.then(() => setTimeout(console.log, 0, 1)); // 1 
p1.then(() => setTimeout(console.log, 0, 2)); // 2 
p2.then(null, () => setTimeout(console.log,0, 3)); // 3 
p2.then(null, () => setTimeout(console.log, 0, 4));// 4 
p2.catch(() => setTimeout(console.log, 0, 5)); // 5
p2.catch(() => setTimeout(console.log, 0, 6)); // 6 
p1.finally(() => setTimeout(console.log, 0, 7)); // 7 
p1.finally(() => setTimeout(console.log, 0, 8)); // 8
```
#### 2.2.6、传递解决值和拒绝理由
到了落定状态后，期约会提供其解决值（如果兑现）或其拒绝理由（如果拒绝）给相关状态的处理程序。拿到返回值后，就可以进一步对这个值进行操作。比如，第一次网络请求返回的JSON是发送第二次请求必需的数据，那么第一次请求返回的值就应该传给 onResolved 处理程序继续处理。当然，失败的网络请求也应该把HTTP状态码传给 onRejected 处理程序。
在执行函数中，解决的值和拒绝的理由是分别作为 resolve() 和 reject() 的第一个参数往后传的。然后，这些值又会传给它们各自的处理程序，作为 onResolved 或 onRejected 处理程序的唯一参数。下面的例子展示了上述传递过程：
```javascript
let p1 = new Promise((resolve, reject) => resolve('foo')); p1.then((value) => console.log(value)); // foolet 
p2 = new Promise((resolve, reject) => reject('bar')); 
p2.catch((reason) => console.log(reason)); // bar
```
Promise.resolve() 和 Promise.reject() 在被调用时就会接收解决值和拒绝理由。同样地，它们返回的期约也会像执行器一样把这些值传给 onResolved 或 onRejected 处理程序：
```javascript
let p1 = Promise.resolve('foo'); 
p1.then((value) => console.log(value)); // foolet 
p2 = Promise.reject('bar'); 
p2.catch((reason) => console.log(reason)); // bar
```
## 3、异步函数
异步函数，也称为“async/await”（语法关键字），是ES6期约模式在ECMAScript函数中的应用。async/await是ES8规范新增的。这个特性从行为和语法上都增强了JavaScript，让以同步方式写的代码能够异步执行。下面来看一个最简单的例子，这个期约在超时之后会解决为一个值：
```javascript
let p = new Promise((resolve, reject) => 
setTimeout(resolve, 1000, 3));
```
这个期约在1000毫秒之后解决为数值3。如果程序中的其他代码要在这个值可用时访问它，则需要写一个解决处理程序：
```javascript
let p = new Promise((resolve, reject) => 
setTimeout(resolve, 1000, 3)); 
p.then((x) => console.log(x)); // 3
```
这其实是很不方便的，因为其他代码都必须塞到期约处理程序中。不过可以把处理程序定义为一个函数：
```javascript
function handler(x) { 
	console.log(x); 
} 
let p = new Promise((resolve, reject) => 
setTimeout(resolve, 1000, 3)); 
p.then(handler); // 3
```
这个改进其实也不大。这是因为任何需要访问这个期约所产生值的代码，都需要以处理程序的形式来接收这个值。也就是说，代码照样还是要放到处理程序里。ES8为此提供了async/await关键字。
#### 3.1、异步函数
ES8的async/await旨在解决利用异步结构组织代码的问题。为此，ECMAScript对函数进行了扩展，为其增加了两个新关键字： async 和await。
##### 3.1.1、async
async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：
```javascript
async function foo() {} 
let bar = async function() {}; 
let baz = async () => {}; 
class Qux { async qux() {} }
```
使用 async 关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通JavaScript函数的正常行为。正如下面的例子所示， foo() 函数仍然会在后面的指令之前被求值：
```javascript
async function foo() { 
	console.log(1); 
}
foo(); 
console.log(2); 
// 1 
// 2
```
不过，异步函数如果使用 return 关键字返回了值（如果没有return 则会返回 undefined ），这个值会被Promise.resolve() 包装成一个期约对象。异步函数始终返回期约对象。在函数外部调用这个函数可以得到它返回的期约：
```javascript
async function foo() { 
	console.log(1); 
	return 3; 
}
// 给返回的期约添加一个解决处理程序
foo().then(console.log); 
console.log(2); 
// 1 
// 2 
// 3
```
当然，直接返回一个期约对象也是一样的：
```javascript
async function foo() { 
	console.log(1); 
	return Promise.resolve(3); 
}
// 给返回的期约添加一个解决处理程序
foo().then(console.log);
console.log(2); 
// 1 
// 2 
// 3
```
异步函数的返回值期待（但实际上并不要求）一个实现thenable 接口的对象，但常规的值也可以。如果返回的是实现 thenable 接口的对象，则这个对象可以由提供给 then()的处理程序“解包”。如果不是，则返回值就被当作已经解决的期约。下面的代码演示了这些情况：
```javascript
// 返回一个原始值
async function foo() { 
	return 'foo'; 
}
foo().then(console.log); // foo 
// 返回一个没有实现thenable接口的对象
async function bar() { 
	return ['bar']; 
}
bar().then(console.log); 
// ['bar'] 
// 返回一个实现了thenable接口的非期约对象
async function baz() { 
	const thenable = {
		then(callback) { 
			callback('baz'); 
			} 
		};
		return thenable; 
	}
	baz().then(console.log); // baz // 返回一个期约
	async function qux() { 
		return Promise.resolve('qux'); 
	}
	qux().then(console.log); // qux
```
与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：
```javascript
async function foo() {
	console.log(1); 
	throw 3; 
}
// 给返回的期约添加一个拒绝处理程序
foo().catch(console.log); 
console.log(2); 
// 1 
// 2 
// 3
```
不过，拒绝期约的错误不会被异步函数捕获：
```javascript
async function foo() { 
	console.log(1); 
	Promise.reject(3); 
}
// Attach a rejected handler to the returned
promise foo().catch(console.log); 
console.log(2); 
// 1 
// 2 
// Uncaught (in promise): 3
```
##### 3.1.2、await
因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。例子：
```javascript
let p = new Promise((resolve, reject) => 
setTimeout(resolve, 1000, 3)); 
p.then((x) => console.log(x)); 
// 3
```
使用async/await可以写成这样：
```javascript
async function foo() { 
	let p = new Promise((resolve, reject) => 
	setTimeout(resolve, 1000, 3)); 
	console.log(await p); 
}
foo(); 
// 3
```
注意， await 关键字会暂停执行异步函数后面的代码，让出JavaScript运行时的执行线程。这个行为与生成器函数中的yield 关键字是一样的。 await 关键字同样是尝试“解包”对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。await 关键字的用法与JavaScript的一元操作一样。它可以单独使用，也可以在表达式中使用，如下面的例子所示：
```javascript
// 异步打印"foo" 
async function foo() { 
	console.log(await Promise.resolve('foo')); 
}
foo(); // foo // 异步打印"bar" 
async function bar() { return await Promise.resolve('bar'); }
bar().then(console.log); // bar // 1000毫秒后异步打印"baz" 
async function baz() { 
	await new Promise((resolve, reject) => 
	setTimeout(resolve, 1000));
	console.log('baz'); 
}
baz(); // baz（1000毫秒后）
```
await 关键字期待（但实际上并不要求）一个实现 thenable接口的对象，但常规的值也可以。如果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作已经解决的期约。下面的代码演示了这些情况：
```javascript
// 等待一个原始值
async function foo() { 
	console.log(await 'foo'); 
}
foo(); // foo // 等待一个没有实现thenable接口的对象
async function bar() { 
	console.log(await ['bar']); 
}
bar();
// ['bar'] // 等待一个实现了thenable接口的非期约对象
async function baz() { 
	const thenable = { 
		then(callback) { 
			callback('baz'); 
		} 
	};
	console.log(await thenable); 
}
baz(); // baz // 等待一个期约
async function qux() { 
	console.log(await Promise.resolve('qux')); 
}
qux(); // qux
```
等待会抛出错误的同步操作，会返回拒绝的期约：
```javascript
async function foo() { 
	console.log(1); 
	await (() => { 
		throw 3; 
	})();
}
// 给返回的期约添加一个拒绝处理程序
foo().catch(console.log); 
console.log(2);
// 1 
// 2 
// 3
```
如前面的例子所示，单独的 Promise.reject() 不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用await 则会释放（unwrap）错误值（将拒绝期约返回）：
```javascript
async function foo() { 
	console.log(1); 
	await Promise.reject(3); 
	console.log(4); // 这行代码不会执行
}
// 给返回的期约添加一个拒绝处理程序
foo().catch(console.log); 
console.log(2); 
// 1 
// 2 
// 3
```
##### 3.1.3、await 的限制
await 关键字必须在异步函数中使用，不能在顶级上下文如script标签或模块中使用。不过，定义并立即调用异步函数是没问题的。下面两段代码实际是相同的：
```javascript
async function foo() { 
	console.log(await Promise.resolve(3)); 
}foo(); 
// 3 
// 立即调用的异步函数表达式
(async function() { 
	console.log(await Promise.resolve(3)); 
})(); // 3
```
此外，异步函数的特质不会扩展到嵌套函数。因此， await 关键字也只能直接出现在异步函数的定义中。在同步函数内部使用await 会抛出 SyntaxError 。