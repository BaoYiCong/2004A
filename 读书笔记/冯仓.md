第1章 什么是JavaScript 
==================================

## 什么是JavaScript

- JavaScript（通常缩写为JS）是一种高级的、解释型的编程语言；它是一门基于原型、函数先行的语言，是一门多范式的语言，它支持面向对象编程，命令式编程，以及函数式编程。
- 除了HTML和CSS, JavaScript是万维网的核心技术之一。JavaScript支持交互式web页面，是web应用程序的重要组成部分。绝大多数网站都使用它，主要的网络浏览器都有专门的JavaScript引擎来执行它。
- 作为一种多范式语言，JavaScript支持事件驱动，功能和命令式（包括面向对象和基于原型）的编程风格。
- 它具有用于处理文本，数组，日期，正则表达式和DOM的API，但语言本身不包含任何I / O，例如网络，存储或图形工具。它依赖于嵌入它的主机环境来提供这些功能。

JavaScript也就是我们常说的JS，或者说是JS脚本。

## 发展历程



- 1997年7月，ECMAScript 1.0发布。
- 1998年6月，ECMAScript 2.0版发布。
- 1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。
- 2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。
- 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。
- 2009年12月，ECMAScript 5.0版 正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。第六版发布以后，将指 ECMAScript 7。TC39 预计，ECMAScript 5 会在2013年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。
- 2011年6月，ECMAScript 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。
- 2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。
- 2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。
- 2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在2016年发布，称为“ECMAScript 2016”，2017年发布“ECMAScript 2017”，以此类推。

## 语言特点

JavaScript脚本语言具有以下特点:

- 解释性：javascript是一种解释语言，源代码不需要经过编译，直接在浏览器上运行时被解释。
- 基于对象：javascripth是一种基于对象的语言，能运用自己已经创建了的对象，许多功能可以来自于脚本环境中对象的方法与脚本的相互作用。
- 事件驱动：JavaScript可以直接对用户或客户输入做出响应，无需经过web服务程序。他对用户的响应，是以事件驱动的方式进行的，所谓事件驱动，指的是在主页执行了某种操作所产生的动作，此动作称为“事件”。
- 跨平台：JavaScript依赖于浏览器本身，与操作环境无关。只要能运行浏览器的计算机，并支持JavaScript的浏览器就可以正确执行。



- 安全性：JavaScript是一种安全性语言。它不允许访问本地的磁盘，并不能将数据存入服务器上；不允许对网络文本进行修改和删除，只能通过浏览器实现信息浏览或动态交互。可有效的防止数据丢失。

## JavaScript能做什么？



- 使网页具有交互性，例如响应用户点击，给用户提供更好的体验
- 可以处理表单，检验用户的输入，并提供及时反馈节省用户时间。例如，表单中要你输入电子邮箱而你却输入一个手机号，那么应该给你一个提醒。
- 还可以根据用户的操作，动态的创建页面。例如，发邮件时，添加附件操作。
- 设置cookie，cookie是存储在浏览器上的一些临时信息，例如你浏览过的网站地址，使用过的用户名
- JavaScript 使有规律地重复的HTML文段简化，减少下载时间。
- 浏览器与服务器进行数据通讯，比如现在最流行的Ajax异步传输；
- 更丰富的界面，可以使用JavaScript来包含诸如拖放组件和滑块之类的项目，以便为您的站点访问者提供丰富的界面。
- 可以制作游戏，微信端小游戏基本都是js写的。
- 基于Node.js技术进行服务器端编程。



## **举例**

这是一个精美的网页，我们可以看到我们鼠标在悬浮于表格，点击按钮时都有各种响应。



当我们把JS去掉

表格的特效都消失了，虽然网页的整体结构还在，但是已经黯然失色了。



我们把CSS去掉

只剩下HTML的标签了，页面布局都消失了。



**总结**

如果说HTML是网页的结构，表示网页中有什么（表格，按钮，标签），CSS是美化网页，表示网页长什么样。

那么JavaScript就是网页的灵魂，决定这个这个网页最终能实现什么功能。

## JavaScript与Java、ECMASCript的关系

1. **Java与JavaScript的关系**

引用网上一个比较流程的比喻

一般认为，当时 Netscape 之所以将 LiveScript 命名为 JavaScript，是因为 Java 是当时最流行的编程语言，带有 “Java” 的名字有助于这门新生语言的传播。

它们的相同之处包括：

- 它们的语法和 C 语言都很相似；
- 它们都是面向对象的（虽然实现的方式略有不同）；
- JavaScript 在设计时参照了 Java 的命名规则；

它们的不同之处包括：

- JavaScript 是动态类型语言，而 Java 是静态类型语言；
- JavaScript 是弱类型的，Java 属于强类型；
- JavaScript 的面向对象是基于原型的（prototype-based）实现的，Java 是基于类（class-based）的；

JavaScript 除了长得和 Java 比较像之外，语言风格相去甚远。JavaScript 在设计时所参考的对象不包括 Java，而包括了像 Self 和 Scheme 这样的语言。

1. **JavaScript和ECMAScript的关系**

ECMAScript是JavaScript的规格，JavaScript是ECMAScript的一种实现，在日常场合，这两个词是可以互换的。

JavaScript的创造者Netscape公司，将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准，后来ECMA发布标准文件的第一版（ECMA-262），规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript。

该标准从一开始就是针对JavaScript语言制定的，之所以不叫JavaScript，有两个原因：一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标；二是想体现这门语言的制定者是ECMA，不是Netscape，有利于保证这门语言的开放性和中立性。

## 核心组成部分

JavaScript比ECMA-262的含义多得多，一个完整的JavaScript实现应该由以下三个部分组成：

- ECMAScript 2.DOM（document object model）3.BOM（browser object document ） （1）ECMA是（欧洲计算机制造商协会）它规定了js的语法标准。
- DOM是文档对象模型，规定了文档的显示结构，可以轻松地删除、添加和替换节点
- BOM是浏览器对象模型，就是浏览器自带的一些功能样式，如搜索框，设置，等学习浏览器窗口交互的对象







# 第2章HTML中的JavaScript

## 一、script 元素

### 1.1属性：

<script>标签有8个属性：

`1.async`:

可选。表示脚本立即下载，但不能阻止其他页面动作，比如下载资源或其他脚本加载。只对外部脚本文件有效

`2.defer`：

可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效

`3.src`：

可选。表示包含要执行的代码的外部文件。

`4.charset`：

可选。使用src属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。

`5.crossorigin`：

crossorigin：可选。配置相关请求的CORS（跨源资源共享）设置。默认不使用CORS。crossorigin="anonymous"配置文件请求不必设置凭据标志。
crossorigin="use-credentials"设置凭据标志，意味着出站请求会包含凭据。

`6.integrity`：

可选。允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI，SubresourceIntegrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN，ContentDeliveryNetwork）不会提供恶意内容

`7.type`：

可选。代替language，表示代码块中脚本语言的内容类型（也称MIME类型）按照惯例。这个值始终都是"text/javascript" 尽管"text/javascript"和"text/ecmascript"都已经废弃了。JavaScript文件的MIME类型通常是"application/x-javascript"，不过给type属性这个值有可能导致脚本被忽略。在非IE的浏览器中有效的其他值还有"application/javascript"和"application/ecmascript"。如果这个值是module，则代码会被当成ES6模块，而且只有这时候代码中才能出现import和export关键字。

`8.language`：language：废弃。最初用于表示代码块中的脚本语言(如"JavaScript"、“JavaScript1.2"或"VBScript”）。大多数浏览器都会忽略这个属性，不应该再使用它。

### 1.2标签位置：

过去所有的<script>元素都被放在<head>标签里，主要是为了把所有的外部css和JavaScript文件集中放在一起。但这样，意味着页面的渲染在脚本下载/执行完之后，那么如果下载的脚本很多，页面就可能会出现短暂的空白期。为了解决这个问题，现代web开发通常将JavaScript文件放在<body>元素后，这样一来，页面会在处理JavaScript脚本之前完成渲染，空白期会更短。这种放置标签的方式也是一种优化网站的简单方式。

### 1.3推迟执行脚本：

script标签中有个叫defer的属性。这个属性表示脚本在执行的时候不会改变页面的结构，也就是说外部脚本文件加上这个属性会推迟脚本的执行：当html中的head 和 body元素被解析完毕了，它才会被浏览器解析。

### 1.4异步执行脚本：

script标签中有个叫async的属性。这个属性表示异步脚本的执行不会根据脚本放置的先后顺序，同时异步脚本的下载和执行不会影响页面的加载。由于异步的原因，脚本可能会先于页面加载执行，所以不应该在异步脚本中修改DOM。

### 1.5动态加载脚本：

除了通过script标签加载脚本，我们还可以通过动态加载脚本的方式。因为JavaScript是可以使用DOM API的，所以我们可以在script元素中动态创建script元素并将其指定需要 加载的脚本即可实现动态加载脚本的操作。下面展示下红宝书里的示例代码：

```javascript
let script = document.createElement('script'); // 创建script元素
script.src = 'gibberish.js'; // 指定需要动态加载的脚本文件
document.head.appebdChild(script); // 在head中添加
123
```

默认情况下这种方式加载的脚本是异步的，但由于不是所有的浏览器的支持async属性，我们可以统一动态脚本的加载方式，设置为同步加载，代码如下

```javascript
let script = document.createElement('script'); // 创建script元素
script.src = 'gibberish.js'; // 指定需要动态加载的脚本文件
script.async = 'false'; // 指定为同步加载
document.head.appebdChild(script); // 在head中添加
1234
```

同时由于这种方式获取的脚本对于浏览器预加载器是不可见的。这会严重影响资源获取队列的优先级，因此可能会严重影响性能，所以我们应当事先告知动态脚本的存在：

```html
<link rel="preload" href="gibberish.js">
1
```

### 1.6XHTML中的变化：

在这我简单介绍下XHTML，具体详细的讲解还是看看原作吧！
XHTML也称可拓展超文本标记语言，它是将HTML作为XML的应用重新包装的结果。
在XHTML中使用JavaScript必须指定type属性值:text/javascript;
XHTML会把小于号<解析成一个标签的开始。有两种方法解决这个问题:
1.将 < 替换成 &lt
2.将所有代码都有包含发送一个CDATA中 <![CDATA[  ]]>

## 二、行内代码和外部文件

虽然可以直接将代码嵌入到HTML中，但是通常最佳做法是将JavaScript代码放在外部文件中。推荐理由如下：

1. **可维护性**：如果将JavaScript代码分散到很多HTML页面，会导致维护困难；而用一个目录保存所有JavaScript文件，则更容易维护，这样一来开发者可以独立于使用它们的HTML页面来编辑代码
2. **缓存**：浏览器会根据特定的设置缓存所有外部链接的JavaScript文件，这就意味着如果两个页面都使用同一个脚本文件，那么该脚本文件只需下载一次。这就意味着页面加载更快
3. **适应未来**：通过把JavaScript文件放到外部文件中，就不必考虑到用XHTML。包含外部脚本的语言在HTML和XHTML中是一样的。

书中还讲到配置浏览器请求外部文件时的带宽问题。总而言之对于较新的浏览器以轻量、独立JavaScript组件形式向客户端送达脚本更具优势。如果是对于较老的浏览器可能还是一个大的脚本文件更好。

## 三、文档模式

目前主要有三种文档模式：混杂模式；标准模式；准标准模式。这些模式的区别主要体现在通过CSS 渲染的内容方面，但对JavaScript也有一定关联影响；其次不同模式的声明方式不同。感兴趣的小伙伴可以去看原著或查阅更多的书籍。

## 四、noscript元素

针对早期浏览器不支持JavaScript的问题，需要一个页面优雅降级的处理方案。noscript的出现，被用于给不支持JavaScript的浏览器提供替代内容，<noscript>中可以使用任何<body>中的HTML元素。以下任意一种情况都会展示<noscript>中的内容：

1. 浏览器不支持脚本；
2. 浏览器对脚本的支持被关闭



# 第3章语言基础

## JavaScript的作用和特点 

1. 前身：livescript
2. JavaScript分三部分：核心，客户机端，服务器端，
3. JavaScript特点：分布式运算，安全可靠，容易移植，使用浏览器对象。

## JavaScript语法

1. **常量：整形常量，浮点型常量，布尔常量，字符串常量，转义字符，UNdefine，NULL**

2. **变量：var 变量名=值**

3. **类型：原始类型（值放栈中，访问变量可直接访问变量的值）：underfined，null，boolean，number，string
        引用类型（指针放栈中，需通过指针才能访问）：boolwan，number，string(这三是原始类型也可是引用类型)，arrary，date，math**

4. **运算符：算术运算符+,-,\*,/,%,++,--,-
         逻辑运算符：&&，||,!
         比较运算符：>，<，===，！==，>=，<=
         位运算符：&,|,^,~,<<,>>,>>>
         赋值运算符：=，op=
         条件运算符：条件？表达式1：表达式2
         字符串连接运算符：+，+=
         new运算符：创建一个对象
         delete运算符:删除一个对象**

5. **语句：用；分。
        表达书语句。条件语句if...else...。多路分支语句：switch..case...。循环语句：while。循环语句：do...while。循环语句for。退出循环：break，continue。**

   

## JavaScript函数：

1. **格式：function 函数名称（）
   {
   函数体
   }**
2. return返回：没有包含return语句后return没有包含表达式，最终返回undefined。
3. **局部变量：在函数内部定义的变量使用var修饰，只在函数内有效
   全局变量：在函数内定义内var修饰，或在函数之外定义**
4. JavaScript不支持行内变量定义，作业变量最好在函数开始前处说明，才能保证他们是局部变量。
   如果在语句中应用了一个未声明变量，自动回变成全局变量，可能会影响其他函数执行。

## javas使用方法：

1. **使用标记将JavaScript脚本嵌入HTML中**
2. **,放入或之间。**
3. **外部JavaScript文件扩展名：.js**

JavaScript内置对象： 

1. **String对象：字符。
   常考：indexOf（指定字符，开始位置）：返回字符串中第一个出现指定字符串的位置
        split（字符串分隔依据）：将字符串分隔为数组
        toLowerCase（）：全变小写
        toUpperCase（）：全变大写
        valueOf（）：返回字符串对象的原始值
        charAt（）：返回指定索引出的字符**

2. **Math对象：数学运算。
   常考：floor（）返回四舍五入后最小整数。
        random（）返回位于0-1之间的随机数
        round()四舍五入整值**

3. **Date对象：日期时间。
   常考：new Date（）得到时间日期
        getDay（）星期几（返回0-6）
        getFullYear完整4位年份数
        getMonth（）月（返回0-11）
        getDate（）日（返回1-31）
        getHours（）小时（返回0-23）
        getMinutes（）分钟（返回0-59）
        getSeconds（）秒数（返回0-59）**

4. **Ararry对象:数组模型。
   常考：slice（开始，移除数，新元素）：从数组移除一个或多个元素，有必要可以在移除位置添加新元素。
        sort（）排序
        toString（）将所有元素合并成一个字符串并返回，用，分隔**

5. Global：JavaScript初始化时的特殊对象。（概念，无需引用）
   常考：属性：underfined指定一个未被赋值变量
        **方法：****eval****（****String****）判断一个字符串并将以脚本代码形式执行
   **        isNaN**（****String****）判断一个字符串是否是非数字值。
   **      parseInt**（****String****）将一个字符串解析为一个整数。** 

   

   12点了未完待续

## 浏览器对象模型Bom:

（用于描述对象与对象之间层次关系的模型，提供独立于内容，可以与浏览器窗口进行互动的对象结构。）

window对象是bom的顶层对象，其他对象都是他的子对象。

 

## JavaScript事件及处理 

   常考事件及含义：

1. **onblur元素失去焦点**
2. **onchange用户改变域的内容（文本输入框及选择域的内容变化事件，即随输入的东西而给出的反应）**
3. **onclick鼠标点击某个对象（只在img，a，input有效）**
4. **onfocus元素获得焦点**
5. **onload某个页面或图像被加载完成**
6. **onmouseout鼠标从某个元素移开**
7. **onmouseover鼠标被移到某个元素之上**
8. **onselect文本被选定**
9. **onsubmit提交按钮被点击（用fasle来阻止该表单的提交行为）**

   程序处理程序引入（为某个标记元素对象绑定事件响应的函数）

​      **事件绑定：其句柄名以属性名的 形式在html标记试题对象中出现，对应属性值事件响应的代码（函数名），从而实现Html标记元素与JavaScript事件响应的函数名对应。**

​      静态引入：用；分隔，在某个标记中添加某个事件句柄的属性，再写事件处理的程序代码

​      动态引入：将事件响应的函数名直接赋值给html某个标记元素的事件属性，用id属性命名某个超链接，然后为该标记动态引入事件处理方法的代码

## 文档对象模型Dom： 

1. 文档D：根据网页创建的一个文档对象
2. 对象O：一种独立的数据结合
3. 模型M：文档对象的树状模型，元素与内容表现为一个个相互连接的结点
         结点包括：元素结点（body，div，a）；文本结点（p）；属性结点（a）
4. 体系结构：树状
5. 结点关系：父子，兄弟，祖孙





# 第4章变量、作用域与内存

JS变量是松散型的(不强制类型)本质,决定了它只是在特定时间用于保存特定值的一个名字而已;
由于不存在定义某个变量必须要保存何种数据类型值的规则,变量的值及其数据类型可以在脚本的生命周期内改变;

# 一 .变量及作用域

### 1.基本类型和引用类型

// JS变量包含两种不同的数据类型的值:基本类型值和引用类型值;

// 1.基本类型值:保存在栈内存中的简单数据段;即这种值完全保存在内存中的一个位置;
// 基本类型值包含:Undefined|Null|Boolean|Number|String;
// 这些类型在内存中占有固定大小的空间;它们的值保存在栈空间,我们按值来访问;

// 2.引用类型值:保存在堆内存中的对象(可能由多个值构成),即变量中保存的实际上只是一个指针,这个指针指向内存中的另一个位置,该位置保存对象;
// 引用类型的值的大小不固定,因此不能保存在栈内存,必须保存在堆内存中;但可以将引用类型的值的内存地址保存在栈内存中;
// 当查询引用类型的变量时,先从栈内存中读取内存地址,然后通过地址找到堆内存中的值;=>按引用访问;

### 2.动态属性



```html
<span style="font-size:18px;">// 定义基本类型值和引用类型值的方式相似:创建一个变量并为该变量赋值;// 但当这个值保存到变量中以后,对不同类型值可以执行的操作则不一样;  var box = new Object();           // 创建引用类型;  box.name = 'lee';              // 新增一个属性;  console.log(box.name);           // =>lee;   var box = 'lee';              // 创建基本类型  box.age = 15;                // 给基本类型添加属性;  console.log(box.age);            // =>undefined;</span>
```







### 3.复制变量值



```html
<span style="font-size:18px;">// 在变量复制方面,基本类型和引用类型也有所不同;// 基本类型赋值的是值本身;  var box = 'lee';              // 在栈内存中生成一个box'lee';  var box2 = box;               // 在栈内存中再生成一个box2'lee';  // box和box2完全独立;两个变量分别操作时互不影响; // 引用类型赋值的是地址;  var box = new Object();          // 创建一个引用类型;box在栈内存中;而Object在堆内存中;  box.name = 'lee';             // 新增一个属性;  var box2 = box;              // 把引用地址赋值给box2;box2在栈内存中;  // box2=box,因为它们指向的是同一个对象;  // 如果这个对象中的name属性被修改了,box.name和box2.name输出的值都会被修改掉;</span>
```







### 4.传递参数





```
// JS中所有函数的参数都是按值传递的,即参数不会按引用传递;
 ` `function` `box(num){       ``// 按值传递,传递的参数是基本类型;
  ` `num +=10;        ``// 这里的num是局部变量,全局无效;
  ` `return` `num;
 ` `}
 ` `var` `num = 50;
 ` `var` `result = box(num);
 ` `console.log(result);      ``// 60;
 ` `console.log(num);       ``// 50;
```

 

```
 ` `function` `box(num){
  ` `return` `num;
 ` `}
 ` `console.log(num);       ``// num is not defined;
```

 

```
 ` `function` `box(obj){
  ` `obj.name = ``'lee'` `;
  ` `var` `obj = ``new` `Object();    ``// 函数内部又创建了一个对象,它是局部变量;但在函数结束时被销毁了;
  ` `obj.name = ``'Mr'` `;      ``// 并没有替换掉原来的obj;
 ` `}
 ` `var` `p = ``new` `Object();
 ` `box(p);         ``// 变量p被传递到box()函数中之后就被复制给了obj;在函数内部,obj和p访问的是同一个对象;
 ` `console.log(p.name);      ``// =>lee;
```

 

```
 ` `// JS函数的参数都将是局部变量;也就是说,没有按引用传递;
```





### 5.检测类型



```html
<span style="font-size:18px;">// 要检测一个变量的类型,通过typeof运算符类判断;// 多用来检测基本类型;  var box = 'lee';  console.log(typeof box);          // =>string; // 要检测变量是什么类型的对象,通过instanceof运算符来查看;  var box = [1,2,3];  console.log(box instanceof Array);     // =>true;  var box2 = {};  console.log(box2 instanceof Object);  var box3 = /g/;  console.lgo(box3 instanceof RegExp);  var box4 = new String('lee');  console.log(box4 instanceof String);   // =>true;是否是字符串对象;   var box5 = 'string';  console.log(box5 instanceof String);   // =>false;  // 当使用instanceof检查基本类型的值时,它会返回false;</span>
```







### **6.执行环境及作用域



```html
<span style="font-size:18px;">// 执行环境:定义了变量或函数有权访问的其他数据,决定了它们各自的行为;// 在Web浏览器中,全局执行环境=window对象;// 因此所有的全局变量和函数都是作为window对象的属性和方法创建的;  var box = 'blue';             // 声明一个全局变量;  function setBox(){    console.log(box);           // 全局变量可以在函数里访问;  }   setBox();                 // 执行函数;  // 全局的变量=window对象的属性;  // 全局的函数=window对象的方法; // PS:当执行环境中的所有代码执行完毕后,该环境被销毁,保存在其中的所有变量和函数定义也随之销毁;// 如果是在全局环境下,需要程序执行完毕,或者网页被关闭才会销毁; // PS:每个执行环境都有一个与之关联的变量对象,就好比全局的window可以调用全局变量和全局方法一样;// 局部的环境也有一个类似window的变量对象,环境中定义的所有变量和函数都保存在这个对象中;// (我们无法访问这个变量对象,但解析器会处理数据时后台使用它);  var box = 'blue';  function setBox(){    var box = 'red';           // 这里是局部变量,在当前函数体内的值是'red';出了函数体就不被认知;    console.log(box);  }   setBox();  console.log(box); // 通过传参可以替换函数体内的局部变量,但作用域仅限在函数体内这个局部环境;  var box = 'blue';  function setBox(box){           // 通过传参,将局部变量替换成了全局变量;    alert(box);              // 此时box的值是外部调用时传入的参数;=>red;  }  setBox('red');  alert(box); // 如果函数体内还包含着函数,只有这个内函数才可以访问外一层的函数的变量;// 内部环境可以通过作用域链访问所有的外部环境,但外部环境不能访问内部环境中的任何变量和函数;  var box = 'blue';  function setBox(){    function setColor(){      var b = 'orange';      alert(box);      alert(b);    }    setColor();              // setColor()的执行环境在setBox()内;  }  setBox();  // PS:每个函数被调用时都会创建自己的执行环境;当执行到这个函数时,函数的环境就会被推到环境栈中去执行,而执行后又在环境栈中弹出(退出),把控制权交给上一级的执行环境;   // PS:当代码在一个环境中执行时,就会形成一种叫做作用域链的东西;它的用途是保证对执行环境中有访问权限的变量和函数进行有序访问;作用域链的前端,就是执行环境的变量对象; </span>
```



### **7.延长作用域链**



```html
// 有些语句可以在作用域链的前端临时增加一个变量对象,该变量对象会在代码执行后被移除;// with语句和try-catch语句;这两个语句都会在作用域链的前端添加一个变量对象;// with语句:会将指定的对象添加到作用域链中; // catch语句:会创建一个新的变量对象,其中包含的是被抛出的错误对象的声明;  function buildUrl(){    var qs = '?debug=true';    with(location){            // with语句接收的是location对象,因此变量对象中就包含了location对象的所有属性和方法;      var url = href+qs;        // 而这个变量对象被添加到了作用域链的前端;    };    return url;  }
```







### 8.没有块级作用域



```html
<span style="font-size:18px;">	// 块级作用域:表示诸如if语句等有花括号封闭的代码块,所以,支持条件判断来定义变量;  if(true){                 // if语句代码块没有局部作用域;    var box = 'lee';           // 变量声明会将变量添加到当前的执行环境(在这里是全局环境);  }  alert(box);   for(var i=0; i<10; i++){         // 创建的变量i即使在for循环执行结束后,也依旧会存在与循环外部的执行环境中;    var box = 'lee';  }  alert(i);  alert(box);   function box(num1,num2){    var sum = num1+num2;         // 此时sum是局部变量;如果去掉var,sum就是全局变量了;    return sum;  }  alert(box(10,10));  alert(sum);                // sum is not defined;访问不到sum;  // PS:不建议不使用var就初始化变量,因为这种方法会导致各种意外发生; // 一般确定变量都是通过搜索来确定该标识符实际代表什么;搜索方式:向上逐级查询;  var box = 'blue';  function getBox(){    return box;              // 此时box是全局变量;如果是var box='red',那就变成局部变量了;  }  alert(getBox());               // 调用getBox()时会引用变量box;  // 首先,搜索getBox()的变量对象,查找名为box的标识符;  // 然后,搜索继续下一个变量对象(全局环境的变量对象),找到了box标识符;// PS:变量查询中，访问局部变量要比全局变量更快，因为不需要向上搜索作用域链；</span>
```





## 二 内存问题



```html
<span style="font-size:18px;">// JS具有自动垃圾收集机制,执行环境会负责管理代码执行过程中使用的内存;它会自行管理内存分配及无用内存的回收; // JS最常用的垃圾收集方式就是标记清除;垃圾收集器会在运行的时候给存储在内存中的变量加上标记;// 然后,它会去掉环境中正在使用的变量的标记,而没有被去掉标记的变量将被视为准备删除的变量;// 最后,垃圾收集器完成内存清理工作,销毁那些标记的值并回收他们所占用的内存空间; // 垃圾收集器是周期性运行的,这样会导致整个程序的性能问题;// 比如IE7以前的版本,他的垃圾收集器是根据内存分配量运行的,比如256个变量就开始运行垃圾收集器,这样就不得不频繁地运行,从而降低了性能; // 一般来说,确保占用最少的内存可以让页面获得更好的性能;// 最佳方案:一旦数据不再使用,将其值设置为null来释放引用,这个做法叫做解除引用;  var o = {    name:'lee';  };  o = null;               // 解除对象引用,等待垃圾收集器回收;</span>
```





## 三 小结 

**

1.变量
// JS变量可以保存两种类型的值:基本类型值和引用类型值;它们具有以下特点:
// 1.基本类型值在内存中占据固定大小的空间,因此被保存在栈内存中;
// 2.从一个变量向另一个变量复制基本类型的值,会创建这个值的一个副本;
// 3.引用类型的值是对象,保存在堆内存中;
// 4.包含引用类型值的变量实际上包含的并不是对象本身,而是一个指向该对象的指针;
// 5.从一个变量向另一个变量复制引用类型的值,复制的其实是指针,因此两个变量最终都指向用一个对象;
// 6.确定一个值是哪种基本类型可以使用typeof操作符;而确定一个值是哪种引用类型可以使用instanceof操作符;

2.作用域
// 所有变量都存在于一个执行环境(作用域)中,这个执行环境决定了变量的生命周期,以及哪一部分代码可以访问其中的变量;
// 1.执行环境有全局执行环境和函数执行环境之分;
// 2.每次进入一个新执行环境,都会创建一个用于搜索变量和函数的作用域链;
// 3.函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其父环境，乃至全局环境；
// 4.变量的执行环境有助于确定应该合适释放内存;

3.内存
// JS自动垃圾收集机制
// 1.离开作用域的值将被自动标记为可以回收,因此将在垃圾收集期间被删除;
// 2.为了确保有效地回收内存,应该及时解除不再使用的全局对象/全局对象属性以及循环引用变量的引用;







# 第5章基本引用类型

引用类型的值（对象）是引用类型的一个实例，它是一种数据结构，用于将数据和功能组织在一起，也常被称为类。

## 一、Object类型

1.创建方式：
（1）new+操作符

```css
        var person = new Object();
        person.name = "lili";
        person.age = "18";
123
```

（2）对象字面量

```css
        var person = {
            name : "lili",
            age : 18
        };
        或
        var person = {};
        person.name = "lili";
        person.age = "18";        
12345678
```

2.访问对象属性
（1）person[“name”]
（2）person.name(常用)

## 二、Array类型

1.创建数组
（1）Array构造函数

```css
        var colors = new Array();
        
        //创建length为20的数组
        var colors = new Array(20);
        
        //直接初始化数组
        var colors = new Array("red","pink","blue");
		//省略new操作符
		var colors = Array("gray");
		var colors = Array(3);
12345678910
```

（2）使用数组字面量（数组字面量由一对包含数组的方括号表示）

```css
        var colors = ["red","pink","blue"];
        var colors = [];		//创建一个空数组
12
```

2.引用数组元素：数组名 [ 索引 ] ;

## 三、Date类型

显示日期和时间的方法。

## 四、RegExp类型

RegExp类型支持正则表达式。
**1.正则表达式的匹配模式：**
g：全局模式，将此模式应用到所有字符串
i：不区分大小写模式，即匹配时忽略匹配项的大小写
m：多行模式，与多行文本进行匹配
**2.创建正则表达式**
（1）使用字面量形式：
var 变量名 = / 目标字符串 / 匹配模式
（2）创建RegExp构造函数：
变量名 = new RegExp（“字符串”，“匹配模式”）；

## 五、Function类型

**1.函数的定义**
（1）通过函数的声明：

```css
function 函数名(任意数量的参数){
	语句;
}
123
```

对于（1），调用语句可以在任何位置，因为解析器会率先解析函数的声明
（2）使用函数表达式

```css
        var 变量名 = function(参数列表){
            语句;
        };
123
```

对于（2），调用语句只能在函数表达式后面，否则会出现错误
（3）使用Function构造函数（不推荐）

## 六、基本包装类型

Boolean、Number、String
每当读取到一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们调用一些方法来操作这些数据。
**引用类型与基本包装类型的区别是生存期**：基本包装类型为其创建的属性和方法存在于一瞬间，然后立即被销毁。

## 七、单体内置对象

Clobal、Math
1.Global对象：所有在全局作用域中定义的属性和函数都是Global对象的属性。
2.Math对象：保存着数学公式和信息。









# 第6章  集合引用类型

今天无由的在博客上开了一个‘随写知识点总结’，目的呢，就是想每次遇到基础知识点，会积累系统全面的总结知识点，加深自己的根基，也方便 
以后的知识复习及查询。 

切入正题，今天个人总结的是js数据类型的引用类型的Array对象 

## 1.什么是数组？ 

数组是值的有序集合，而且可以存放js各种数据类型，因为js是弱类型的语言，所以不像其他语言数组只能存放特定的数据类型 
 注意：1. ECMAScript语言中的数组是可以动态变化的（因为是js的数组的数值存储采用链式结构存储） 
    2.Array数组是数据的有序列表。所以数组里的数值都有特定的索引值 
    3.ECMAScript同一个数组中可以存储不同类型的数据； 
    4.每个数组都有一个length属性 

## 2.数组的创建 

1.使用new Array()方法 
      创建未知长度的数组  var arr1=new Array(); 
      创建数据长度    var arr2=new Array(20); 
      创建存放元素的数组  var arr3=new Array(20,10,'hello',null,undefined) 
    2.使用Array()方法 
    3.使用字面量创建，也是以后最常用创建的方法 
      var arr4=[1,2,4]; 

## 3.数组元素的读和写 

通过下标来读取数组的值  arr[5]='hello' 

## 4.数组的长度：length属性 

通过数组的length属性来获取数组的长度  arr=['h','dsa','as'];arr的长度为arr.length 

## 5.检测数组 

判断是否是数组，使用Array.isArray(要判断的变量), 但值得注意的是：（typeof 要判断变量）或（typeof(要判断的变量)格式判断的是基本数据类型，即局限性就是在于基本数据类型，引用类型都是返回object 

## 6.数组方法 

### 1.将数组转为字符串的方法

   1>toString()方法，形如：arr.toString(),数组元素转为字符串，数组元素默认以“，”来分隔    2>join('符号'),形如：arr.join('+')使用指定符号来分隔元素
   1>push()方法，形如：arr.push('新元素1'，'新元素二'),从数组末尾的位置添加新元素，并返回数组的长度


### 3.数组开头操作增减

   1>shift()方法，形如：arr.shift()删除数组开头第一个元素，并返回删除的元素    2>unshift()方法，形如：arr.unshift()在数组开头添加一个元素
   形如：var arr1=arr.concat('数组元素'，’另外一个数组’)根据现有数组创建新数组，即原数组添加元素或者一个数组而产生新的数组
    形如：var arr1=arr.slice(开始下标，结束下标[可选])，注意：截取不包含结束下标，根据当前数组中一个或多个元素创建另一个数组

### 6.splice()方法

​    对数组的增删改操作，形如：arr.splice(起始下标位置，要删除的元素个数，要插入的元素) 注意：当要删除的元素个数为0，就是对数组增操作       eg.var arr1=[1,23,12,45,3];arr1.splice(2,0,'red')
​       var arr3=[1,23,12,45,3];arr3.splice(0,3,'green')
​    获取数组元素的下标，形如：arr.indexOf(要查找的元素，要搜索的起始位置[可选])

## 7.二维数组 

数组元素其实也是一个数组 

## 8.数组元素的遍历 

使用for循环遍历 

## 9，数组实现对数组的排序 

列举常用的方法： 

###      1>使用冒泡排序

代码如下： 
       

```javascript
//定义一个排序函数，第一个参数是需要排序的数组，第二个参数是以哪种方式排序              //true代表升序，false代表降序              function(arr,isAscend){                  for(var i=0;i<arr.length-1;i++){                      for(var j=0;j<arr.length-i;j++){                          var temp;                          if(isAscend){                              if(a[j]>a[j+1]){                                temp=a[j];                                a[j]=[j+1];                                a[j+1]=temp;                              }                          }else{                              if(a[j]<a[j+1]){                                temp=a[j];                                a[j]=[j+1];                                a[j+1]=temp;                              }                          }                      }                  }                  return arr;              }
```



### 2>使用自定义的排序函数结合sort()实现排序

代码如下： 

```javascript
function sortArray(arr,isAscend){                      //这是一个升序函数                      function compare1(value1,value2){                        if(value1>value2){                            return 1;                        }else if(value1=value2){                            return 0;                        }else{                            return -1;                        }                      }                      //这是一个降序函数                      function compare2(value1,value2){                        if(value1<value2){                            return 1;                        }else if(value1=value2){                            return 0;                        }else{                            return -1;                        }                         //如果传入的参数，需要升序就调用compare1函数，否则调用compare2函数                        if(isAscend){                          arr.sort(compare1);                        }else{                          arr.sort(compare2)                        }                       }                   }
```



### 3>快速排序算法

原理思路： 
          1.在数据集之中，找个基准点 
          2.建立两个数组，分别存储左边和右边 
          3.利用递归进行下次比较 

```javascript
function quickSort(arr){                      if(arr.length<=1){   //如果数组只有一个数，就直接返回  ,递归的终止条件                        return arr;                      }                      var num=Math.floor(arr.length/2);//找到中间的索引值，如果是浮点数，则向下取整                      var newValue=arr.splice(num,1);  //找到中间数的值                      var left=[],right=[];                      for(var i=0;i<arr.length;i++){                        if(arr[i]<newValue){                          left.push(arr[i]);   //基准点的左边的数传到左边数组                        }else{                          right.push(arr[i]);                        }                      }                      return quickSort(left).concat(newValue,quickSort(right));                    }                    console.log(quickSort([12,2,3,12,2,11,1,34]));
```





# 第7章  迭代器与生成器

迭代器和生成器可能对于一些人来说知道是什么东东，但是并没有比较深入的了解，那么今天，就跟随我来了解一下这两者的概念，关系及优点，我将使用python中的迭代器和生成器作为演示，如果你不懂python没关系，明白了概念，剩下的就只是编程语言的差异了！这一点很关键，再啰嗦一句，不要为了编程而编程，也要明白一些概念性的东西，编程语言只是工具！

## 1.从循环开始说起

想必大家在学习编程的时候，肯定学到过for循环，while循环，do…while循环等等，那么我们为什么需要循环操作呢？因为有些时候我们希望计算机为我们重复的执行同样的操作，比如我有一个“数组”，里面存储了100个同学的id，那么我则会对这个数组进行循环操作，然后挨个输出。当然还有很多其他地方需要循环操作，这里我只是举个例子。

所以，循环操作是计算机编程语言中必不可少的组成部分，那么请大家用几秒钟时间回想一下，我们之前曾经写过的循环操作for循环，while循环。我们往往需要初始化一个变量i，还得声明一个条件比如i<100，然后循环完每一步之后做什么，比如(下方伪代码):

```
for(i = 0; i < 100; i++) {	}
```

我们可以很容易的用这种循环来遍历一个数组，希望大家学过数据结构，因为数组在内存中的存储是连续的！我们可以通过数组的“下标”(其实是相对于数组第一个元素的位置)来进行访问数组中的元素，所以在很多时候，我们通过for循环来遍历数组(下方伪代码):

```
for(i = 0; i < arrLength; i++) {	}
```

那么如果我现在问你，你怎么进行遍历一个没有在内存中连续存储的“数据结构”呢，比如python中的“字典”，javascript中的”对象“，又比如你自己写了一个”树“结构的类，想遍历整个树的节点？那么传统的for循环，while循环就无法发挥他们的作用了，这个时候我们就应该引入”迭代器“了。

所以，小结一下，”迭代器“其实目的也是为了”循环“，更严谨一些，是为了“遍历”，你可以把迭代器看成比普通循环更高级别的工具，普通循环能搞定的迭代器也能搞定，普通循环搞不定的迭代器还能搞定，并且使用迭代器比普通循环效率更高，这个我们后面说到生成器的时候会提到。

## 2.迭代(iteration)/可迭代(iterable)/迭代器(iterator)

我想大多数人可能和我一样，刚开始对这些概念/名词都很模糊，那么让我们一起弄明白他们。

大家先要知道“协议”（protocol）的意思，其实协议是用来“规范/标准化”你“创造的东西”的。比如，你开天辟地的发明了一种东西叫做“吧啦哔哩”，你给小明说：“小明，给我发一个吧啦哔哩过来”，如果小明不知道啥叫“吧啦哔哩”，那么小明会直接懵逼的。这时候你就要定一个“协议”如下：

1， “吧啦哔哩”一共有10个字
2， “吧啦哔哩”开头和结尾都是”#”号 (占两个字)
3， “吧啦哔哩”最后四位是”blbl”
4, 其他随便

那么我们根据这个协议，可以很轻易的构造出“吧啦哔哩”来：#1234blbl# 或者 #8888blbl#

同样，我们根据这份协议，就可以用来检测你得到的是不是“吧啦哔哩”，#1234blbl# -> 是，#1234blbl！-> 不是

迭代(iteration)

明白了上面的东西，下面我们就开始“迭代”之旅，迭代顾名思义，就是重复的的既定的任务，直到完成。所以，为了完成迭代，我们需要一个迭代器！那么什么是迭代器呢？来看看迭代器的协议吧

## 3.迭代器协议 iterator protocol

从前有个人发明了迭代器，为了让大家明白什么是迭代器，他就写了这个协议，那么协议的内容简而言之就是一句话：如果一个对象包括一个叫”next”(python3 为__next__)的方法，那么这个对象就叫做“迭代器”。

好了，那么我们根据这个协议可以创建一个迭代器(iterator)

```
class Counter:	def __init__(self):		self.index = 0 	def __next__(self):		i = self.index		if i < 10:			self.index += 1			return i
```

这个Counter就是一个迭代器，但是目前它没有什么太大的作用，因为我们不可能每次通过手动调用__next__方法来进行操作。

好消息是，很多编程软件为我们提供了一个“语法糖”(syntactic sugar)，让这个语法糖来替我们反复执行__next__方法，比如python中的”for.. in”，但是，为了让这个反复执行的过程停下来，我们同样需要定义一个终止信号，在python中，终止信号就是抛出一个StopIteration的“例外”(exception)，来告知我们的语法糖：”好啦，没东西可以迭代了，可以停了“，这样迭代就终止了。

所以我们再进一步规范一下我们创建的迭代器成如下形式：

```
class Counter:	def __init__(self):		self.index = 0 	def __next__(self):		i = self.index		if i < 10:			self.index += 1			return i		else:			raise StopIteration
```

好了，我们来试一下：

```
counter = Counter() for i in counter:	print(i)
```

不妙，报错了。。

```
TypeError: 'Counter' object is not iterable
```

错误显示说：这个Counter对象不是可迭代的！这是什么意思呢？

原来，为了使用这个for..in 迭代语法糖，我们需要在in后面放可以迭代的“迭代器”，什么是可以迭代？你可以认为就是可以使用for..in语法糖，让语法糖帮你重复调用next方法就好了。如果不可以迭代， 那么for..in这个语法糖就无法为我们自动调用next方法。

所以说，为了使用for..in语法糖来进行迭代我们的迭代器，你必须让你的迭代器可迭代(有点绕。。哈哈)。

这句话有两层含义： 1，为了使用for..in语法糖，你必须让你的迭代器可迭代 2，你如果不适用for..in语法糖，你就不必让你的迭代器可迭代，你可以自己写一个语法糖，不断地调用next方法，当遇到StopIteration例外的时候停止罢了。

但是当你使用别人(编程语言)实现编写好的语法糖时，你就必须按照他们的规则走。

好了，我们现在明白了，通常来讲，当我们要创建了一个迭代器时，我们还“必须”(注意是必须)让迭代器可迭代，这样理解：因为一个不可迭代的迭代器是没有意义的！

**所以，注意！从现在开始到文章结束，我所说的“迭代器”都是“可迭代”的迭代器！**

那么怎么让我的迭代器可迭代呢？同样，来看什么是“可迭代协议”(iterable protocol）

## 4.可迭代协议 iterable protocol

在python中，为了使一个”对象“可迭代：
1，这个迭代器必须同时包含另一个方法叫做“**iter**”
2，这个”**iter**“方法还得返回一个”迭代器“(可迭代)

请注意，上面我说的是：为了使一个”对象“可迭代，这里，对象可以指我们刚刚创建的”Counter“迭代器，也可以是其他的对象。

来个栗子： 为了使我们刚才创建的Counter迭代器对象“可迭代”，那么： 1，我们就在这个Counter对象里面添加一个叫__iter__的方法 （可迭代化操作） 2, 让这个__iter__方法返回一个“可迭代的迭代器” (这里就是自己了！)

```
class Counter:	def __init__(self):		self.index = 0 	def __iter__(self):		return self 	def __next__(self):		i = self.index		if i < 10:			self.index += 1			return i		else:			raise StopIteration counter = Counter()for i in counter:	print(i)
```

Cool! 这个时候我们得到了0，1，2，3，4，5，6，7，8，9的迭代！

这里简单说一些执行步骤，当我们使用for..in语法糖的时候，它先调用__iter__方法，得到返回的迭代器，然后连续调用该迭代器的__next__方法，知道遇到StopIteration例外

我上面也提到了，我们不仅可以使迭代器“可迭代”，我们也可以使普通的对象“可迭代”，只需给该对象添加一个__iter__的方法，然后返回一个可迭代的迭代器就好了！

这里顺便插一句！在python中，我们可以使用”iter”这个函数来返回一个“可迭代的迭代器”。

比如：

```
x = iter([1, 2, 3])print(x) #<list_iterator object at 0x10c828550>x.__next__() # 返回 1x.__next__() # 返回 2x.__next__() # 返回 3x.__next__() # 返回 StopIteration
```

所以，我们可以让一个普通对象可迭代，而不一定非得是迭代器。

```
class Name:	def __iter__(self):		return iter(['zhangsan', 'lisi', 'wangwu']) name = Name()for n in name:	print(n)
```

不错！我们得到了zhangsan, lisi, wangwu

现在逻辑不是很复杂的情况之下，这种创建迭代器的方式还是能够接受的，但是如果逻辑复杂，以及用这种模式多了，每次这么定义就不是很方便，于是为了“简化”创建迭代器的过程，“生成器”generator就出现了。

## 5.生成器generator

生成器的出现，就是为了简化创建迭代器的繁杂，同时又要保证逻辑的清晰，说到底生成器就是为了更方便我们使用迭代器而生的，生成器的特性如下：

1, 生成器的样子就是一个普通的函数，只不过return关键词被yield取代了
2, 当调用这个“函数”的时候，它会立即返回一个迭代器，而不立即执行函数内容，直到调用其返回迭代器的next方法是才开始执行，直到遇到yield语句暂停。
3, 继续调用生成器返回的迭代器的next方法，恢复函数执行，直到再次遇到yield语句
4, 如此反复，一直到遇到StopIteration

看如下例子：

```
def gFun():	print('before hello')	yield 'hello'	print('after hello') a = gFun() # 调用生成器函数，返回一个迭代器并赋给a print(a) # <generator object gFun at 0x104cd2a40> 得到一个生成器对象(迭代器)print(a.__next__())# before hello# helloprint(a.__next__())# after hello# StopIteration
```

同时因为调用生成器函数返回的是一个迭代器，所以我们可以使用for..in语法糖对其进行迭代操作：

```
a = gFun()for x in a:	print(x)
```

迭代返回了before hello, hello, after hello

## 6.使用迭代器/生成器的好处

首先快速看一段代码：

```
def firstn(n):	num, nums = 0, []	while num < n:		nums.append(num)		num += 1		return nums sum_of_first_n = sum(firstn(1000000))
```

这段代码定一个了一个函数firstn，该函数接受一个参数n，返回n之前所有的整数，最后对这些整数进行求和。 这个代码使用了我们传统的while循环，如果接受的参数n比较小还好，但是当接受的参数很大时，对内存的消耗就凸显出来了，因为在执行该函数的过程中， nums这个大的列表会全部存在于内存中。并且求和运算只有当nums列表完全构建完成之后才可以进行运算，效率也高。

而用迭代器(生成器)的方法则会大大提高效率，一方面每次next循环都会yield出一个值，供sum函数累加使用，这样就不用占用很大的内存，另一方面，使用迭代器/生成器也不用完全等到前n个数全部遍历完再进行累加，效率更高！







# 第8章   对象、类与面向对象编程

## 一，什么是面向对象

**常见的几种思想**

1. 面向过程：（没有类，没有对象，在C语言中有用）
2. 面向对象（在Java、C++、JS中都有使用）
3. 面向切面（spring IOC AOP）

## 二，JS面向对象的几种特征以及类和对象

### 1，面向对象的几种特征

1. 抽象：把具体的问题抽象化；
2. 封装：把属性和方法封装在类中，如

```javascript
var obj = {
                name:"wc",
                age:100,
                say:function(){
                    log("say...");
                }
            }
1234567
```

1. 继承：一个类可以继承另一个类，在JS中，类是通过函数表达式来定义；
2. 多态：暂时不多说；

### 2，面向对象中的类和对象

1. **类：** JS中的类的本质还是一个函数，是抽象的，而不是具体的；如下

```javascript
function Person(){  // 是一个类的话，首字母会大写 
            }
     new Person(); // 此时Persion是一个类
     Person(); // 此时Person就是一个函数
1234
```

- **对象：** `var obj = {name:"wc"};` 此时obj就表示一个对象，在JS中一个{ }就是一个对象；

## 三，JS中默认存在的类（常见的）

### 1，Number类

```javascript
var n = new Number("100");
    console.log(n); // Number {100}
    console.log(typeof n); // object（对象）
    // instanceof 是一个运算符  判断一个对象是否属性某个类
    console.log(n instanceof Number);  // true（表示n属于Number类）
12345
```

### 2，String类

```javascript
var str = new String("hello oop");
    console.log(str)  // {"hello oop"}
    console.log(typeof str)  // object（对象）
    console.log(str instanceof String);  // true（表示str属于String类）
    console.log(str instanceof Number);  // false（表示str不属于String类）
12345
```

### 3，Boolean构造器（JS中构造器也叫类）

```javascript
var f = new Boolean(false);
    console.log(f)  // {false}
    console.log(typeof f)  // object
    console.log(f instanceof Boolean)  // true
1234
```

### 4，Object构造器（存在语法糖）

**第一种写法**

```javascript
var obj = new Object();  // new一个构造器得到一个对象
    obj.name = "wc";
    obj.age = 110;
    console.log(obj); // {name: "wc", age: 110}
1234
```

**第二中写法**：是第一种写法的语法糖（就相当于上面写法的简写，方便了程序员）

```javascript
var obj2 = {  // 字面量形式声明一个对象
        name:"xiaoqiang",
        age:100
    }
1234
```

### 5，Data类

```javascript
var d = new Date();
    console.log(d); 
    console.log(d.getFullYear()) //只获取年份，属于对象中默认的方法；
123
```

### 6，Math类（不需要new）

- **属于单体内置类，常驻内存不需要new**

```javascript
var r = Math.random(); 
    console.log(r); //输出一个随机数
12
```

### 7，Array类

```javascript
var arr = new Array("a","b","c");
    console.log(arr); // 输出["a", "b", "c"]
    // 是上面的形式的语法糖
    var arr2 = ["d","e","f"];  // 字面量创建数组（对象）
    console.log(arr2); // ["d", "e", "f"]
12345
```

## 四，JS中的对象及函数

### 1，证明：JS中的一切数据都是对象

> **JS中的HTML元素标签、数组、函数、基本数据类型、console等等 均是对象**

**数组是对象证明：**

```javascript
var arr = ["a","b","c"]; // 也是Array这个类
    console.log(arr); // ["a", "b", "c"]
    console.dir(arr); //console.dir(arr)显示arr对象所有的属性和方法。
    console.dir(typeof arr); // object
    console.log(arr.length); //打点调用，表明arr对象中有length方法；
    arr.push("d"); //加入数据“d”
    console.log(arr); //["a", "b", "c", "d"]
    console.log(arr instanceof Array); // true  表名arr属于Array类
12345678
```

**函数也是对象证明：**

```javascript
function f(a,b) {
        console.log("f...")
    }
    console.dir(f)
    console.dir(f.name)
    console.dir(f.length)
    console.log(f instanceof Function); // true 函数属于Function类
    console.log(typeof f); // function
12345678
```

**基本数据类型也是对象证明：**

```javascript
 var a = 110; // 现在要证明a也是对象
    console.dir(a);  // 110
    console.log(typeof a) // number
    console.log(a instanceof Number) // false
    // 如果a不是对象  是不可能打点调用toFiexed
    console.log(a.toFixed(3)); // 110.000
    // 上面的a叫包装对象
    // 上面调用toFixed时，它会把a瞬间包装成一个对象
    var str = "hello";
    console.log(str.length);  // 5  str也是瞬间包装成对象了
    console.log(str.toUpperCase()); // HELLO 如果str不是对象  是不可能打点调用toUpperCase
1234567891011
```

**console、window也是对象证明：**

```javascript
console.log("wc") //打点调用，如果console不是对象，则不会调用log
console.dir(console)
console.log(console instanceof Object)  // true
console.dir(window)
console.log(window instanceof Window)  // true
12345
```

### 2，对象是属性的无序集合

> 在访问集合中的属性时，键是可以使用引号给包起来，也可以不包；调用属性有两种方式：
>
> - 打点调用
> - 通过[ ]来调用；（通常不使用这种方式）

```javascript
var obj = {
        name:"wangcai",  // name叫属性名  “wangbai"叫属性值
        123:456, // 123是属性名(键)，456是属性值（值）
        "1+1":2, // "1+1"是属性名   2是属性值
        "a":"hello",
        "b":null,
        "c":function () {
            console.log("c..")
        },
        "d":["1","2","3"],
        "e":{ x:"xxx" }
    }
    console.log(obj.name)
    console.log(obj[123]); // 必须使用[ ]给属性名包起来，输出456
    console.log(obj.a); // hello
    console.log(obj["1+1"]); // 2
    // 如果我们的键是一个变量  我们需要通过变量去访问  必须使用[]
    var k = "name";
    console.log(obj[k]); // wangcai
12345678910111213141516171819
```

- 访问一个对象中不存在的属性时，输出结果为undefined；如下

```javascript
var obj = {};
 console.log(obj.name)
12
```

### 3，对象属性的增删改查

### （1）对象属性的遍历（for in）

存在一个对象：

```javascript
 var obj = {
        name:"wangcai",
        age:100,
        say:function () {
            console.log("say...")
        }
    }
1234567
```

对上面对象遍历：

```javascript
for (var key in obj) {  // 通常遍历一个对象使用for in
        // key是一个变量
        console.log(obj[key])
    }
1234
```

- 使用for in有时候不能对属性全部遍历出来

```javascript
let arr = ["a","b","c"];
    console.dir(arr)；//还有个length属性
    for (const key in arr) {  // 使用for in 并不能遍历出一个对象中所有的属性  如数组中的length和__proto__
       console.log(arr[key])
    }
12345
```

### （2）对象属性的增删改

- 添加、修改属性：

```javascript
var obj = {
        name:"wangcai"
    }
    console.log(obj.name); // 打印出obj中的name属性  访问
    obj.name = "xiaoqiang"; // 修改属性
    console.log(obj.name);  // 同名属性后面的会把前面的覆盖掉
    obj.age = 1100; // 新增属性
    obj["address"] = "北京"; //  新增属性
    console.log(obj)
123456789
```

- 删除对象属性

```javascript
var obj = {
        name:"wangcai",
        age:100
    }
    console.log(obj)
    // delete 是一个运算符 是单目运算符
    delete obj.age; //只能删除私有属性，而不能删除公有属性；
    console.log(obj); //{name: "wangcai"}
12345678
```

- 再删除对象属性的时候，有一些情况是不能删除的；

```javascript
	var a = 110;  // var的变量放到GO中，是不能删除的，因为GO中有一个属性的设置使a不能删除；（后面有相关属性的介绍）
    console.log(window.a)
    delete window.a;
    console.log(window.a)
    
    b = 666;  // 没有加var的变量  默认是可以删除的
    console.log(window.b) // 666
    delete window.b;
    console.log(window.b) // undefined

    let c = 111;
    delete c;  // delete用来删除一个对象上的属性
    console.log(c)
12345678910111213
```

## 4，对象中属性的四大特征

### （1）configurable（是否删除）

> 表示该属性是否可以被删除，true表示可以删除；

### （2）writable（是否修改）

> 表示是否可以对属性进行修改，true表示可以修改；

### （3）enumerable（能否输出）

> 是否可以枚举，就是是否可以输出，是否可以遍历；

### （4）value（属性值，默认undefined）

**在获取对象中的属性的特征时，是通过Object.getOwnPropertyDescriptor 获取属性的特征的**

- 获取obj对象中的name属性：

```javascript
console.log(Object.getOwnPropertyDescriptor(obj, "name"));
//得到四个属性分别为：
// configurable: true  可以删除
// writable: true  可以修改
// enumerable: true  可以输出（遍历）
// value: "wangcai"  默认值
123456
```

- 获取数组对象中的length属性：

```javascript
var arr = ["a"] 
console.log(Object.getOwnPropertyDescriptor(arr, "length"));
//得到四个属性分别为：
// configurable: true  可以删除
// writable: true  可以修改
// enumerable: false  不可以输出（就是上面所提到的使用for in不能遍历出length属性）
// value: "wangcai"  默认值
1234567
```

**在给一个对象添加一个属性时，也可以自己设置上面的4个特征，使用Object.defineProperty()**

- 给obj对象添加一个name属性，自行设置四个属性：

```javascript
var obj = {};
    Object.defineProperty(obj,"name",{
        configurable:false, //不能删除
        writable:false,  //不能修改
        enumerable:true, //能输出
        value:"wangcai"  //默认值
    })
    console.log(obj) //{name: "wangcai"}
    delete obj.name; 
    console.log(obj); //{name: "wangcai"}
    obj.name = "xxx"; 
    console.log(obj); //{name: "wangcai"}
    for (const objKey in obj) {
        console.log(obj[objKey]); //wangcai
    }
123456789101112131415
```

## 5，对象属性的分类

> 对象上的属性分为两类：
>
> - 私有属性（也叫原型属性）
> - 共有属性

- 对于一个对象可以通过api来查看一个属性是否为私有属性；**api是hasOwnProperty();**
- 如果一个私有属性和公有属性重名了 会把公有属性覆盖掉

```javascript
var obj = {
        name:"wangcai",
        age:100
    }
console.log(obj.hasOwnProperty("name")); // true 查看obj对象中的name属性是不是obj的私有属性，true表示是
console.log(obj.hasOwnProperty("age"));  // true 查看obj对象中的age属性是不是obj的私有属性，true表示是
// 对于obj来说：name和age是它的私有属性  toString是它的公有属性
// 对于obj.__proto__来说：toString是它的私有属性
console.dir(obj.hasOwnProperty("toString")); // false 查看toString是否是obj的私有属性
console.log(obj.hasOwnProperty("__proto__")); // false 查看__proto__是否是obj的私有属性
console.log(obj.__proto__.hasOwnProperty("toString")); // true  // 查看toString是否是obj.__proto__这个对象的私有属性
1234567891011
```

- 判断一个属性是否属于某个对象（**hasOwnProperty**）：
- **in** ：是一个运算符，是公有属性，得到的也是true；

```javascript
var obj = {
        name:"wangcai"
    }
console.log(obj.hasOwnProperty("name"));// 判断name是否是obj的私有属性  true表示是
console.log("name" in obj); // 判断name是否是obj的属性 true表示是
console.dir(obj) //查看对象中的所有属性
console.dir("toString" in obj) // 判断toString是否是obj的属性  true
console.dir("xxx" in obj) // 判断xxx是否是obj的属性  false
12345678
```

## 6，对象都是由函数创造的

- 一个函数具有多个角色：

1. 普通的函数；
2. 类（构造器）构造器的本质就是函数；
3. 对象；

> 构造器：Array、Number都是构造器；
> 对象：标签 、Number、new Number、Document、Window、console、Array、new Array、Function、new Function等等

- 任何一个对象都有一个属性叫`__proto__`此属性也是一个对象，该对象中有一个属性叫做

```javascript
//constructor 是构造器；
console.log([1,2,3].__proto__.constructor == Array); // true 表示对象[1,2,3]的构造器就是Array；
console.log({}.__proto__.constructor == Object); // true 表示{}的构造器就是Object；
console.log(function () {}.__proto__.constructor == Function); // true 表示function () {}的构造器就是Object；
1234
```

1. 对象是由函数创建的 / 对象是由构造器构造的；
2. 构造器本质是函数；
3. 如果你把一个函数当作是一个构造器，一般情况下，首字母大写；
4. 任何一个函数都可以充当一个构造器；

## 7，函数的四种使用方式

1. 作为普通的函数；

```javascript
function f() {
        console.log("f...")
    }
   f();   // 作用1：让函数体执行    作用2：得到返回值
1234
```

1. 在对象中作为一个方法；

```javascript
let obj = {
        say:function () {  // 方法
            console.log("say...")
        },
      }
    obj.say();
123456
```

1. 作为类（构造器）；

```javascript
function NBAPlayer() {
    }
    var nbaPlayer = new NBAPlayer();//作为类，new一个新对象
123
```

1. 作为一个对象；

```javascript
function F() {
    }
    F.name1 = "wangcai"; //插入数据
    F.age = 100; //插入数据
    console.log(F.name1) //输出wangcai
    console.log(F.age) //输出100
123456
```

## 8，JS中创建对象的几种方式

> 1. 使用字量面的方式创建一个对象
> 2. 使用工厂模式创建对象
> 3. 通过构造器+原型对象来创建对象
> 4. 通过构造器+原型对象来创建对象

### **1. 使用字量面的方式创建一个对象**

```javascript
 var rect = {
        width:10,
        height:20,
        getS(){
            return this.width * this.height
        }
    }
    rect.getC = function(){
        return 2*this.width + 2*this.height;
    }
    console.log(rect.getS());  // 200
    console.log(rect.getC());  // 60
123456789101112
```

### **2. 使用工厂模式创建对象**

- 优点：可以批量创建对象

```javascript
 function createRect(w,h) {  // 工厂函数
        var obj = {};
        obj.width = w;
        obj.height = h;
        obj.getS = function () {
            return this.width * this.height
        }
        return obj;
    }
    var rect1 = createRect(1,2);
    console.log(rect1.getS());
    var rect2 = createRect(2,2);
    console.log(rect2.getS());
12345678910111213
```

### **3. 通过构造器+原型对象来创建对象**

```javascript
function Rect(w,h) {
        this.w = w; // 私有属性
        this.h = h; // 私有属性
    }
    Rect.prototype.getS = function () {  // 将方法当成一个公共属性
        return this.w*this.h;
    }
    // rect1 rect1是通过Rect构造器构造的
    var rect1 = new Rect(1,2);
    console.log(rect1.getS());
    var rect2 = new Rect(3,2);
    console.log(rect2.getS());
123456789101112
```

### **4. ES6中通过class创建类 new新对象**

```javascript
class NBAPlayer{
        constructor(name,age) {
            this.name = name;
            this.age = age;
        }
        score = 100; // 私有属性
        run(){   // 公有方法
            console.log("run....")
        }
        static xx = "123"; // 类上的属性  静态属性
    }
    var nbaPlayer1 = new NBAPlayer("乔丹",40);
    console.log(nbaPlayer1.name) //乔丹
    console.log(nbaPlayer1.age) //40
    console.log(nbaPlayer1.score) //100
    console.log(nbaPlayer1.run()) //run...   undefined（函数调用时没有返回值，就返回undefined）
    console.log(nbaPlayer1.xx) //undefined
    console.log(NBAPlayer.xx) //123 （静态属性只能通过类名去调用）
```





### 5.继承

#### **1.继承

继承，指一个对象直接使用另一对象的属性和方法。
JS里常用的有如下两种继承方式：
原型链继承（对象间的继承）
类式继承（构造函数间的继承）

#### 2.知识剖析

JavaScript语言的对象体系，不是基于“类”，而是基于构造函数（constructor）和原型（prototype）。
\*  原型对象：只要创建一个新函数，就会根据特定的规则为该函数创建一个prototype属性指向其原型对象，默认情况下原型对象会自动获得一个constructor属性，该属性包含一个指向prototype属性所在函数的指针。

```
Function.prototype.constructor === Function        //true
```

\*  构造函数：本身是一个函数，出于创建特定类型新对象的目的而定义的，内部使用this变量，需要和new配合使用来创建实例，this变量会绑定在实例对象上。

 **demo:**

```
    var f = function(){}     f.prototype.constructor === f         //true
```

#### 3.常见问题

常见的继承方式有哪些？如何实现？

#### 4.解决方案

**方法一：原型链**
原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的指针。如果：我们让原型对象A等于另一个类型B的实例，那么原型对象A就会有一个指针指向B的原型对象，相应的B的原型对象中保存着指向其构造函数的指针。假如B的原型对象又是另一个类型的实例，那么上述的关系依旧成立，如此层层递进，就构成了实例与原型的链条。
注意： 通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链。 
问题： 原型链很强大，可以利用它来实现继承，但是也有一些问题，主要的问题还是包含引用类型值的原型属性会被所有实例共享。因此我们在构造函数中定义实例属性。但是在通过原型来实现继承时，原型对象其实变成了另一个类型的实例。于是原先定义在构造函数中的实例属性变成了原型属性了。 
原型链的另一个问题是： 在创建子类型的实例时，不能在不影响所有对象实例的情况下，给超类型的构造函数传递参数。

**方法二：构造函数**
为了解决原型中包含引用类型值带来的一些问题，引入了借用构造函数的技术。这种技术的基础思想是：在子类型构造函数的内部调用超类型构造函数。 
<!-- Parent.call(this)在新创建的Child实例环境下调用Parent构造函数。这样，就在新的Child对象上，此处的kid1和kid2对象上执行Parent()函数中定义的对象初始化代码。这样，每个Child实例就都会具有自己的friends属性的副本了。 -->
借用构造函数的方式可以在子类型的构造函数中向超类型构造函数传递参数。 
构造函数模式的问题： 在于方法都在构造函数中定义，函数复用无从谈起，因此，借用构造函数的模式也很少单独使用。

**方法三：组合继承**
组合继承指的是将原型链和借用构造函数的技术组合在一块，从而发挥二者之长。即：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 
<!-- Person构造函数定义了两个属性：name和friends。Person的原型定义了一个方法sayName()。Child构造函数在调用Parent构造函数时，传入了name参数，紧接着又定义了自己的属性age。然后将Person的实例赋值给Child的原型，然后又在该原型上定义了方法sayAge().这样，两个不同的Child实例既分别拥有自己的属性,包括引用类型的属性，又可以使用相同的方法了。 -->
组合继承避免了原型链和构造函数的缺陷，融合了他们的有点，成为JavaScript中最常用的继承模式。而且，instanceOf和isPropertyOf()也能够识别基于组合继承创建的对象。

**方法四：原型式继承**
这是另一种继承，没有严格意义上的构造函数。思路是：借助原型可以基于已有的对象创建新对象，同时还不必要创建自定义类型。
在object()函数内部，先创建一个临时的构造函数，然后将传入的对象作为构造函数的原型，最后返回这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。

**方法五：寄生式继承**
寄生式继承是与原型式继承紧密相关的一种思路，与寄生式构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。
使用寄生式继承来为对象添加函数，会由于不能做到函数的复用而降低效率；这一点和构造函数继承模式类似。

**方法六：寄生组合式继承**
所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链来继承方法。寄生组合式继承的基本思路：不必为了指定子类型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承超类型的原型，然后再将结果指定给子类型的原型。

```
function inheritPrototype(child, parent){    var prototype = object(parent.prototype);  // 创建对象    prototype.constructor = child;         // 增强对象    child.prototype = prototype;           // 指定对象}
```

####  6.扩展思考

**寄生组合式继承和组合式继承，两者有什么区别？**

组合继承最大的问题就是无论什么情况下，都会调用俩次超类型构造函数Parent()：一次是在创建子类型原型的时候( Parent.call(this,name); )，另一个是在子类型构造函数内部( Child.prototype = new Parent(); )。
寄生组合式继承的基本思路：不必为了指定子类型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。

#### 7.参考文献

参考一：JavaScript高级程序设计（第3版）
参考二：JS实现继承的几种方式详述（CSDN)————https://blog.csdn.net/liuyan19891230/article/details/50774439
参考三：JS继承的6种方式（CSDN)————https://blog.csdn.net/hhthwx/article/details/78095944
参考四：js继承的常用方法————https://www.cnblogs.com/chenwenhao/p/6980401.html

#### 8.更多讨论

Q1：继承一般用到什么地方？
A ：通常在一般的项目里不需要，因为应用简单，但你要用纯js做一些复杂的工具或框架系统就要用到了，比如webgis、或者js框架如jquery、angular、vue什么的，不然一个几千行代码的框架不用继承得写几万行，甚至还无法维护。

Q2：如何确定原型和实例之间的关系？ 
A：两种方法：第一种是使用instanceOf操作符，第二种是使用isPrototypeOf()方法。 

```
eg：console.log(person instanceOf Child);//true console.log(Child.prototype.isPrototypeOf(instance));//true 
```

Q3：什么是浅复制？
A ：浅复制是复制引用，复制后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响。





# 第9章  代理与反射

## 一、代理(Proxy)

什么是‘代理’ 呢？代理：就是调用new 创建一个和目标（traget）对象一直的虚拟化对象，然该代理中就可以拦截JavaScript引擎内部目标的底层对象的操作；这些底层操作被拦截后会触发响应特定操作的陷阱函数
来看个简单的案例

```js
	let tartget = {};
	let proxy = new Proxy(target,{});
	proxy.name = 'proxy';
	console.log(proxy.name); // proxy
	console.log(tartget .name); // proxy
	
	tartget .name = 'tartget';
	console.log(proxy.name); // target
	console.log(tartget .name); // target
123456789
```

如案例
如`proxy.name = 'proxy';` 将proxy赋值给proxy.name时，代理就会将该操作转发给目标，执行name属性的创建；然而他只是做转发而不会存储该属性；
so他们之间存在一个相互引用；tartget .name设置一个新值后，proxy.name值也改变了；

## 二、反射(Reflect)

那反射又是什么呢？反射：它提供了一个Reflect对象API;该对像中的方法默认特性与底层的操作对应；而每一个代理陷阱会对应一个命名和参数都相同的Reflect方法（其实就是每个代理陷阱都会对应一个Reflect api接口供覆写JavaScript底层操作）

映射关系如下表：

| 代理陷阱                 | 覆写的特性                                                   | 默认特性                           |
| ------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| get                      | 读写一个属性值                                               | Reflect.get()                      |
| set                      | 写入一个属性                                                 | Reflect.set()                      |
| has                      | in操作                                                       | Reflect.has()                      |
| deleteProperty           | delete操作符                                                 | Reflect.deleteProperty()           |
| getAPrototypeof          | Object.getAPrototypeof ()                                    | Reflect.getAPrototypeof ()         |
| setAPrototypeof          | Object.setAPrototypeof ()                                    | Reflect.setAPrototypeof ()         |
| isExtensible             | Object.isExtensible()                                        | Reflect.isExtensible()             |
| preventExtensions        | Object.preventExtensions()                                   | Reflect.preventExtensions()        |
| getOwnPropertyDescriptor | Object.getOwnPropertyDescriptor()                            | Reflect.getOwnPropertyDescriptor() |
| defineaProperty          | Object.defineaProperty()                                     | Reflect.defineaProperty()          |
| ownKeys                  | Object.keys() 、 Object.getOwnPropertyNames()和 Object.getOwnPropertySysmbols() | Reflect.ownKeys()                  |
| apply                    | 调用一个函数                                                 | Reflect.apply()                    |
| construct                | 用new调用一个函数                                            | Reflect.construct()                |

## 三、使用set陷阱验证属性

接下来使用set陷阱来验证一下对象属性赋值操作（如为对象新增属性，要求必须赋值为int）

```js
	let target = {
		name :'target'
	};
	let proxy = new Proxy(target,{
		set(trapTarget,key,value,receiver){
			//忽略不希望受到影响的已有属性
			if(!trapTarget.hasOwnProperty(key)){
				if(isNaN(key)){
					throw new TypeError("属性必须是数字哟，亲！");
				}
			}
			// 添加属性
			return Reflect.set(trapTarget,key,value,receiver);
		}
	});
	
	// 添加一个新属性
	proxy.count = 1;
	console.log(proxy.count); // 1
	console.log(proxy.count); // 1
	
	// 由于目标已有name属性，so 如上第一个if不成立(赋值成功)
	proxy.name= "proxy";
	console.log(proxy.name); // proxy
	console.log(proxy.name); // proxy
	
	// 新建一个属性同时赋值一个非int 值，第一个if成立，第二个if验证isNaN(key) = true 即抛出异常
	proxy.anotherName = "proxy";
12345678910111213141516171819202122232425262728
```

案例中`set(trapTarget,key,value,receiver)` 这个set陷阱默认接收 四个参数

- trapTarget 用于接收属性（代理的目标）的对象
- key 要写入的属性键（字符串或Symbol类型）
- value 被写入的属性的值
- receiver 操作发生的对象（通常是代理）

## 四、使用get 陷阱验证对象结构

如

```js
let target = {};
console.log(target.name); // undefined
12
```

在JavaScript中调用一个对象不存在的属性不会报错，反而使用undefined代替被读取属性的值

而喝多时候会带来意想不到的bug，现在我们可以使用get陷阱来验证该问题
依然看这个案例

```js
	let proxy = new Proxy(target,{
		get(trapTarget,key,receiver){
			//忽略不希望受到影响的已有属性
			if(!(key in receiver)){
				throw new TypeError("sorry 亲！ 你找的 "+key+" 属性不存在。！")
			}
			// 添加属性
			return Reflect.get(trapTarget,key,receiver);
		}
	});
	// 添加一个属性，
	proxy.name= "proxy";
	console.log(proxy.name); // proxy

	// 读取一个不存在的属性  直接会抛出异常
	console.log(proxy.nme);
12345678910111213141516
```

如上使用in操作判断receiver中是否存在被读取的属性；如果没有抛出异常

其中`get(trapTarget,key,receiver)` 参数

- trapTarget 被读取属性源对象（代理的目标）
- key 要读取的属性键（字符串或Symbol类型）
- receiver 操作发生的对象（通常是代理）

结合上面3、4 的操作可以封装一个带自定义检测的对象，为以后自己写插件打下基础

```js
	let originObj = {
		employee:'jack'
	};
	
	let optObj = new Proxy(originObj,{
		set(trapTarget,key,value,receiver){
			// 忽略原有属性
			if(!trapTarget.hasOwnProperty(key)){
				if(!isNaN(value)){ // 属性不能位数字
					throw new TypeError('属性不能为数字！')
				}
			}
			// 添加属性
			return Reflect.set(trapTarget,key,value,receiver);
		},
		get(trapTarget,key,receiver){
			if(!(key in receiver)){
				throw new TypeError('属性'+key+'不存在');
			}
			
			return Reflect.get(trapTarget,key,receiver);
		}
	});
			
12345678910111213141516171819202122232425
```

用node测试哈

```shell
	> optObj.sex = 'female';
	'female'
	> console.log(optObj.sex);
	female
	undefined
	> console.log(originObj.sex);
	female
	undefined
	> optObj.age =18;
	Thrown:
	TypeError: 属性不能为数字！
	    at Object.set (repl:6:14)
	> console.log(optObj.age);
	Thrown:
	TypeError: 属性age不存在
	    at Object.get (repl:14:13)
	> console.log(optObj.name)
	Thrown:
	TypeError: 属性name不存在
	    at Object.get (repl:14:13)
	> console.log(optObj.employee)
	jack
	
123456789101112131415161718192021222324
```

## 五、函数代理apply和construct陷阱

使用这个两个陷阱来验证函数调用时的参数的正确性
如下案例

```js
	// 参数求和
	function sum (...values){
		return values.reduce((previous,current) => prvious + current, 0);
	}
	
	let sumProxy = new Proxy(sum,{
		apply:function(trapTarget,thisArg,argumentList){
			argumentList.forEach(arg => {
				if(typeof arg !== "number"){
					throw new TypeError("所有参数必须是数字，亲！");
				}
			});
			return Reflect.apply(trapTarget,thisArg,argumentList);
		},
		// 防止使用new 关键字调用
		construct:function(trapTarget,argumentList){
			throw new TypeError("亲，你不能这么干，该函数不能通过new调用。");
		}
	});
	
	// 测试哈
	console.log(sumProxy(1,2,3,4)); // 10
	
	// 传入一个非数字的属性值试试 【直接抛出异常】 
	console.log(sumProxy(1,“2”,3,4)); // 10
	
	// 同样使用new调用 【直接抛出异常】 
	let result = new sumProxy();

123456789101112131415161718192021222324252627282930
```

apply陷阱和Reflect.apply()都接受同样的参数

- trapTarget 被执行的函数（代理的目标）
- thisArg 函数被调用时内部的this的值
- argumentList传递给函数的参数数组

**当使用new调用函数时 会触发construct陷阱，接收的参数为**

- trapTarget 被执行的函数（代理的目标）
- argumentList传递给函数的参数数组

其中Reflect.construct()第三个参数是newTarget 这是一个可选参数。用于指定该函数内部
new.target的值











# 第10章        函数





函数的基本概念、声明及调用；函数作用域、作用域链、闭包；this指向及修改和绑定this指向等。

## 1.函数概念，声明及调用

JS中的函数：把一段需要重复使用的代码，用function语法包起来，方便重复调用，分块和简化代码。复杂一点的，也会加入封装、抽象、分类等思想。

声明方式：严格意义上两种方式，但还有匿名函数

- 方式一：

```javascript
function 方法名(){     //要执行的代码}
```

- 方式二：ES6中声明方式箭头函数，()=>{} 
- 方式三：匿名函数，将函数存到变量里 var func = function(){};

函数调用：两种方式调用

- 调用方式一：名字(); 函数可以多次调用

```javascript
//函数声明function fn(){    console.log(1);} //函数的调用fn();
```

调用方式二：在事件中调用，直接写函数名，不使用括号

```javascript
//函数声明function fn(){    console.log(1);} //函数在事件中的调用document.onclick = fn;
```

## 2.函数表达式（匿名函数）

函数表达式：就是把函数存到变量里。

匿名函数：没有名字的函数；

匿名函数在使用时只有两种情况：

- 匿名函数自执行：声明后不需要调用就直接执行

```javascript
(function(){    console.log("匿名函数自执行");})();
```

- 函数表达式：把函数存到变量，或将函数存到数组的对应位置里等，调用时通过变量或数组对应位置进行调用。调用时需要写括号。

```javascript
//2，函数表达式：把函数存到变量或数组等里，调用时通过变量进行调用var fn = function(){    console.log("函数表达式：将函数存到变量里");};fn();//调用时需要写括号 //2，函数表达式：把函数存到数组第0位，调用时通过数组第0位进行调用var arr = [];arr[0] = function(){     console.log("函数表达式：将函数存到数组的对应位置");};arr[0]();//调用时需要写括号要写括号
```

结果：

![img](https://img-blog.csdnimg.cn/20190711101304294.png)

事件函数扩展：给元素添加事件的说法是不正确的。事件时元素本身就具有的特征，只是触发事件后，默认没有相关的一些处理。这种操作其实就是给元素的某个事件添加一个事件处理函数。当事件被触发后，判断到属于该事件类型，就触发该事件函数的处理函数。

可以通过console.dir()把对象的所有属性和方法打印出来，查看对象或元素本身具有的事件。

```javascript
<script>       //事件时元素本身就具有的特征，只不过，触发事件后，默认没有相关的一些处理。事件函数其实就是给元素的某个时间添加一个事件处理函数。       //可以通过console.dir()把对象的所有属性和方法打印出来       document.onclick = function(){           console.log("事件的处理函数");       };       //当被触发后，判断到属于该事件类型，就触发该事件函数的处理函数       if(typeof document.onclick == "function"){         document.onclick();       }</script> 
```

 结果：

![img](https://img-blog.csdnimg.cn/20190711103026185.png)

## 3.函数传参

获取元素，最好从父级元素获取，全部从document中获取，可能会出现混乱。

- 形参：形式上的参数——给函数声明一个参数；
- 实参：实际的参数——在函数调用时给形参赋的值

```javascript
function func(形参1,形参2){    //函数执行代码} func(实参1,实参2);//调用时传参
```

什么时候使用到传参？当有两段代码本身的功能极其相似，只有个别地方不一样时，就可以把两段代码合并成一个函数，然后把两段代码中不一致的内容通过传参传进去。

案例：自定义（多个模块）选项卡封装

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <script src="../index.js"></script>    <title>选项卡封装</title>    <style>        body { margin: 0; padding: 0; }        .tab .active { background: red; }        .cont div { display: none; }        .cont .show { background: #000; font-size: 60px; color: white; width: 220px; height: 220px; display: block;  }    </style></head><body><div id="wrap1" class="wrap">    <div class="tab">        <button class="active">选项卡一</button>        <button>选项卡二</button>        <button>选项卡三</button>    </div>    <div class="cont">        <div class="show">内容一</div>        <div>内容二</div>        <div>内容三</div>    </div></div> <div id="wrap2" class="wrap">        <div class="tab">            <button class="active">选项卡一</button>            <button>选项卡二</button>            <button>选项卡三</button>        </div>        <div class="cont">            <div class="show">内容一</div>            <div>内容二</div>            <div>内容三</div>        </div></div><div id="wrap3" class="wrap">        <div class="tab">            <button class="active">选项卡一</button>            <button>选项卡二</button>            <button>选项卡三</button>        </div>        <div class="cont">            <div class="show">内容一</div>            <div>内容二</div>            <div>内容三</div>        </div></div><script>     //通过id获取元素    /*    var wrap1 = _id("wrap1");    var wrap2 = _id("wrap2");    var wrap3 = _id("wrap3");        tab(wrap1);    tab(wrap2);    tab(wrap3);    */   //通过数组方式获取一组    var wraps = _selectorAll(document,".wrap");//注意这里的parent父级已经是body了， 所以最好使用document    for (var i = 0; i < wraps.length; i++) {        tab(wraps[i]);    }    function tab(wrap){        var btn = _selectorAll(wrap,".tab button");        var divs = _selectorAll(wrap,".cont div");         var num = 0;//记录当前样式        for (var i = 0; i < btn.length; i++) {            btn[i].index = i;            btn[i].onclick = function(){                //清除当前样式                btn[num].classList.remove("active");                divs[num].classList.remove("show");                 this.classList.add("active");                divs[this.index].classList.add("show");                 num = this.index;            };        }    }</script></body></html>
```

index.js:

```javascript
function _id(idName){    return document.getElementById(idName);}function _selector(parent,selector){    return parent.querySelector(selector);}function _selectorAll(parent,selectors){    return parent.querySelectorAll(selectors);}
```

 结果：

![img](https://img-blog.csdnimg.cn/20190711114731833.png)

## 4.修改input的值

value和innerHTML都可以用来获取和修改元素的值（或内容）；value只能获取特定的textarea和input的值，但是innerHTML可以获取所有HMTL元素的值。

不同之处如下：
1）value可以用来修改（获取）textarea和input的value属性的值或元素的内容；
2）innerHTML用来修改（获取）HTML元素（如div）html格式的内容。

![img](https://img-blog.csdnimg.cn/20190710215232228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <script src="../index.js"></script>    <title>修改input的值</title>    <style>        .wrap input, .wrap button { display: none; }        li { height: 30px; line-height: 30px; }    </style></head><body>    <div class="wrap">        <ul>            <li>                <span id="first">这是第一个列表</span>                <a href="javascript:;">修改</a>                <input type="text">                <button>确定</button>            </li>            <li>                <span>这是第二个列表</span>                <a href="javascript:;">修改</a>                <input type="text">                <button>确定</button>            </li>            <li>                <span>这是第三个列表</span>                <a href="javascript:;">修改</a>                <input type="text">                <button>确定</button>            </li>            <li>                <span value="asf">这是第四个列表</span>                <a href="javascript:;">修改</a>                <input type="text">                <button>确定</button>            </li>         </ul>    </div>    <script>        var lis = _selectorAll(document,"li");        for (var i = 0; i < lis.length; i++) {            modify(lis[i]);        }        function modify(li){            var modify = _selector(li,"a");            var span = _selector(li,"span");             var input = _selector(li,"input");            var btn = _selector(li,"button");            //1.点击修改，“这是第一个列表”span标签隐藏，“修改”标签隐藏；input和确定按钮显示            modify.onclick = function(){                span.style.display = "none";                this.style.display = "none";                input.style.display = "inline-block";                btn.style.display = "inline-block";                 //注意：span标签只能通过.innerHTML获取元素的值，而不能通过.value                //2.将span标签的文字内容赋值给input输入框                input.value = span.innerHTML;            };            //3.点击确定按钮，先验证是否为空；再还原会span标签和修改a标签            btn.onclick = function(){                var txt = input.value;                if(txt === ""){                    alert("请输入内容");                }else{                    input.style.display = "none";                    this.style.display = "none";                    span.style.display = "inline-block";                    modify.style.display = "inline-block";                     //4.将修改后的值赋给span标签                    span.innerHTML = txt;                }            };        }    </script></body></html>
```

结果：

![img](https://img-blog.csdnimg.cn/20190711141714766.png)![img](https://img-blog.csdnimg.cn/2019071114180094.png) ![img](https://img-blog.csdnimg.cn/2019071114174753.png)

## 5.函数的不定参（可变参）—关键字arguments

案例：购物车商品累计。事先不知道用户买多少商品

不定参（可变参）使用关键字：arguments，代表所有实参的集合。通过下标获取参数的每一位；通过length获取实参的个数；

集合是类数组，可以使用下标，但是没有数组中的各种方法。

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>可变参（不定参）：arguments</title></head><body>    <script>        //arguments 代表所有实参的集合（类数组），可以通过下标获取各个实参，通过length获取集合长度        function args(){            console.log(arguments);            console.log("arguments的各个参数为：");            for (var i = 0; i < arguments.length; i++) {                console.log(arguments[i]);            }        }                 args(23,45,999,10.90,"can","不定参");    </script></body></html>
```

结果：

 ![img](https://img-blog.csdnimg.cn/20190711142625883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

## 6.函数返回值

函数返回值即函数执行之后的返回结果。

1. 所有函数都会有函数返回值即函数执行后一定会返回一个结果，如果没有定义默认返回undefined；
2. 在函数中，return后定义返回值；
3. 在函数中，return之后的代码就不会再执行了
4. return只能用于函数中，用在其他地方会报错

```javascript
<script>        function func1(){           console.log("函数func1执行内容");        }         function func2(){           console.log("函数func2执行内容");           return 1;           var a = 2;           console.log(a);        }         //如果没有定义默认返回undefined        console.log("func1返回结果："+func1());//undefined        console.log("func2返回结果"+func2());//1</script>
```

结果：发现return后的代码没有继续执行

![img](https://img-blog.csdnimg.cn/2019071114333389.png)

## 7.封装获取元素的方法

封装通过id/CSS选择器获取（一般在父级下获取，所以传入父级和选择器名字）获取多个元素的方法，然后返回获取到的值

```javascript
//通过id名获取元素function _id(idName){    return document.getElementById(idName);} //通过CSS选择器获取一个元素function _selector(parent,selector){    return parent.querySelector(selector);} //通过CSS选择器获取一组元素function _selectorAll(parent,selectors){    return parent.querySelectorAll(selectors);}
```

使用：

```javascript
var wrap1 = _id("wrap1");var wrap2 = _id("wrap2");var wrap3 = _id("wrap3"); var wraps = _selectorAll(document,".wrap"); var btn = _selectorAll(wraps,".tab button");var divs = _selectorAll(wraps,".cont div");
```

## 8.获取计算后样式—getComputedStyle(el)

点击时获取box的宽度，在原有基础上+100

- 从style中获取的是行间样式，但是通常样式不会写在行间；
- 获取计算后样式：getComputedStyle(el)获取元素的计算后样式。属于window的方法，即window.getComputedStyle(el)。在JS中使用window下的方法时，window可以不写；
- getComputedStyle(el)方法不兼容IE6,7,8；
- 计算后样式：优先级最高的样式，即当前显示出来的样式
- 使用getComputedStyle(el)是获取window下所有的样式，getComputedStyle(el)['样式名']即可获取到特定样式
- 写样式名时，使用驼峰样式的名字（否则IE下会有兼容问题），如margin-left必须写成marginLeft。
- IE下获取元素的计算后样式，需要使用el.currentStyle['样式名']
- 兼容IE和其他浏览器：判断el.currentStyle返回true即表示IE，否则就是其他浏览器，然后在对应浏览器下使用对应方法
- 获取计算后样式会经常使用，因此可以封装成方法，进行复用
- getComputedStyle(el)和el.currentStyle获取不到伪元素的样式，因为伪元素不是DOM的内容
- 伪类样式计算后样式可以获取到，伪元素获取不到

标准浏览器下：transition:.5s;设置过渡效果的时间，否则div会直接变到从100+100的宽度

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <script src="../index.js"></script>    <title>getComputedStyle(el)</title>    <style>        #box { width: 100px; height: 100px; background: red; transition:.5s; }    </style></head><body>    <div id="box"></div>    <script>        //需求：点击div，div的width在原有基础上+100px        var box = _id("box");        var ss = 0;        box.onclick = function(){            //直接获取box.style.width是获取不到的，因为样式时写到style标签，而非行间样式            //console.log(box.style.width);//获取不到值             //使用getComputedStyle(el)['样式名']即可获取到当前显示出来的样式            var curStyle = getComputedStyle(box)['width'];            //获取到的结果是“100px”，需要将其进行转为数字。width最后有可能会有小数点，所以最好使用parseFloat()。大多数情况下parseInt()亦可            //但是parseInt(curStyle);才能去掉px进行相加            //注意px前面的数字千万不要加引号            this.style.width = parseInt(curStyle) + 100 + 'px';        };    </script></body></html>
```

结果：

![img](https://img-blog.csdnimg.cn/20190711152542637.png)

不断点击后：

![img](https://img-blog.csdnimg.cn/201907111526019.png)

兼容问题：发现在IE6,7，8下并不支持getComputedStyle(el)方法

![img](https://img-blog.csdnimg.cn/20190711152655563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

解决：通过el.currentStyle判断返回true代表在IE浏览器下，为false就不是在IE浏览器下。在IE浏览器下必须使用el.currentStyle才行

```javascript
//解决浏览器兼容问题：通过el.currentStyle判断返回true代表在IE浏览器下，为false就不是在IE浏览器下。在IE浏览器下必须使用el.currentStyle才行function currStyle(el,styleName){    // var curStyle = '';    // if(el.currentStyle){    //     curStyle = el.currentStyle[styleName];    // }else{    //     curStyle = getComputedStyle(el)[styleName];    // }    // return curStyle;    //使用三元获取返回值    return el.currentStyle?el.currentStyle[styleName]:getComputedStyle(el)[styleName];}
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <script src="../index.js"></script>    <title>getComputedStyle(el)</title>    <style>        #box { width: 100px; height: 100px; background: red; transition:.5s; }    </style></head><body>    <div id="box"></div>    <script>        //需求：点击div，div的width在原有基础上+100px        var box = _id("box");         box.onclick = function(){            //直接获取box.style.width是获取不到的，因为样式时写到style标签，而非行间样式            //console.log(box.style.width);//获取不到值             //使用getComputedStyle(el)['样式名']即可获取到当前显示出来的样式            // var curStyle = getComputedStyle(box)['width'];            var curStyle = currStyle(box,'width');            //获取到的结果是“100px”，需要将其进行转为数字。width最后有可能会有小数点，所以最好使用parseFloat()。大多数情况下parseInt()亦可            //但是parseInt(curStyle);才能去掉px进行相加            //注意px前面的数字千万不要加引号            this.style.width = parseInt(curStyle) + 100 + 'px';        };    </script></body></html>
```

结果：

![img](https://img-blog.csdnimg.cn/201907111546125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190711154634473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

## 8.JS预解析机制（变量提升Hoisting）

JS预解析机制（变量提升（Hoisting））：JS在读取到一个script标签（或者一个函数作用域）时，会先进行一个预解析的过程，在这个过程中，会把var声明的变量和function声明的函数体，提升到整个scriptt标签（或者一个函数作用域）最前边去。在预解析完之后，JS才会从上到下一行一行解析代码并执行。

- var在预解析时，会把声明提升到最前边（赋值前打印返回undefined）。只提升声明，不会把赋值过程进行提升。
- function的函数体在预解析时，会把整个函数体提升至最前边。（函数体：function fn(){ console.log(1);}）
- 函数表达式（函数表达式：var fn = function(){};）只会提升函数表达式的声明，不会执行（真正执行函数表达式前调用会返回undefined）
- 在预解析时，会先预解析var（包括变量声明和函数表达式的变量声明），把var放在最前面，然后再预解析function，所以当var和function重名时，function会覆盖var;

```javascript
   //JS var变量的预解析    console.log("var变量的预解析："+a);//undefined    var a = 0;     //JS函数体的预解析    console.log("函数体的预解析:"+fn);    function fn(){        console.log("函数");    }    //JS函数表达式的预解析    console.log("函数表达式的预解析:"+fnn);    var fnn = function(){        console.log("函数表达式");    };
```

结果：

![img](https://img-blog.csdnimg.cn/20190712224155985.png)

在预解析时，会先预解析var，把var放在最前面，然后再预解析function，所以当var和function重名时，function会覆盖var：

```javascript
    /*        解析过程：先预解析var声明的a,再预解析函数体a，后面覆盖前面，所以最后结果是function函数体        var a;        function a(){console.log("函数a");};//此函数体解析后会覆盖变量a    */    console.log(a);    var a = 0;    function a(){        console.log("函数a");    }
```

结果：

![img](https://img-blog.csdnimg.cn/20190712225127830.png)

JS预解析示例：

```javascript
    //JS预解析过程：遇到Script标签或一个函数作用域，会先进行预解析，先预解析var声明的变量(包括普通变量声明和函数表达式声明)，再声明function函数体，如果有重名function声明会覆盖var声明    /*        预解析之后代码：        var a;//变量a        var a;//函数表达式a(函数表达式也是var声明)        function a(){//函数体            console.log(1);        };        console.log(a);//打印函数体a        var a = 10;        console.log(a);//10        console.log(a);//10        a = function(){            console.log(2);//打印函数表达式a        };        console.log(a);    */    console.log(a);    var a = 10;     console.log(a);    function a(){        console.log(1);    };     console.log(a);    var a = function(){        console.log(2);    };     console.log(a);
```

结果：

![img](https://img-blog.csdnimg.cn/20190712231005390.png)

JS预解析机制不是良好的编码习惯，不利于代码维护，建议不要使用，编码时建议先声明，再使用。

扩展：从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。

ES6之后就不能像JS预解析这么编写JS代码了。

## 9.作用域

![img](https://img-blog.csdnimg.cn/20190713203625134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

通常来说一段程序代码中使用的变量和函数并不总是可用的，限定其可用性的范围即作用域，作用域的使用提高了程序逻辑的局部性，增强程序的可靠性，减少名字冲突。

通俗的说，作用域：数据起作用的范围（某条数据可以在什么范围内使用）

前端权威官方MDN：https://developer.mozilla.org/en-US/docs/Glossary/Scope

作用域的分类：

1. \- 全局作用域：通过var或function声明在全局（声明在任意函数之外和代码块之外）中的数据，在全局的任意地方都可以调用或修改（即全局变量）和在window下的属性
2. \- 局部作用域：

- 函数作用域：声明在函数内部的某个数据（var，function，参数）,就只能在函数内部使用（函数的局部作用域）
- 块级作用域（ES6新增）

全局作用域：

```javascript
    //声明在全局中的变量    var a = 0;    console.log(a);//可在全局任意地方调用    function fn(){        console.log(a);//可在函数中调用        a = 10;//可在任意地方修改全局中的变量    }    fn();    console.log(a);
```

结果：

![img](https://img-blog.csdnimg.cn/20190712232941277.png)

## 10.window

- 在JS中，默认情况下 var声明的全局变量和function声明的全局函数会挂载在window上(所以要避免声明全局变量和全局函数)
- 在JS中，默认全局数据都会保存在window下（ES6之前）
- 另外window是JS在浏览器里的顶层对象，所以window的属性和方法也都是全局的
- 在JS中，调用window下的属性和方法，默认可以不写window，所以如果在函数里面声明变量没有写var，会把其当做window的一个属性；（不规范写法，要避免）

```javascript
    //var声明的全局变量和function声明的全局函数，都默认挂载在window上    var a = 0;    console.log(window);     function fn(){        b = 10;        console.log(1);    }    fn();    console.log(b);//此处b没有写声明的var所以，b=10即为window.b = 10;相当于挂载在window上的全局变量     //在JS中，默认全局数据都会保存在window下    //window是浏览器的最顶层对象，所以默认window下的属性和方法都是全局的。所以window下的方法和属性，默认可以不写window
```

 结果：全局变量a和全局函数fn()都默认挂载在window上。而且，此处b没有写声明的var，所以，b=10即相当于window.b = 10;也是挂载在window上的全局变量：

![img](https://img-blog.csdnimg.cn/20190712234010283.png)

![img](https://img-blog.csdnimg.cn/20190712234025990.png)

![img](https://img-blog.csdnimg.cn/20190712234157837.png)

## 11.全局污染（命名冲突问题）

全局变量污染：大家都在全局中写代码，很容易造成命名冲突，导致代码冲突。ES6中代码冲突会直接报错。所以要养成好的习惯不要在全局去声明变量。

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>全局污染</title></head><body>    <div id="list"></div>    <div class="memulist"></div>    <script>        var list = document.getElementById("list");        var list = document.querySelector(".memulist");        console.log(list);    </script></body></html>
```

 结果：发现最后获取的只有一个元素，所以很容易造成代码冲突

![img](https://img-blog.csdnimg.cn/2019071223473624.png)

解决：不要声明全局变量

```javascript
(function(){     var list = document.getElementById("list");     console.log(list);})(); (function(){      var list = document.querySelector(".memulist");      console.log(list);})();
```

结果： 

![img](https://img-blog.csdnimg.cn/20190712235003569.png)

JS中提供了id使用的简便方法，直接调用id名即可：但尽量不要这么写，不规范：

```javascript
console.log(list);
```

![img](https://img-blog.csdnimg.cn/20190712235243798.png)

匿名函数：匿名函数自执行本身就是为了避免在全局写代码，避免冲突的。匿名函数自执行也叫开启一个新的命名空间。即开启新的作用域，此作用域和其他的不会冲突。

## 12.作用域链（scope chain）

作用域链决定了哪些数据能被函数访问。当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。

作用域链：JS中数据的查找规则。

作用域链查找过程：在JS中我们调用一条数据时，会先在当前作用域进行查找，如果找不到，就从向上找父作用域的数据，还找不到就接着向上，一直找到全局作用域（window对象），window都找不到就报错。

```javascript
    //调用fn()时，在其子函数fn2()被调用时，首先会在fn2()自己的作用域内找变量a    //找不到就在其父级作用域即fn()作用域中找，即a=10，然后打印a=10    function fn(){        var a = 10;        function fn2(){            console.log(a);        }        fn2();    }    fn();
```

 结果：![img](https://img-blog.csdnimg.cn/20190713000907856.png)

作用域链查找关系图：

![img](https://img-blog.csdnimg.cn/20190713001146465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

 作用域链示例：

```javascript
<script>    function fn(){        var b = 0;        return function(){            b++;            console.log(b);        };    }    var f = fn();    console.log(f);//ƒ (){ b++; console.log(b); }    f();//1    f();//2    f();//3    fn()();//1</script> 
```

结果：

![img](https://img-blog.csdnimg.cn/20190713133402460.png)

解析（函数拆分）三个f()：

注意：这里的var f = fn();是将函数fn()的返回值函数体f(){ b++; console.log(b); };赋给变量f，但是并没有执行该返回值函数体，当f()调用时，便执行了该函数体。f此时是fn的子函数，那它可以访问和更改父级fn的作用域中的b。

b变量会一直赋值，是因为JS的垃圾回收机制决定的，只要检测都有引用存在，就不会释放。

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>作用域链示例-函数拆分</title></head><body><script>    // function fn(){    //     var b = 0;    //     return function(){    //         b++;    //         console.log(b);    //     };    // }    // var f = fn();    // f();//1    // f();//2    // f();//3    // fn()();//1    //这里的var f = fn();是将函数fn()的返回值函数体function(){ b++; console.log(b); };赋给变量f，但是并没有执行该返回值函数体，当f()调用时，便执行了该函数体    //即这里的三个f()相当于，在函数fn()中写了三个子函数，再进行调用    //由于b变量对于fn1(),fn2(),fn3()都是父级变量，所以每次b++都会将b的值+1,所以最后得到的值即1，2，3    function fn(){        var b = 0;        function fn1(){            b++;            console.log(b);        }        fn1();        function fn2(){            b++;            console.log(b);        }        fn2();        function fn3(){            b++;            console.log(b);        }        fn3();    }     fn();</script>    </body></html>
```

结果：所以执行三个f();和执行三个fn();得到的结果是不一样的。

![img](https://img-blog.csdnimg.cn/20190713003315839.png)

以上进一步分解：

 

```javascript
<script>    // function fn(){    //     var b = 0;    //     return function(){    //         b++;    //         console.log(b);    //     };    // }    // var f = fn();    // f();//1    // f();//2    // f();//3    // fn()();//1    //这里的var f = fn();是将函数fn()的返回值函数体function(){ b++; console.log(b); };赋给变量f，但是并没有执行该返回值函数体，当f()调用时，便执行了该函数体    //即这里的三个f()相当于，在函数fn()中写了三个子函数，再进行调用    //由于b变量对于fn1(),fn2(),fn3()都是父级变量，所以每次b++都会将b的值+1,所以最后得到的值即1，2，3    function fn(){        var b = 0;        // function fn1(){        //     b++;        //     console.log(b);        // }        // fn1();        // function fn2(){        //     b++;        //     console.log(b);        // }        // fn2();        // function fn3(){        //     b++;        //     console.log(b);        // }        // fn3();        function fnn(){            b++;            console.log(b);        }        fnn();        fnn();        fnn();     }    fn();</script>   
```

结果：所以调用三次f()和再fn()函数里执行三次fnn()是一样的

![img](https://img-blog.csdnimg.cn/20190713134431799.png)

函数拆分fn()():

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>作用域链示例——函数拆分fn()()</title></head><body><script>    // function fn(){    //     var b = 0;    //     return function(){    //         b++;    //         console.log(b);    //     };    // }    // var f = fn();    // f();//1    // f();//2    // f();//3    // fn()();//1     //此处的fn()();第一个括号表示执行fn()函数，第二个括号表示执行fn()函数中返回值中的函数，所以fn()()相当于整个fn函数再执行一次    //函数每次调用，都相当于把这个代码复制出来执行了一遍。所以fn()();每次执行都是重新执行一遍代码，相当于以下：    function fn(){        var b = 0;        return function(){            b++;            console.log(b);        };    }    function fnA(){        var b = 0;        return function(){            b++;            console.log(b);        };    }    fn()();//1    fnA()();//1</script></body></html>
```

结果：

![img](https://img-blog.csdnimg.cn/20190713003930318.png)

函数每次调用，如fn()和fnA()之间没有任何关联，都相当于把这个代码复制出来执行了一遍。

## 13.闭包

闭包是对作用域链的一种表现和使用。

函数对象可以通过作用域链相互关联起来，函数体内的数据(变量和函数声明)都可以保存在函数作用域内，这种特性在计算机科学文献中被称为“闭包”。既函数体内的数据被隐藏于作用于链内，看起来像是函数将数据“包裹”了起来。从技术角度来说，js的函数都是闭包：函数都是对象，都关联到作用域链，函数内数据都被保存在函数作用域内。

fn()();调用函数后的返回值还是一个函数，也对其进行执行

函数的每次执行之间没有任何关系。每次执行都相当于在JS内部吧代码重新写了一遍。

面试时：闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取[局部变量](https://baike.baidu.com/item/局部变量/9844788)，所以闭包可以理解成“定义在一个[函数](https://baike.baidu.com/item/函数/301912)内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

闭包：

- 形式：函数嵌套函数；
- 作用：子函数可以访问父函数的作用域，但是父级不能访问子级的。

闭包示例：

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>闭包</title></head><body><script>    function fn(){        var a = 0;        function fn2(){            console.log(a);//fn2是fn的子函数，所以可以访问父级作用域的a        }        fn2();    }    fn();    console.log(a);//在fn函数作用域外，不能访问其子级作用域fn中的变量a</script></body></html>
```

结果：

![img](https://img-blog.csdnimg.cn/201907131359273.png)

闭包应用：i传参给了fn函数，而点击事件是fn函数的子函数，所以也可以获取到fn函数中的i

```html
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>闭包应用</title></head><body>    <button>按钮一</button>    <button>按钮二</button>    <button>按钮三</button>    <script>        var btns = document.querySelectorAll("button");        for (var i = 0; i < btns.length; i++) {            fn(i);        }        //i传参给了fn函数，而点击事件是fn函数的子函数，所以也可以获取到fn函数中的i        function fn(index){            btns[index].onclick = function(){                console.log(index);            };        }    </script></body></html>
```

结果：按钮进行循环后会将当前index传参给fn函数，当点击按钮时，再通过父级作用域获取到父级的index

![img](https://img-blog.csdnimg.cn/20190713142338290.png)

闭包应用二：（匿名函数自执行方式）页面刷新时解析for循环并将index传给fn，并且立即执行fn函数，当点击按钮时，再通过父级作用域fn获取到index

```javascript
<script>        var btns = document.querySelectorAll("button");        for (var i = 0; i < btns.length; i++) {            (function fn(index){                btns[index].onclick = function(){                    console.log(index);                };            })(i);        }        //i传参给了fn函数，而点击事件是fn函数的子函数，所以也可以获取到fn函数中的i        // function fn(index){        //     btns[index].onclick = function(){        //         console.log(index);        //     };        // }    </script>
```

结果：

![img](https://img-blog.csdnimg.cn/20190713142701550.png)

闭包应用三：点击按钮后，再立即执行一个匿名函数自执行。匿名函数自执行后，得到的是一个函数返回值，当点击时再执行该函数中的内容

```javascript
    <script>        var btns = document.querySelectorAll("button");        for (var i = 0; i < btns.length; i++) {            //匿名函数自执行后，得到的是一个函数返回值，当点击时再执行该函数中的内容            btns[i].onclick = (function fn(index){                return function(){                    console.log(index);                };            })(i);        }    </script>
```

结果：

![img](https://img-blog.csdnimg.cn/2019071314284011.png)

## 14.this当前执行代码的环境对象

默认情况下：

- 函数外：window
- 函数内：函数中的this指向谁，取决于这个函数是怎么调用的
- 严格模式下，默认为undefined

1. 作为对象的属性（方法，事件（方法的一种））调用，指向当前对象
2. 其余情况执行window

```javascript
<script>//函数外：window// 函数内：函数中的this指向谁，取决于这个函数是怎么调用的    // 作为对象的属性（方法）调用，指向当前对象    // 其余情况执行window function fn(){    console.log(this);}//直接调用函数，this代表windowconsole.log("没有作为对象的属性进行调用，而是直接调用:");fn();//this指向window  //作为对象的属性或方法调用//作为对象的属性进行调用console.log("作为对象的属性进行调用:");document.fn = fn;document.fn();//this 执行document //事件里，把this绑定在事件上console.log("作为对象的属性(事件)进行调用:");document.onclick = fn;document.onclick();//this 执行document //数组里,把函数放到数组里，再由数组调用，此时this指向当前数组console.log("作为对象(数组)进行调用:");var arr = [fn,1,2];arr[0]();//this指向当前数组 //obj对象里console.log("作为对象(object对象)进行调用:");var obj = {    fn:fn};obj.fn();//this指向object对象</script>
```

结果：

![img](https://img-blog.csdnimg.cn/20190714143123828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

## 15.严格模式下的this指向

 在script标签最上面加上 'use strict';，加上'use strict'后预解析已经不能使用，会报错。

严格模式下的function指向问题：在严格模式下，function如果不是作为对象的属性和方法被调用（即直接调用方法）就指向undefined。

```javascript
<script>'use strict';function fn(){    console.log(this);};console.log("严格模式下，函数直接被调用（没有通过函数的属性或方法被调用，this就指向undefined）:");//严格模式下，函数直接被调用（没有通过函数的属性或方法被调用，this就指向undefined）fn(); //通过函数的属性或方法被调用，就指向被调用的对象console.log("通过函数的属性或方法被调用，就指向被调用的对象:");document.onclick = fn;document.onclick(); </script>
```

结果：

![img](https://img-blog.csdnimg.cn/20190714160038743.png)

## 16.this指向的修改

### 16.1 function.call()

1. function.call(this指向谁，参数1，参数2...)调用函数，并修改函数中的this指向；
2. 执行函数的call方法，会调用该函数，并且修改函数中 的this指向；
3. call中的第0个参数，代表当前函数执行时，函数中的this指向谁
4. 其他参数都是给函数传的实参
5. 注意修改执行为body时，一定要使用document.body

```javascript
<script>function fn(a,b){    console.log(this,a,b);}//直接执行，this指向windowconsole.log("直接调用函数，this指向window:");fn(1,2);//window //通过call更改当前函数的this指向//更改this指向为documentconsole.log("调用函数的call方法,更改this指向document:");fn.call(document,'a','b');//document  //更改this指向为document.bodyconsole.log("调用函数的call方法,更改this指向document.body:");fn.call(document.body,'a','b');//body </script>  
```

结果：

![img](https://img-blog.csdnimg.cn/20190714151107532.png)

### 16.2 function.apply()

1. function.apply(this指向谁，[参数1，参数2...])调用函数，并修改函数中的this指向
2. 指向函数的apply方法，会调用该函数，并且修改函数中的this指向；
3. apply中的第0个参数，代表当前执行时，函数中的this指向谁；
4. apply中第1个参数是个数组，数组中代表了我们要往函数中传递的参数；且所有参数只能放在一个数组里，有多个数组时，除了第一个，其他数值的参数不会被接收
5. apply和call唯一的区别在于，call方法直接在方法里传参，而apply是将所有参数已数组形式进行传递；
6. 注意修改执行为body时，一定要使用document.body

```javascript
<script>function fn(a,b){    console.log(this,a,b);}//直接调用，this指向windowconsole.log("直接调用，this指向window:");fn('s','r'); //调用函数的apply方法,更改this指向为documentconsole.log("调用函数的apply方法,更改this指向document:");fn.apply(document,['2','4']); //调用函数的apply方法,更改this指向document.bodyconsole.log("调用函数的apply方法,更改this指向document.body:");fn.apply(document.body,['2','4']);</script> 
```

结果： 

![img](https://img-blog.csdnimg.cn/20190714150906785.png)

### 16.3 function.bind()

1. function.bind(指向，参数1，参数2,...)绑定this指向
2. 调用函数的bind方法，会返回一个绑定了this执行的新函数；
3. 第0个参数是bind返回的新函数的this指向
4. 返回新函数的this指向被绑定了，不能再被更改
5. 新函数的this指向在修改原函数this指向时就已经被绑定，一旦被绑定不能再次修改

总结：调用函数的bind方法，会生成新的函数，绑定的this指向是针对新函数的，新函数this指向被绑定后，不能再继续被绑定（call和apply也不行）；如果调用时再传入新的参数，会将新的参数和被绑定的参数进行合并，被绑定的参数会一直存在；而原函数的this指向一直没有变，还可以继续调用bind方法，生成新的函数，同时给新的函数绑定新的this指向

```javascript
<script>function fn(a,b){    console.log(this,arguments);}//直接调用函数，this指向windowconsole.log("直接调用函数，this指向window:");fn(1,2);//window //使用函数的bind方法console.log("使用函数的bind方法，返回新的函数:");var fn2 = fn.bind(document,3,4);console.log(fn2 == fn);//false 新函数和旧函数不是同一个 console.log("原函数的this指向:");fn(5,6);//原函数的this指向不变，依然是window，且还可以继续调用bind方法 console.log("新的函数的this指向:");console.log("如果新的函数调用时传入新的参数，会将绑定的参数和新传入的参数进行合并:");fn2(7,8);//3,4,7,8  新函数的this指向即原函数绑定的this指向 //新函数的this指向在修改原函数this指向时就已经被绑定，一旦被绑定不能再次修改,且被绑定的参数也不能再被修改//只是如果调用新函数时传入新参数，会合并两次的参数console.log("新函数的this指向再修改原函数this指向时就已经被绑定，一旦被绑定不能再次修改:");fn2.call(window,9,0);//这里即使再次更改this指向，fn2新函数的this指向永远不会再改变 //再次调用fn的bind方法console.log("再次调用fn的bind方法，返回新的函数:");var fn3 = fn.bind(document.body,'a','b');console.log(fn3 == fn);fn3('c','d');</script> 
```

结果：

![img](https://img-blog.csdnimg.cn/20190714154748235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NTY5NDk3,size_16,color_FFFFFF,t_70)

### 16.4 bind方法原理分析：

为什么调用bind生成的新函数，this指向被绑定后就不能再绑定了？bind方法在ES5.1后才出来，如果想实现此功能，可以自己写可以再次绑定的bind方法。

自己实现bind方法：

参数：fn 要绑定this函数；_this返回新函数this指向谁

```javascript
<script>//为什么调用bind生成的新函数，this指向被绑定后就不能再绑定了//自己实现bind方法的原理//fn要绑定的新函数，_this给新函数绑定的this指向，...arg传参（展开运算符ES6新增）function bind(fn,_this,...arg){    return function(...args2){        fn.call(_this,...arg,...args2);    };} function fn(){    console.log(this,arguments);}//调用bind方法，返回新的函数function(){ fn.call(_this); };var fn2 = bind(fn,document,11);//执行fn2()即执行返回的新函数，并给新的函数绑定this指向fn2(2,3);//documentfn(); //重新调用绑定函数，并返回新的函数同时给其绑定this执行var fn3 = bind(fn,document.body,12);fn3(4,5);//this</script> 
```

结果：

![img](https://img-blog.csdnimg.cn/20190714214503230.png)

