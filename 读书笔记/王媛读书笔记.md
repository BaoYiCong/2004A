# 第三章：语言基础

## 3.1 语法

1，区分大小写 
2，标志符，就是变量、函数、属性或函数参数的名称。
    驼峰式命名：虽然写法不是强制的，但因为这种形式跟ECMAScript内置函数和对象的命名方式一致，所以算是最佳事件
3，注释：
单行注释和多行注释
4，严格模式
    可以全局使用 "use strict"
    也可以定义在函数体内，指定一个函数在严格模式下执行
    所有现代浏览器都支持严格模式
    5，语句
    语句以分号结尾
    代码块

## 3.2 关键字和保留字

​    case void yield 样式关键字
​    保留字
​    enum implemments package public
​    interface protected static let private

## 3.3变量

​    变量是松散类型的，意思是变量可以用于保存任何类型的数据。
​    每个变量不过是一个用于保存任意值的命名占位符

    三个关键字可以声明变量；var ，let,const
    
    3.31 var 
    可以多次声明变量，声明多个多个变量
    var string = "hi"
    如果去掉 var  string=“hi"吃屎string是全局变量
    
    变量提升   只是变量的提升命名不提升
    let 
    1,let声明的范围是块作用域，而var声明的范围是函数作用域
    
    2,let声明的变量不会别提升
         console.log(b); //--undefined
       var b = 2 
    
       console.log(a); //----a没有定义
       let a = 1
    3,不会和window相映射
        var a = 0;
      console.log(window.a); //--0
      let c = 0;
      console.log(window.c);--undefind
    4,let 在条件判断中，try catch中尽量不使用let，因为let是块作用域，
    5，for循环和定时器共同使用，输出0,1,2,3
        将var改成let 
    
    const
    1,const 声明的变量一旦声明不能修改，
    2，和let一样 不与window相映射 受限于块级 暂存性死区
    3，定义对象中的属性可以的，
    4， 使用到for in，for of 循环中
    
    优先使用const，如果需要更改的则使用let，以后var会用的很少。
    因为变量有了明确的作用域、声明位置，以及不变的值。
## 3.4 数据类型

​    3.41，undefined 定义未被初始化，
​    未定义会报错；
​    用typeOf 检查  定义未被初始胡和未定义都是undefined
​        undefined是一个假值
​    var message ;
​      console.log(message);//undefined
​      console.log(d);//报错

      console.log(typeof message);//undefined
      console.log(typeof d); //---undefined
    3.42，null
      1，null值表示一个空对象指针，所以给typeof会返回“object”
      2，在定义将来要报错对象值的变量时候，建议使用null来初始化
        if(car! = null){
            //表示car是一个对象的引用
        }
      3，undefined是由null值派生来的，定义为表面上的相等
      console.log(undefined == null)  -----true
      4,即使null和undefined 有关系，他们的用途完全不一样。永远不必显式的将变量值设置为 undefined。当时null之哟啊变量要 报错对象，而当时有解忧对象可以保存，可以用null来填充变量
    3.43 boolean类型
        1，boolean 有两个字面量：true和false
        2，可以用来赋值
            let found = true;
            let lost = false;
        3,是区分大小写的
            True False是有效的标识符，但不是布尔值
        4，可用Boolean()将其他的数据类型转换成布尔值
        空字符串"",数值型 0，NaN ,null,undefined 转换成false；；；
        其他的转换成true
        var msg = "hello";
        if(msg){
            console.log("你好"); 
        }       //会打印出 "你好"
    3.44 Number 类型
        不明白
        浮点数和整数
        NaN 不是数值
            isNaN()用于判断是不是数值型
        转换成数值型Number(),parseInt(),parseFloat()
            一样用parseInt()转换成整型，parseFloat()转换浮点型
    3.45字符串
        1，字符串可以使用双引号，单引号，反引号
        2，字符字面量
            \n 换行 \t 制表 \b退格 \r回车 
            \f换页 \\\\反斜杠 \' 单引号……
    
        3,，字符串是不可变的，修改某个变量中的字符串，必须先销毁原始的字符串，将包含新值的保存到变量
        4，转换为字符串
            toString();
            但是null,undefined用string()来转换成自身的字面量
        5，模板字符串
            标签那部分没看明白
    3.46 Symbol 符号 唯一的标志符
            
    3.47 Object类型
        在ECMAScript中的Object时候派生其他对象的基类。Object类型的所有属性和方法在
        派生的对象上同样存在
        每个Object实例都有如下属性和方法
        1，constructor 用于常见当期那对象的函数。在前面的例子中，这个属性的值就是Object()hanshu 
        2,hasOwnProperty(propertyName);:用于判断当前对象实例时候存在给定的属性。
            检查的是字符串 o.hasOwnProperty('name')
        3,isPrototypeof(object):用于判断当前对象是否为另一个对象的原型
        4，propertyIsEnumerable(propertyName) ：用于判断给定
            的属性是否可以使用（本章稍后讨论的） for-in 语句枚举。
            与 hasOwnProperty() 一样，属性名必须是字符串。
        5，toString()返回对象的字符串表示
        6valueOf() 返回对象对应的字符串、数值或布尔值表示。通常与toString(d fanhuizhi xinagong )
## 3.5 操作符

​    3.51 一元操作符
​    3.52位操作符
​    3.53布尔操作符
​        逻辑或
​        逻辑非
​        逻辑与
​    3.54 乘性操作符，除性操作符，取模
​    3.55 指数操作符 es7新增  
​            Math.pow() ===>对应的操作符是 **
​            console.log(Math.pow(3,2))===9
​            console.log(3 ** 2)===9

            console.log(Math.pow(16，0.5))===4
            console.log(16**0.5)===4
    
        还可以赋值操作
            let squar = 3;
            squar **=2;
            console.log(squared);====9
    3.56 加法 +
         减法 -
    3.57 关系操作符
        < > <= >=
    3.58 == === != !==
    3.59 条件操作符(二元表达式)
    3.6逗号操作符
        用来在一条语句中执行多个操作
# 第四章 变量、作用域与内存

## 4.1 原始值和引用值

​    变量包含两种不同类型的数据：原始值和引用值
​    原始值就是最简单的数据，引用值则是由多个值构成的对象
​    再把一个值赋值给变量时，js引擎必须确定这个值是原始值还是引用值
​    原始值(Undefined,Null,Boolean,Number,String,Symbol)
​    保存原始值的变量是 按值 访问的，因为我们操作的就是存储在变量中的实际值
​    引用值是保存在内存中的对象。与其他语言不同，js不许直接访问内存位置，不能直接操作对象所在的内存空间。
​        在操作对象时候，实际上操作的是改对象的引用而非实际的对象本身。因此保存引用值的变量是按引用访问的
​    4.11 动态属性
​        引用类型可以添加、删除、修改属性。而原始值没有属性
​    4.12 复制值
​        原始值和引用值 
​        通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置
​        引用值 把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，他指向存储在堆内存中的对象
​    4.13 传递参数 不明白
​    4.14 确定类型
​        typeof 操作符最适合用来判断一个变量是否是原始类型。可以检测 字符串。数值、布尔值、或undefined的最好方式
​        如果值是对象或者是 unll 用typeof来检测返回 “object"
​        typeof操作符用于检测函数时会返回“function”

##     4.2 执行上下文与作用域

​        看后面的小结部分会明白些   
​        执行上下文和 变量、函数预解析的关系
​    4.21 try catch; with 
​    4.22 1，使用var声明的作用域
​         写在函数内部的是局部变量，未写在函数内部的是全局变量。。
​         name = 1；；这种形式没有var，，是全局变量
​         变量提升
​         通过在声明之前打印变量，可以验证变量是否被提升。声明的提升意味着 会输出undefined而不是Reference Error
​         2,使用let的块级作用域
​         在同一个块级作用域中，let重复声明会报错，
​         var 则不会报错
​         let 非常适合在循环中声明迭代变量。使用var声明的变量会泄漏到外面，而 let不会
​         严格将 let 在js运行时也会被提升，但由于“暂时性死区”实际上不能在声明之前使用let变量
​         3，const 声明的变量必须赋值(声明的变量必须同时初始化为某个值)，
​            一经声明，在声明周期的任何时候都不能在重新赋予新值
​        const声明只应用到顶级原语或者对象。换句话说，赋值为对象的const变量不能在被重新赋值为其他引用值，但对象的键则不受限制

        如果，想让整个对象都不能修改，使用Object.freeze()
        const a1 = Object.freeze({});
        a1.name ="jack";
        console.log(a1.naem) //undefined
    
        由于 const 声明 暗示变量的值是单一类型且不可修改，js运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。谷歌的V8引擎就执行这种优化
    
    4.23 标识符查找

## 4.3 垃圾回收

​    在执行环境负责在代码执行时管理内存。
​    通过自动内存管理实现内存分配和限制资源回收。基本思路很简单：确定哪个变量不会在使用，然后释放他占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间就会自动执行，，但是某块内存是否还有用，属于“不可判定的”问题
​    如何标记未使用的变量也许有不同的实现方式在浏览器的发展史上，勇敢到过阆中主要的标记策略：标记清理和引用计数
4.31 标记清理？？？
4.32 引用计数 使用中会有很多问题
4.33 性能
​     现在垃圾回收程序会基于对js运行时环境的探测来决定何时运行。参测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的

     将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保住在执行代码时值保存必要的数据。如果数据不再必要，那么把它设置为null,从而释放其引用。这也可以叫做 解除引用。
     这个建议最适合全局变量和全局对象的属性。
     局部变量在超出作用域后会被自动解除引用，
     解除引用的关键在于确保相关的值已经不再上下文里里，因此他咋下次垃圾回收时会被回收
    
     1，通过let和const来提升性能
        不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。
        因为都以块为作用域，相比较var，会增早让垃圾回收程序介入
        在块作用域比函数作用域更早终止的情况下，这就有可能发生
    2 隐藏类 和 删除操作
    3 内存泄漏
        内存有限，多次调用，会有内存泄漏的问题
        js中的内存泄漏大部分是有不合理的引用导致的
            没有var const let声明的变量。相当于window.name ="jack".只要window本事不被清理就不会消失。
        定时器，，定时器的回调通过闭包引用了外部变量。。。定时器一致运行，回调函数中国引用的全局变量就会一直占用内存
        js闭包很容易在不知不觉中造成内存泄漏
    4 静态分配与对象池
        如何减少浏览器执行垃圾回收的次数。
        开发者无法直接控制什么时候开始收集垃圾，但可以简介控制触发垃圾回收的条件。
        理论上将 合理使用分配的内存，同时避免多余的垃圾回收，可以保住因释放内存而损失的性能
    
        浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后又超出了作用域，浏览器就会采用更激进的方式调度垃圾回收程序运行。这样就会影响性能
        对象池？？？？


​    
## 4.4 小结  复制过来。。

看完小结对前面的内容理解的更多一些。下次先看小结部分

JavaScript变量可以保存两种类型的值：原始值和引用值。原始值
可能是以下6种原始数据类型之一： Undefined 、 Null 、
Boolean 、 Number 、 String 和 Symbol 。原始值和引用值有
以下特点。
原始值大小固定，因此保存在栈内存上。
从一个变量到另一个变量复制原始值会创建该值的第二个副本。
引用值是对象，存储在堆内存上。
包含引用值的变量实际上只包含指向相应对象的一个指针，而不
是对象本身。
从一个变量到另一个变量复制引用值只会复制指针，因此结果是
两个变量都指向同一个对象。
typeof 操作符可以确定值的原始类型，而 instanceof 操作
符用于确保值的引用类型。
任何变量（不管包含的是原始值还是引用值）都存在于某个执行
上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生
命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如
下。
执行上下文分全局上下文、函数上下文和块级上下文。
代码执行流每进入一个新上下文，都会创建一个作用域链，用于
搜索变量和函数。
函数或块的局部上下文不仅可以访问自己作用域内的变量，而且
也可以访问任何包含上下文乃至全局上下文中的变量。
全局上下文只能访问全局上下文中的变量和函数，不能直接访问
局部上下文中的任何数据。
变量的执行上下文用于确定什么时候释放内存。
JavaScript是使用垃圾回收的编程语言，开发者不需要操心内存分
配和回收。JavaScript的垃圾回收程序可以总结如下。
离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被
删除。
主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标
记，再回来回收它们的内存。
引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。
JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这
种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如
DOM元素）。
引用计数在代码中存在循环引用时会出现问题。
解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮
助。为促进内存回收，全局对象、全局对象的属性和循环引用都
应该在不需要时解除引用。

# 第五章:基本引用类型

引用值(或者对象)是某个特定 引用类型 的实例。在ECMAScript 中，引用类型是把数据和功能组织到一个的结构。
    注意和 “类”区分开。但EAMAScript缺少传统的免息那个对象编程语言所具备的某些基本结构，包括类和接口。
    引用类型有时候也被称为 对象定义，因为他们描述了自己的对象应有的属性和方法 
    对象被认为是 某个特定引用类型的实例。 新对象通过使用 new 操作符后跟一个构造函数 来创建。构造函数就是用来创建新对象的函数
        例如：let now = new Date();
        Date()在这里就是构造函数，它负责创建一个只有默认属性和方法的简单对象。
    ECMAScript提供了很多像Date这样的原生引用类型，帮助开发者实现常见的任务。

## 5.1 Date

​    Date类型可以精确表示1970年1月1日
​    要创建日期对象，就使用new 操作符来调用Date构造函数  let now = new Date();
​        bu不传递参数的情况下，创建的对象将保存当前日期和时间
​    如果要基于其他日期和时间创建日期对象，必须传入器毫秒表示 提供了两种辅助方法
​        Date.parse() 和 Date.UTC()
​        Date.parse()方法接收一个便是日期的字符串参数，转换成日期的毫秒数
​        let someDate = new Date(Date.parse('May 23,2019'));
​        let someDate = new Date(('May 23,2019'));
​        这两行得到的日期对象相同
​        Date.UTC()
​        也是返回事件的毫秒数，但是传递的参数是 年。零起点月数（1月是0,2月是1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒，前两个是年月是必须的。如果不提供日，那么默认为1日。其他参数默认值是0
​        let time = new Date(Date.UTC(2000,0)) --2000年一月一日零点
​        Let timer = new Date(Date.UTC(2000,5,5,17,55,55)); 第二个日期表示2005年5
月5日下午5点55分55秒
​        上面的例子也可以这样写
​        // 本地时间2000年1月1日零点
​            let y2k = new Date(2000, 0);
​            // 本地时间2005年5月5日下午5点55分55秒
​            let allFives = new Date(2005, 4, 5, 17, 55, 55);

        Date.now() 返回表示方法执行时日期和时间的毫秒数。可以方便的用在代码中。起始时间，间隔时间
    5.1.1 继承的方法
        toLocalString()  月 日 年 时分秒 上午或下午 没有时区
        toString() 有时区  输出和toLocalString趋于一致，在现代浏览器中
        valueOf()  返回的毫秒数  在new Date(时间之后)  可以进行比较 < >
    5.1.2 日期格式化方法
        有多个，但都会返回字符串
        toUTCString()显示完整的UTC日期   UTC 格林威治时间
            var a = new Date();
            var b = a.toUTCString();
            console.log(b);   完整 的格式  
    5.1.3 日期 时间组件方法
            getTime() 返回日期的毫秒表示，与valueOf()相同
            getFullYear()  返回 4位数年 返回2019
            getMonth() 返回日期的月(0表示1月，11表示12月)   
            getDate() 返回日期中的日（1-31）
            getDay() 返回 星期（0表示周日，6表示周六）
            getHours() 返回 时
            getMinutes() 返回  分钟
            getSeconds() 返回 秒（0-59）


## 5.2 RegExp

​    let expression = /pattern/flags;
​    pattern(模式)可以是任何简单后复杂的正则白哦哦但是，包括字符类、限定符、分组、向前查找和反向引用
​    1，匹配模式的标记 g i m y u s 
​    2,任何使用字面量定义的正则表达式也可以通过构造函数来创建
​     let pattern1 =/[bc]at/i;
​     let pattern2 = new RegExp('[bc]at','i')
​     这两个是的等效的正则表达式。狗战胜的两个参数都是字符串。
​     因为RegExp的模式参数是字符串，在某些情况下需要转义。所有元字符都必须二次转义，包括转义字符序列
​     需要转义，没看明白？？？不过字面量模式要简单写，多使用
5.21 RegExp实例属性
5.22 RegExp实例方法
​    exec() 主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串
​    什么是捕获组？？？？
​    没有补货组，数组中只包含一个元素，为什么是 那些结果
​    test(),接收的是字符串参数。 如果输入的文本域模式匹配，则参数返回true，否则返回false。
​        适用于只想测试模式是否匹配，而不需要事件匹配内容的情况。test()经常用在if语句中
​     let text = "000-00-0000";
​        let pattern = /\d{3}-\d{2}-\d{4}/;
​        if (pattern.test(text)) {
​        console.log("The pattern was matched.");
​        }   
​        这种用法常用于验证用户输入，我们只在乎输入是否有效，不关心为什么无效
​     无论正则表达式是怎么创建的，继承的方法 toLocaleString() 和
​        toString() 都返回正则表达式的字面量表示。比如：   
​        let pattern = new RegExp("\\[bc\\]at"
​                ,
​                "gi");
​                console.log(pattern.toString()); // /\
​                [bc\]at/gi
​                console.log(pattern.toLocaleString()); // /\
​                [bc\]at/gi

        toString toLocalString 这两种方法不是用在Date吗?????
5.2.3 RegExp 构造函数属性
5.24 模式局限
    虽然js对正则表达式 支持有了长足的进步，但仍然缺少Perl语言中一些高级特性

## 5.3 原始值包装类型

​    方便操作原始值，ECMAScript提供了3中特殊的引用类型  Boolean Number String
​    没用到某个原始值的方法或属性时候，后台会创建一个相对应原始包装类型的对象，从而暴露出操作原始值的各种方法 
​        let s1 = "some text"
​        let s2 =s1.substring(2)
​    区别：引用类型与原始值类型包装类型的主要区别在于 对象的生命周期，实例化引用类型后，得到的实例会在离开作用域是被销毁，而原始值包装对象值存在于访问他的那行代码执行期间。所以不能在运行时给原始值添加属性和方法

    在原始值包装类型对象调用 typeof 会返回 “object",都会转换为布尔值 true
5.31 Boolean
    对应布尔值 的引用类型
    let bool = new Boolean(true);
    console.log(bool) --true ;如果 后面括号中是false，返回false
    理解原始布尔值和boolean对象宅男的区别很重要。强烈建议不要使用后者
5.32 Number
        与 Boolean 类型一样， Number 类型重写了 valueOf() 、
    toLocaleString() 和 toString() 方法。 valueOf() 方法返回
    Number 对象表示的原始数值，另外两个方法返回数值字符串。
    toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式
    的数值字符串
     除了继承的方法外，Number类型还提供了 用于将数值格式化为字符串的方法
        toFixed()方法返回包含指定小数点位数的数值字符串
            let num = 10;
            console.log(num.toFixed(2)); // "10.00"
        如果数值本身的小数位超过了参数指定的位数，四舍五入到最接近的小数位
            let num = 10.005;
            console.log(num.toFixed(2)); // "10.01"
        注意多个浮点数值的计算不一定得到精确的结果
    toPrecision() 返回的结果可能是长度，也可能是科学计数法形式，接收一个参数表示数组的总位数
        let num = 99; 
            console.log(num.toPrecision(1)); // "1e+2" ---100 因为只能用一位数表示99，99不能只用1位 数组来精确表示，所以四舍五入为100
            console.log(num.toPrecision(2)); // "99"
            console.log(num.toPrecision(3)); // "99.0"
5.33 string
    1，String 对象的方法可以在所有字符串原始值上调用。3个继     承的方法 valueOf() 、 toLcaleString() 和       toString() 都返回对象的原始字符串值。？？？？？
    2 ，javascipt字符
        javascipt字符串由16位码元组成。对多数字符来说，每16位码元对应一个字符。
        ·2.1字符串的length属性表示字符串包含多少16位码元
        ·2.2charAt() 传入索引位置返回对应的字符

    3，操作字符串值的方法
     3.1concat(),用于将一个或多个字符串拼接成一个新字符串；可以一次性拼接多个字符串，但是不改变原来的字符串
        let stringValue = "hello ";
        let result = stringValue.concat("world","!");
        console.log(result); // "hello world!"
        console.log(stringValue); // "hello"
        3.2 三种从字符串中提取字符串的方法
            slice(start,end)
            substr(start,length) 
            substring(start,length)
# 第六章

## 6.1 Object

### 6.1.1 new操作符 ，创建对象

```js
 let person = new Object();
      perosn.name = "jack";
      person.age =29
```

### 6.1.2 对象字面量

对象字面量是对象定义的简写形式，目的是为了简化包含大量属性的对象的创建

```js
 let person ={
        name:'jackson',
        age:29
      }
```

也可以使用字符串、数字、Boolean类型来定义

```js
let person = { 
    "name": "jack", 
    "age": 29, 
    5: true,
	true: 123,
    false: 321
};
person[5];	//true
person[true];	//123
person[false];	//321
```

需要注意的是：后面的值会覆盖前面的值

```js
let person = { 
    "name": "Nicholas", 
    "age": 29, 
    5: true,
	true: 123,
    true: 555,
    name: 'jack'
};
console.log(person)
{5: true, name: "jack", age: 29, true: 555}

```

思考：

```js
let person = {
    5:15,
    true: 'yes',
    false: 'no'
};
person.5;	// ? true ,这样写会报错
person.true;	// "yes"
person.false;	// "no"
person.__proto__ === ?;  //答案是 Object.prototype 
person.__proto__.constructor === ?; //Object

let person = new Object();
person.__proto__ === Object.prototype  //true
person.__proto__.constructor === Object //true
```

### 6.1.3 访问对象的属性 有两种方式

点语法  和  中括号 方式

通常，点语法是首选的属性，除非访问属性的时候必须使用变量。

```js
访问变量时候，使用[]
let propertyName = "name";
console.log(person[propertyName]); // "Nicholas"
如果属性名中包含可能会导致语法错误的字符，或者包含关键字和保留字时候，使用中括号
person["first name"] = "Nicholas";
let person = { 
	"name": "Nicholas", 
	"age": 29, 
	5: true,
	true: 123
};
person['name'];	//"Nicholas"
person['age'];		//29
person['name'] = 'jack';
person['age'] = 30;
person[true];	//123
person[5];	//true

但是用点语法 person.5 会报错 Unexpected number
person.true 会打印结果 123

```

思考：

```js
let name = {
    firstName: '张',
    lastName: '三'
};
let person = {
    [name]: '张三'
}
console.log(person[name]) //张三，因为中括号可以访问到变量的值
```

## 6.2 Array

### 6.21 Array 构造函数  创建数组

```js
//1,
      let colors = new Array();
      color.length;
//2,
      let colors = new Array(5);//表示创建一个长度为5的空数组
      colors.length //5
      colors[0]; //undefined
 //2.1
      let colors = Array(5);// 也可以这样创建，不用new
 //3,
      let colors = new Array('red','blue','green'); //表示创建一个数组，并传入三个值
      colors.length; // 3;
      color[0];// "red"
 //3.1 不用new 也可以
      let names = Array('gery');
```

思考：

```js
	  let colors = new Array(3);  //这是创建一个长度为3的空数组
      colors[0] //undefined 
      colors.length;//3
```

### 6.22 用字面量方式创建 数组

```js
//1,
      let colors =['red','blue','green'];//创建一个包含3个元素的数组
      let names =[];//创建一个空数组
      let values = [1,2,] //创建一个包含2个元素的数组
      let ages=[,,,]//创建一个包含三个元素的空数组
//2
      colors.length(2);//直接改变color数组的长度
      colors[2] //undefined

```

思考：

```js
let cars = [1,2,,,];
cars.length;	//4

let cats = [1,2,,,5];
cats.length;	//5
cats[cats.length - 1];	//5    cats.length =5 5-1=4 cats[4]--- 5

let dogs = [1,2,3];
dogs.length = 5;
dogs.length;	//5
dogs[dogs.length - 1];	// 5-1=4 dogs[4]---undefined
```

### 6.23 Array.from

from () 用于将类数组结构转换为数组实例，而of()用于将一组参数转换数组实例

第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构

# 第八章

## 1.1 对象属性的类型

### 1.1.1 configurable

表示属性是否可以通过delete 删除并重新定义，是否可以修改他的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true

```js
let person ={};
Object.defineProperty(person,'name',{
	configurable:false,
	value:undefined
});
console.log(person);
//{name:undefined}
delete person.name;//false
console.log(person);
//{name:undefined}

let person ={};
Object.defineProperty(person,'name',{
    configurable:true,
    value:undefined
});
console.log(person);
//{name:undefined}
delete person.name; // true
console.log(person);// {}
```



### 1.1.2 enumerable

### 1.1.3writable

### 1.1.4value

### 1.1.5get

### 1.1.6 set

## 1.2 getOwnPropertyDescriptor

## 1.2 getOwnPropertyDescriptors

## 1.3 合并对象 -- 深浅拷贝

#### ·在es6 之前，通常会封装一个方法，可参考jquery的extend方法

```js
var obj ={
	a:1,
	b:2
}
var obj1 ={
	c:3,
	a:5
}
{
	a:5,
	b:2,
	c:3
}
```



```js
//一个特别简单的浅拷贝  使用extend
function extend(target,source){
  target = target || {}; //用来判断target是一个对象
  if(typeof target !== 'object'){
    throw new Error('target不是对象');
  }
  if(!source){
    throw new Error('source不能为空');
  }
  if(typeof source !== 'object'){
    throw new Error('source不是对象');
  }
  for(let key in source){
    target[key] = source[key] //然后将源对象的值赋值到target中
  }
  return target;//最后返回target
}
 
    var obj = extend({
        a:1,
        b:2
    },{
        c:3,
        a:5
    })
    console.log(obj)
    /*
    
      a:5,
      b:2,
      c:3

      将source对象中的值，赋值到target上。return出target
      判断是对象；；；循环source中的值 然后赋值；；；返回target对象      
    */
```

#### ·object.assign

用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target).源对象可以是多个，后者替换前者

```js
 let obj = Object.assign({a:1},{b:2},{c:3},{a:5},{b:6})
    console.log(obj)
```

出现的问题：

以上方法都是 **浅拷贝**，如果拷贝属性是对象，那么拷贝的只是引用

```js
 var obj ={
        a:1,
        b:'fff'
    }
    var obj1={
        a:2,
        c:{
            name:'李四',
            age:20
        }
    }
     var obj2 = Object.assign({},obj,obj1);
     obj1.a=3;
     obj1.c.name = "王五";
     obj1.c.age =30;
     console.log(obj2);//obj2.c会跟着obj1.c 的改变而改变
```

#### 深拷贝



## 1.4解构

## 1.5  创建对象

### 1.51 简单工厂模式 

### 1.52 构造函数模式

### 1.53 原型模式

## 1.6 hasOwnProperty

## 1.7 keys

## 1.8 getOwnPropertyNames

## 1.9 values

## 1.10 entries

## 1.11 继承

## 1.12 原型链

## 1.13 面向过程

## 1.14 面向对象

## 1.15继承

### 1.15.1 组合继承

### 1.15.2 原型式继承

### 1.15.3 盗用构造函数

### 1.15.4 组合继承

## 1.16 class类

### 1.16.1 类的构成



### 1.16.2 类构造函数

### 1.16.3 继承

## 1.17作业

- **使用ES5和class两种方法实现以下需求：**

1. 设计一个`Person`（人）基础类，有姓名、年龄、性别、血型等属性。会走路、吃饭、自我介绍、睡觉。
2. 设计`Famer`（农民）类，继承自`Person`，会种地。
3. 设计`BusinessMan`（商人）类，继承自`Person`，会做生意。
4. 设计`Coder`（程序员）类，继承自`Person`，会写代码。
5. 设计`JavaCoder`（`java`程序员）类，继承自`Coder`，会写`Java`的代码。
6. 设计`JSCoder`（`JS`程序员）类，继承自`Coder`，会写`JS`代码。
7. 设计`VueCoder`（`Vue`程序员）类，继承自`JSCoder`，会开发`Vue`项目。
8. 当调用自我介绍的方法时，每个人都要完整的说出自己会的每一项技能，如`VueCoder`会说：我叫xxx，今年xx岁了，我的性别是x，血型是x。我是个程序员，会写代码。JS是我的主力语言。不过我目前主要还是做Vue开发。

```js
 //使用class 完成
        //定义基类 
        class Person {
            constructor(name, age, sex, blood) {
                this.name = name;
                this.age = age;
                this.sex = sex;
                this.blood = blood;
            }
            //定义的函数（自我介绍) 

            introduction() {
                console.log(`我叫${this.name},今年${this.age}岁了,我的性别是${this.sex},血型是${this.blood}型`)
            };

            walk() {
                console.log('我会走路')
            };
            eat() {
                console.log('我会吃饭')
            };
            sleep() {
                console.log('我会睡觉')
            }
        }
        // 农民
        class Famer extends Person {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood)
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('会种地')
            }
        }
        let person = new Person('人', 21, '女', 'A')
        let famer = new Famer('农民', 20, "男", "b");
        famer.introduction();
        person.introduction();

        // 商人
        class BusinessMan extends Person {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood)
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('会做生意')
            }
        }
        let bussiness = new BusinessMan('商人', 40, '男', 'c')
        bussiness.introduction();

        //Coder 程序员类
        class Coder extends Person {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood);
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('会写代码');
            }
        }

        let coder = new Coder('程序员', 18, '女', 'B')
        coder.introduction();

        //Java 程序员
        class JavaCoder extends Coder {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood);
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('会写Java代码');
            }
        }

        let javacoder = new JavaCoder('JAVA程序员', 30, '男', 'A');
        javacoder.introduction();

        //jsCoder  
        class jsCoder extends Coder {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood);
            }
            //自我接收
            introduction() {
                super.introduction();
                console.log('会写JS代码');
            }
        }
        let jscoder = new jsCoder('小王', 23, '女', 'A');
        jscoder.introduction();

        // vueCoder 
        class VueCoder extends jsCoder {
            constructor(name, age, sex, blood) {
                super(name, age, sex, blood);
            }
            //自我介绍
            introduction() {
                super.introduction();
                console.log('js是我的主力语言。不过我目前主要还是做Vue项目开发');

            }
        }
        let vuecoder = new VueCoder('小敏', 26, '女', 'C');
        vuecoder.introduction();


        // 使用es5 完成  没有完成，不是使用继承父类的方法
        function Person(name, age, sex, blood) {
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.blood = blood
        }
        Person.prototype.introduction = function () {
            console.log(`我叫${this.name},今年${this.age},性别：${this.sex},血型:${this.blood}`);
        }

         function Famer(name,age,sex,blood) {
            Person.call(this,name,age,sex,blood);
         }
		//原型链继承
        // Famer.prototype = Object.assign(Object.create(Person.prototype), {
        //    constructor: Famer
        // });
		Famer.prototype = Object.create(Person.prototype)
        Famer.prototype.constructor = Famer;

        Famer.prototype = new Person();
        let liye = new Person('立业', 20, '男', 'b');
        liye.introduction(); //我叫立业,今年20,性别：男,血型:b
        let famer = new Famer('农民', 30, '男', 'a')
        famer.introduction(); //我叫农民,今年30,性别：男,血型:a
		





        // function superType() {
        //     console.log('superType执行了一次');
        //     this.name = '张三';
        //     this.children = ['张欣', '张宇'];
        // }
        // superType.prototype.age = function(){
        //     console.log(`我叫${this.name}`);
        // };

        // function sub() {
        //     superType.call(this);
        // }

        // //直接继承原型，不用再次实例化父类构造函数，防止再次执行父类构造函数
        // //sub.prototype = Object.create(superType.prototype, { constructor:{ value:sub, enumerable:false } });

        // //跟上面的一样，只是最后自己手动修改一下构造函数的指向
        // sub.prototype = Object.create(superType.prototype)
        // sub.prototype.constructor = sub;

        // //使用浅拷贝的方式将自身的构造函数替换掉父类原型的构造函数
        // //sub.prototype = Object.assign(Object.create(superType.prototype), { constructor: sub });

        // var s = new sub();
        // console.log(s.name); //张三
        // console.log(s.hasOwnProperty('name')); //true
        // console.log(s.hasOwnProperty('children')); //true

        // var s1 = new sub();
        // s1.children.push('李四');
        // console.log(s1.children);
        // console.log(s.children);

        // console.log(s.constructor === sub); //true
        // console.log(s instanceof sub); //true
        // console.log(s instanceof superType); //true
        // console.log(s.age, s1.age); //12 12
```



# 一，作用域

javascript 一门解释型语言，运行到哪一段代码，就分析、编译哪一段代码，不会像其他编译型语言会提前将分析、编译等操作完成。所以 JavaScript的运行会分为两个阶段：分析阶段（分词、预编译）、执行阶段。

------

作用域的意思就是变量在哪个区域起作用（可以被访问）。离开这个作用域后无法访问到这个作用域内的变量了，例：

```js
function scope() {
    var a = 1;
    console.log(a); //这个作用域内可以被访问
}
scope();    //1
console.log(a); //报错，因为出了scope函数作用域了
```

作用域又分为：全局作用域、块级作用域、函数作用域

## 1,全局作用域

无论在何处都可以被访问到，全局作用域中定义的变量和方法都会被绑定到window上

```js
var a = 1;  //全局变量
function fnScope() {
    console.log(a); //函数作用域中可以访问到
}
{
    console.log(a); //块级作用域中也可以访问到
}
```



## 2，块级作用域

以{}包裹的就是块级作用域（es6 新增的let、const定义的）。

```js
{
    let a = 1;
    const b = 2;
    console.log(a);     //只有在这个块级作用域中才能访问到a
}
console.log(a);     //出了块级作用域访问不到a了
console.log(b); 
```

```js
{
    var a = 1;  //提升
}
console.log(a);     //1
```

```js
if (false) {
    var a = 1;  //提升，但是执行阶段不赋值
}
console.log(a);     //undefined
```

思考：

```js
{
    function init() { }
}
console.log(init);	// ？

if (false) {
    function init() { }
}
console.log(init);	// ?

{
    function init() { }
    init = 3;
}
console.log(init);	// function init() { }

{
    function init() { }
    init = 3;
    console.log('kuai', init);	// 3
}
console.log(init);	// function init() { }

{
    init = 4;
    function init() { }
    init = 3;
    console.log('kuai', init);	// kuai,3
}
console.log(init);	// 4


{
    init = 4;
    function init() { }
    init = 3;
    console.log('kuai', init);
    function init() { }
    var init = 5;
}
console.log(init);
// Uncaught SyntaxError: Identifier 'init' has already been declared


function fn() {
    console.log('out');
}
if (false) {
    function fn() {
        console.log('inner');
    }
}
fn();	// out
```

在同一个块级作用域中，如果有申明式函数，后面对于此函数的表达式更改都将被保护。但是在申明式函数前面的更改可以生效

```js
{
    init = 4;
    function init() { }
    init = 3;
    console.log('kuai', init);  // kuai 3
    function init() { }
    init = 5;
}
console.log(init);  // 3


{
    init = 4;
    function init() { }
    init = 3;
    console.log('kuai', init);  // kuai 3
    function init() { }
    init = 5;
    function init() { }
}
console.log(init);  // 5
```



## 3，函数作用域

在function 函数中的即是函数作用域

```js
function fnScope() {
    var a = 1;
    console.log(a);     //在此函数作用域中可以访问到a
}
console.log(a);     //出了函数作用域就访问不到a了
```

```js
function fn() {
   console.log('out');
}
function init() {
    if (false) {
        function fn() {       console.log('inner');
        }
    }
    fn();	// Uncaught TypeError: fn is not a function
}
init();
/*
因为函数作用域下fn会提升，但如果为false的话，方法体不会提升。所以最终变为了：
function init() {
	var fn;
    if (false) {
    }
    // fn为undefined
    fn();	// Uncaught TypeError: fn is not a function
}
*/
```

思考：

```js
function fn() {
    console.log('out');
}
function init() {
    if (true) {
        function fn() {
            console.log('inner');
        }
    }
    fn();	// ?
}
init();
```



# 二、词法作用域

JavaScript 采用词法作用域（静态作用域），词法作用域是在分析阶段确定的。无论函数在哪里被调用，也无论他如何被调用，它的此法作用域都只由函数被声明时所处的位置决定（小技巧：除了this定义和调用的值，其他都是在词法作用域中）。

```js
var a = 123;
function parent() {
    var a = 321;
    function child() {
            console.log(a);   //做词法分析的时候就已经确定了调用parent的词法作用域中的a
    }
    child();    //321
    return child
}
const p = parent();     //无论调用位置在哪里
p();    //321
```

在来看看this 绑定的效果：

```js
var a = 123;
function parent() {
    var a = 321;
    function child() {
        console.log(this.a);   //运行时才能确定this的指向，确定了this的指向后才能确定a的值
    }
    child();    //123 this指向window
    return child
}
const p = parent();
p();    //123
```

```js
var a = 123;
function parent() {
    var a = 321;
    function child() {
        console.log(a);   //做词法分析的时候就已经确定了调用parent的词法作用域中的a
    }
    child();    //321
    return child
}
const child = parent();
var obj = {
    a: 555,
    child: child
}
obj.child();    //321 无论怎么调用，在哪里调用这个方法永远都打印321
```



# 三，执行上下文

当JavaScript 代码执行一段可执行代码（executable code)时，会创建对应的执行上下文（execution context)。

对于每个执行上下文，都有三个重要属性：

​	·变量对象（Variable object,vo)

​	·作用域链（Scope chain)

​	· this

## 1.1变量对象

​	 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

### 1.11 全局上下文

可以通过 this 引用，在客户端 JavaScript中，全局对象就是 window对象。

```js
console.log(this);	//window
```

全局对象是由 Object 构造函数实例化的一个对象

```js
xxxxxxxxxx console.log(this instanceof Object);
```

预定义了一堆，大堆函数和属性

```js
//都能生效
console.log(Math.random());
console.log(this.Math.random());
```

作为全局变量的宿主

```js
var a = 1;
console.log(this.a);
```

客户端 JavaScript 中，全局对象有window属性 指向自身

```js
var a = 1;
console.log(window.a);	//1

this.window.b = 2;
console.log(this.b);	//2

console.log(self);	//window
console.log(globalThis);	//window
```

全局上下文中的变量对象其实就是全局对象

### 1.12 函数上下文

在函数上下文中，我们用活动对象`(Activation Object, AO)`来表示变量对象。活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在`JavaScript`环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫`Activation Object`，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。

活动对象是在进入函数上下文时被创建的，他通过函数的 arguments 属性初始化。 arguments属性值是 Arguments对象

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};
  b = 3;
  console.log(a);
  console.log(b);
}
foo(1);
```

在进入执行上下文后。

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}

//var person = { name: '张三', age: 13 }; obj.name;
```



## 1.2作用域链

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一致找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链条就叫做作用域链

函数有一个内部属性[scope]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解[scope]就是所有父变量对象的层级链

```js
function foo() {
    function bar() {
        //更多代码
    }
}
```

函数创建时，各自的[scope]为：

```js
foo.[scope] = [
  globalContext.VO
];

bar.[scope] = [
    fooContext.AO,
    globalContext.VO
];
```

子作用域可以访问父作用域的变量，父作用域不能访问子作用域的变量(只能自下往上查找，不能自上往下查找).

```js
x function parent() {    var a = 1;    function child() {        var b = 2;        console.log(a); //可以访问到parent中的a    }    console.log(b);     //报错，因为访问不到child中的b}
```



## 1.3 this

​	前面已经提到 javascript 采用的是静态作用域，但是this 算是模仿了动态作用域，this是在执行阶段是确定的

### 	1.31 默认绑定

​	不带任何修饰的函数进行调用的，只能采用默认绑定，this指向全局对象 window。

###### 注意：

严格模式下不能将全局对象用于默认绑定，因此this绑定到undefined

```js
  function foo(){
        console.log(this); //window
        console.log(this.a); // 12
    }
    var a =12;
    foo(); //foo()这种就是不带任何修饰符，指向全局window

//第二题：
function a() {
    console.log('a', this);	//'a' window
}
function b() {
    a();
    console.log('b', this);	//'b' window
}
function c() {
    b();
    console.log('c', this);	//'c' window
}
c();
```

思考：

```js
var a = 12;
function test() {
    this.a = 13;
}
test();
console.log(a);	//13

分析：
var a = 12,,,window.a = 12
进入test函数中  this= window  则this.a =13,也就是window.a = this.a =13;
下面 test() --->window.a = 13;
所以console.log(a) --->13
var a = 12; // window.a=12
function test(){
    //此时 window = this,因为this.a=13,那么 
    this.a = 13;
    //window.a = 13;
}
test();//window.a = 13;
console.log(a);//13
```



### 	1.32隐式绑定

​		对象内部包含一个指向函数的属性，并通过这个属性间接引用这个函数，从而把this间接（隐式）绑定到这个对象上

·无论是直接在obj中定义还是在添加为引用属性，这个函数严格来说都不属于obj对象

```js
function foo() {
    console.log(this);	//{a: 2, foo: ƒ}
    console.log(this.a);	//2
}

var obj = {
    a: 2,
    foo: foo
}
obj.foo();

var obj = {
    a: 2,
    foo: function() {
        console.log(this);	//{a: 2, foo: ƒ}
        console.log(this.a);	//2
    }
}
obj.foo();
```

·调用位置会使用obj上下文来引用函数，因此你可以说函数被调用是 obj 对象“拥有”或者“包含”函数引用。当foo()被调用时，他的前面确实加上了对obj的引用，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。因此调用foo()时this被绑定到obj，因此在函数中执行this.a和obj.a是一样的。

·对象属性引用链中只有上一层或者说最后一层在调用位置中起作用。

```js
function foo() {
    console.log(this.a);
}

var obj2 = {
    a: 1,
    foo: foo
}

var obj1 = {
    a: 2,
    obj2: obj2
}
obj1.obj2.foo();    //1

var obj3 = {
    a: 3,
    obj1: obj1
}
obj3.obj1.obj2.foo();	//1

```



### 	1.33显示绑定

​		call,apply,bind 都属于显式绑定一类，显示绑定后 this便无法在修改

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.call(obj);
```

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);  //2
}
var obj = {
    a: 2
}
foo.apply(obj);
```

```js
function foo() {
    console.log(this);	//{a: 2}
    console.log(this.a);	//2
}
var obj = {
    a: 2
}
var f = foo.bind(obj); 
f();
```



### 	1.34 new绑定

​	实例化一个新对象后，会将实例对象绑定到函数调用中的this上

```js
function foo(a) {
    console.log(this);	//foo {}
    this.a = a;
    console.log(this.a);	//2
}
var bar = new foo(2); 
console.log(bar.a); //2
console.log(a);	//Uncaught ReferenceError: a is not defined
```

思考：

```js
function foo() {
    console.log(this);	//obj
    console.log(this.a);	//2
}
var obj = {
    a: 2
}
var obj1 = {
    a: 20
}
var f = foo.bind(obj);
f = f.bind(obj1);
f();


//思考2
var num = 1;
function a1() {
    'use strict';
    console.log(this.num++); //严格模式下this是undefined，undefined.num++ 是undefined
}

function a2() {
    console.log(++this.num);
}

(function () {
    'use strict';
    a2();	//2
})()
a1();	//  undefined
知识点：
	1，num ++  是先+1，后打印console.log(num)
		++ num  是先打印，后+1
	2默认绑定，this指向全局，严格模式下this不能将指向全局，因此this会绑定到undefined
    3，‘use strict’ 只在当前作用域有效
    

//题3
function c1(name) {
    if (name) {
        this.name = name;
    }
}

function c2(name) {
    this.name = name;
}

function c3(name) {
    this.name = name || 'test'; //如果name是undefined或是null的时候，this.name= “test"
}

c1.prototype.name = 'c1';
c2.prototype.name = 'c2';
c3.prototype.name = 'c3';
console.log(new c1().name + new c2().name + new c3().name);		// c1undefinedtest
//new c2().name 没有传递值，是undefined，所以new c3().name 是test
```



### 	1.35 箭头函数

es6 新增的()=>箭头函数中，this在分析阶段时就确定了（跟函数中的this在执行阶段时确定相反），绑定的是父作用域中的this，指向永远不变。其实总结起来就两点：

· 外层有函数：外层函数的this就是箭头函数的this

```js
function ab() {
    var b = () => {
        console.log(this);
    };
    b();
}
ab();   //window，因为外层函数的this采用了默认绑定规则
```

```js
var obj = {
    a: 1,
    foo() {
        var fn = () => {
            console.log(this.a);
        };
        fn();
    }
}
obj.foo();  //1，外层函数的this采用了隐式绑定规则 foo()绑定到obj上，所以foo的this执行的是obj，， 那么fn里面的this.a指向的是foo()的this.a，，所以obj.a = 1
```

· 外层没有函数：箭头函数的this就是window

```js
var a = 123;
var obj = {
    a: 1,
    foo: () => {
        console.log(this.a);
    }
}
obj.foo();  //123
foo箭头函数外面没有函数，所以this指向的是window，那么window.a = 123；
```

思考：

```js
var a = 666;
var obj = {
    a: 1,
    obj: {
        a: 2,
        obj: {
            a: 3,
            foo: () => {
                console.log(this.a);
            }
        }
    }
}
obj.obj.obj.foo();	//? 666 
外层没有函数，那么foo箭头函数中的this指向window
```

```js
var a = 666;
var obj = {
    a: 1,
    foo() {
        console.log(this.a);
        var obj1 = {
            a: 2,
            foo: () => {
                console.log(this.a);
                function f() {
                    console.log(a);
                    console.log(this.a);
                }
                f();
                return f;
            }
        }
        obj1.foo()();
    }
};
obj.foo();  //? 1,1,666,666,666,666,
var ff = obj.foo;
ff();   //?666,666,666,666,666,666
```



## 1.4 总结

​	到目前为止还不知道执行上下文的结构。

接下来通过例子讲解

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();  // local scope
```

#### 1,全局执行上下文初始化

```js
globalContext = {
    VO: [global],	//window是暴露出来的一个指向全局变量对象的属性
    Scope: [globalContext.VO],
    this: globalContext.VO
}
```

#### 2，初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[scope]

```js
checkscope.[scope] = [
  globalContext.VO
];
```

#### 3,执行 checkscope函数，创建 checkscope 函数执行上下文有开始初始化。

```js
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope: undefined,
        f: reference to function f(){}
    },
    Scope: [AO, globalContext.VO],
    this: undefined
}
```

#### 4，执行 f 函数，创建 f 函数 执行上下文并初始化

```js
fContext = {
    AO: {
        arguments: {
            length: 0
        }
    },
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
    this: undefined
}
```

思考:

```js
this.a = 20;
function go() {
    console.log(this);
    console.log(this.a);
    this.a = 30;
}
go.prototype.a = 40;
var test = {
    a: 50,
    init(fn) {
        fn();
        console.log(this.a);
        return fn;
    }
};
console.log(new go().a);	// 40 30
test.init(go);	// 20 50
var p = test.init(go);	// 30 50
p();	// 30 undefined
```



## 1.5 作业，

在0129 已经讲解

```js
作业1,
alert(a);	// ?	
a();
var a = 3;
function a() {
    alert(10);
}
alert(a);	// ?
a = 6;
a();	// ?

ao:
a:undefind   
a():alert(10)
没有函数嵌套，就没有作用域链；同时也没有this
var a = 3,赋值a = 3  所以第一行alert(a)--->3；；；
a()--->  alert(10)
alert(a)--->3
a=6  这是全局变量 ，所以将6赋值给 a 
a() ---->还是调用a()这个函数，所以还是alert(10)


```

```js
作业 2
var x = 1, y = 0, z = 0;

function add(x) {
    return (x = x + 1);
}
y = add(x);
console.log(y);	// ?
function add(x) {
    return (x = x + 3);
}
z = add(x);
console.log(z);	// ?
```

```js
作业 3
function foo() {
    console.log(this.a);
}
function doFoo(fn) {
    fn();   //调用位置
}
var obj = {
    a: 2,
    foo: foo
}
var a = 'this is global';
obj.foo();	//?
doFoo(obj.foo); //?
```

```js
作业 4 

function foo() {
    console.log(this.a);
}
function doFoo(fn) {
    fn();   //调用位置
}
var obj = {
    a: 2,
    foo: foo
}
var obj1 = {
    a: 3,
    obj: obj
}
var a = 'this is global';
obj1.obj.foo();	//?
doFoo(obj1.obj.foo); //?
```

```js
作业 5
function foo() {
    console.log(this.a);
}
function doFoo(fn) {
    fn();   //调用位置
}
var obj = {
    a: 2,
    foo: foo
}
var a = 'this is global';
setTimeout(obj.foo, 100);	//?
```

```js
作业 6
function foo() {
    console.log(this.a);
}
var obj = {
    a: 2
}
var bar = function () {
    foo.call(obj);
}
var a = 20;
bar();  //?
setTimeout(bar, 100);
bar.call(window);   //?
```

```js
作业 7
function foo() {
    console.log(this.a);
}
var obj1 = {
    a: 2,
    foo: foo
}
var obj2 = {
    a: 3
}
obj1.foo();     //?
obj1.foo.call(obj2);    //?
```

```js
作业 8
function foo(a) {
    this.a = a;
}
var obj1 = {
    foo: foo
}
var obj2 = {}
obj1.foo(2);
console.log(obj1.a);    //?
obj1.foo.call(obj2, 3);
console.log(obj2.a);    //?
var bar = new obj1.foo(4);
console.log(obj1.a);    //?
console.log(bar.a); //?
```

```js
作业 9 
function foo(a) {
    this.a = a;
}
var obj1 = {};
var bar = foo.bind(obj1);
bar(2);
console.log(obj1.a);    //?
var baz = new bar(3);
console.log(obj1.a);    //?
console.log(baz.a); //?
```

```js
作业 10 

var age = 12;
function a() {
    var age = 13;
    function b() {
        console.log(this.age);  //?
        console.log(age);   //?
        var age = 15;
        function c() {
            var age = 16
            console.log(this.age);  //?
            console.log(age);   //?
        }
        c();
    }
    b();
    console.log(age);   //?
    console.log(this.age);  //?
}
a();
```

```js
作业 11 
var age = 12;
function a() {
    var age = 13;
    function b() {
        console.log(age);
        var age = 15;
        function c() {
            var age = 16
            console.log(age);
        }
        c();
    }
    b();
    console.log(age);
}
a();
//请写出以上代码创建执行上下文创建过程
```

# 第九章

## 1.1代理

生活中就有很多代理，比如机票代理，火车票代理，微商代理。代理人处在服务商和客户的中间，类似于中间商的概念。客户和服务商不直接通信，所有的沟通和业务往来都有代理人在中间代理

```js
//微商卖鞋的商家
```



### 1.1.1创建空代理

### 1.1.2get

### 1.1.3 set

## 1.2 Reflect

### 1.2.1 get/set

### 1.2.2 has

### 1.2.3 deleteProperty

### 1.2.4 construct

### 1.2.5 defineProperty

1.2.6 ownKeys

## 1.3 作业

# 第十章

### 阅读以下小章节：

\1. 10.1 箭头函数。

\2. 10.3 理解参数。

\3. 10.5 默认参数值。

\4. 10.6.2 收集参数。

\5. 10.9.1 arguments。

\6. 10.9.3 caller

\7. 10.12 递归

\8. 10.14 闭包

# 第十章  函数

函数是ECMAScript中最有意思的部分之一，主要是因为函数实际上是对象。

每个函数都是 Function类型的实例，而Function也有属性和方法，跟其他引用类型一样。

因为函数是对象，所以函数名就是执行函数对象的指针，而且不一定与函数本身紧密绑定。

## 定义函数的方式

·函数声明的方式定义

```js
function sum (num1,num2){
	return num1 + num2;
}
// 代码定义了一个变量 sum并将其初始化为一个函数
// 注意函数末尾没有分号
```

·函数表达式的方式 定义

```js
let sum = function(num1,num2){
	return num1 + num2;
};
//注意函数末尾是有分号的，与任何变量初始化语句一样
```

· 箭头函数 的方式定义 和函数表达式很像

```js
let sum = (num1,num2)=>{
	return num1 + num2;
}
```

· 使用 Function构造函数  

```js
let sum =new Function('num1','num2','return num1 + num2');
//不推荐使用这种语法定义函数，因为这段代码会被解释两次。第一次将他当做常规ECMAScript代码，第二次是解释传给构造函数的字符串。显然会影响性能
//不过，把函数想象为对象，把函数名想象为指针是很重要的。这种定义方式很好地诠释了这些概念
```

## 10.1 箭头函数

### 10.1.1 

ES6新增 使用 => 语法定义函数表达式的能力。

任何可以使用函数表达式的地方，都可以使用箭头函数

```
let arrowSum =(a,b)=>{
	return a+b;
}
let functionExpressionSum =function(a,b){
	return a+b;
}
console.log(arrowSum(1,2));//3
console.log(functionExpressionSum(1,2)); //3
```

### 10.1.2

 箭头函数简洁的语法非常适合嵌入函数的场景

```js
let ints = [1, 2, 3];
console.log(ints.map(function(i) { return i + 1;
})); // [2, 3, 4]
console.log(ints.map((i) => { return i + 1 }));
// [2, 3, 4]


```

### 10.1.3 格式用法

·如果只有一个参数，可以不用括号；没有参数，或多个参数的情况下，才需要使用括号

```js
//一个参数
let double=(x)=>{return 2 * x};
let triple = x=>{return 3 * x};
//需要括号
	//没有参数时，需要括号
let getRandom =()=>{return Math.random()};
	//多个参数，需要括号
let sum  =(a,b)=>{return a+b}
//无效的写法
let multiply =a,b=>{return a*b}
```

·使用大括号，说明包含“函数体"，可以在一个函数中包含多条语句，跟常规函数一样。

如果不使用大括号，箭头后面只能有一行代码（一个赋值操作，或者一个表达式),省略大括号会隐式返回这行代码的值

```js
//以下两种有效
let double = (x) => {return 2*3}
let triple =(x) => 3 * x
//可以赋值
let value ={};
let setName =(x)=> x.name='jack';
setName(value);
console.log(value.name);//"jack"
//无效写法
let multiply =(a,b)=> return a*b;
```

### 10.1.4

箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用 arguments、super、 new.target,也不能做构造函数。此外，箭头函数也没有prototype属性。

## 10.3 理解参数

js函数既不关心传入的参数个数，也不关心这些参数的数据类型。

定义函数是要接收两个参数，并不意味着调用时就穿两个参数。可以传一个、三个，甚至不传，解释器都不会报错。

原因是：js函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么(数组为空或者数组元素超出要求，也没问题)

```js
function num(a,b) {
    console.log(a+b);
}
num();//NaN
function num(a,b) {
    console.log(a+b);
}
num(1);//NaN
function num(a,b) {
    console.log(a+b);
}
num(1,1);//2
function num(a,b) {
    console.log(a+b);
}
num("2",1);//21
function num(a,b) {
    console.log(a+b);
}
num("2",1,3);//21
function num(a,b) {
    console.log(a+b);
}
num("2",5,"t");//25
```

事实上，在使用function关键字定义（非箭头）函数时，，可以在函数内部访问 arguments 对象，从中取得传进来的每个参数值

arguments 对象是一个类数组对象（不是Array的实例。类数组：具有length属性，可以遍历。但是没有push()，pop()等方法），因此可以使用中括号语法访问其中的元素。而要确定传进来多少个参数，可以访问 arguments.length属性

```js
function sayHi(name,message){
	console.log('Hello'+name+','+message)
}
sayHi("小明","天气不错")//Hello小明,天气不错
//使用arguments
function sayHi() {
console.log("Hello " + arguments[0] + "," +arguments[1]);
}
sayHi("张三","天气不错")//Hello 张三,天气不错

//打印结果可以看出，没有命名参数，函数照样可以调用。说明，js函数的参数只是为了方便才写出来的，并不是必须
```

通过arguments对象的length属性检查传入的参数个数。

```js
function howManyArgs(){
	console.log(arguments.length)
}
howManyArgs('string',1);//2
howManyArgs();//0
```

```js
function doAdd() {
  if(arguments.length ===1){
    console.log(arguments[0]+10);
  }else if(arguments.length === 2){
    console.log(arguments[0]+arguments[1]);
  }
}
doAdd(10);//?
doAdd(10,20)//?

```

arguments对象可以跟命名参数一起使用,

```js
function doAdd(num1, num2) {
     if (arguments.length === 1) {
         console.log(num1 + 10);
   } else if (arguments.length === 2) {
                console.log(arguments[0] + num2);}
        }
 doAdd(1,2);//3
 doAdd(1);//11

```

并且arguments的值始终会与对应的命名参数同步

```js
function doAdd(num1, num2) {
arguments[1] = 10;
console.log(arguments[0] + num2);
}
doAdd(1,2) ; //11
doAdd(1,20);//11
//但是但这并不意味着他们都会访问同一个内存地址，他们在内存中是分开的，只不过是单向同步而已，即修改命名的参数的值不会影响arguments对象中相应的值
doAdd(1);//?
//如果只传入一个参数，然后把arguments设置为某个值，那么这个值并不会反映到第二个命名参数
//因为arguments对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的。。。如果没有传入命名参数，那么它的值就是undefined。就类似于定义了变量而没有初始化
//doAdd(1);//NaN

```

但是严格模式下，argrments赋值不会在影响num2的值。

其次， 在函数中尝试重写 arguments 对象会导致语法错误。（代码也不会 执行。）

```js
function doAdd(num1, num2) {
            "use strict"
            arguments[1] = 10;
            console.log(arguments[0] + num2);
        }
        doAdd(1, 2); //3
        doAdd(1, 20); //21

```

### 箭头函数中的参数

 传入函数中的参数将不能 arguments关键字访问。只能通过定义的命名参数访问

```js
function foo() {
console.log(arguments[0]);
}
foo(5); // 5
let bar = () => {
console.log(arguments[0]);
};
bar(5); // ReferenceError: arguments is notdefined
```

但是可以在包装函数中把它提供给箭头函数

```js
function foo() {
	let bar = () => {
	console.log(arguments[0]); // 5
	};
    bar();
  }
foo(5);

```

注意：js中所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用

## 10.5 默认参数值

在es5以前，实现默认参数的一种常用方式就是检测某个参数时候是否等于 undefined，如果是则意味着没有传入这个参数，那就给他赋一个值

```js
 function makeKing(name){
            name=(typeof name !== 'undefined')? name:'henry';
            return `king ${name} VIII`;
        }
        console.log(makeKing());//'king henry VIII'
console.log(makeKing('Louis'));//'king Louis VIII'
```

es6因为支持显式定义默认参数。只要在函数定义中的参数后面用 = 就可以为参数赋一个默认值

下面就是与前面代码等价的es6写法

```js
 function makeKing(name ="henry") {
         return `king ${name}VIII`
        }
        console.log(makeKing('Louis'));//king Louis VIII
        console.log(makeKing()); //king henry VIII
```

给参数传undefined相当于没有传值，不过这样可以利用多个独立的默认值

```js
 function makeKing(name ="herny",numerals="VIII") {
            return `King ${name} ${numerals}`;
        }
        console.log(makeKing());//King herny VIII
        console.log(makeKing('Louis'));//King Louis VIII
        console.log(makeKing(undefined,'VI'));//King herny VI
```

在使用默认参数时，arguments对象的值不反映参数从默认值，只反映传给函数的参数。当然，跟es5严格模式一样，修改命名参数也不会影响arguments对象，他始终以调用函数时传入的值为准

```js
function makeKing(name = 'Henry') {
name = 'Louis';
return `King ${arguments[0]}`;
}
console.log(makeKing()); // 'King
undefined'
console.log(makeKing('Louis')); // 'King Louis'
```

默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值

```js
let romanNumerals = ['I','II','III','IV','V','VI'];
let ordinality = 0;
function getNumerals() {
    // 每次调用后递增
    return romanNumerals[ordinality++];
}
function makeKing(name = 'Henry', numerals =
    getNumerals()) {
    return `King ${name} ${numerals}`;
}
console.log(makeKing()); // 'KingHenry I'
console.log(makeKing('Louis','XVI')); //'KingLouisXVI'
console.log(makeKing()); // 'KingHenry II'
console.log(makeKing()); // 'KingHenry III'
```

函数的默认参数只有在函数被调用时才会求值，不会在函数定义是求值。而且，计算默认值的函数只有在调用函数但未传相应参数时才会被调用。

箭头函数同样也可以这样使用默认参数，在只有一个参数时，必须使用括号而不能省略了

```js
let makeKing = (name = 'Henry') => `King
${name}`;
console.log(makeKing()); // King Henry
```

### 默认参数作用域与暂时性死区

因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的

给多个参数定义默认值实际上跟使用let关键字顺序声明变量一样

```js
function makeKing(name = 'Henry'
, numerals =
'VIII') {
return `King ${name} ${numerals}`;
}
console.log(makeKing()); // King Henry VIII

//这里的默认参数会按照定义它们的顺序依次被初始化。可以按照如下实例想象一下这个过程：
function makeKing() {
let name = 'Henry';
let numerals = 'VIII';
return `King ${name} ${numerals}`;
}

```

因为参数是顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。

```js
function makeKing(name = 'Henry'
, numerals =
name) {
return `King ${name} ${numerals}`;
}
console.log(makeKing()); // King Henry Henry
```

参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。

```js
function makeKing(name = numerals, numerals =
'VIII') {
return `King ${name} ${numerals}`;
}
console.log(makeKing());//报错
```

参数也存在于自己的作用域中，他们不能引用函数体的作用域

```js
function makeKing(name = 'Henry'
, numerals =
defaultNumeral) {
let defaultNumeral = 'VIII';
return `King ${name} ${numerals}`;
}
console.log(makeKing());//报错
```

## 10.6.2 收集参数

在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。

这有点类似arguments 对象的构造机制，只不过收集参数的结果会得到一个Array实例

```js
function getSum(...values) {
// 顺序累加values中的所有值
// 初始值的总和为0
return values.reduce((x, y) => x + y, 0);
}
console.log(getSum(1,2,3)); // 6
```

如果前面还有命名参数，只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，只能把它作为最后一个参数

```js
function ignoreFirst(firstValue, ...values) {
console.log(values);
}
ignoreFirst(); // []
ignoreFirst(1); // []
ignoreFirst(1,2); // [2]
ignoreFirst(1,2,3); // [2, 3]
```

箭头函数虽然不支持 arguments对象，但支持收集参数的定义，因此也可以实现与使用arguments一样的逻辑

```js
let getSum = (...values) => {
return values.reduce((x, y) => x + y, 0);
}
console.log(getSum(1,2,3)); // 6
```

使用收集参数并不影响arguments对象，它仍然反映调用时传入函数的参数

```js
function getSum(...values) {
console.log(arguments.length); // 3
console.log(arguments); // [1, 2, 3]
console.log(values); // [1, 2, 3]
}
console.log(getSum(1,2,3));

```

## 10.9.1 arguments

arguments对象是一个类数组对象，包含调用函数时传入的所有参数。

arguments只有function关键字定义函数（相对于使用箭头语法创建函数）是才会有。主要用于包含函数参数，

arguments对象其实还有一个callee属性，是一个执行arguments对象所在函数的指针

看下面这个经典的阶乘函数

```js
function factorial(num) {
if (num <= 1) {
	return 1;
} else {
	return num * factorial(num - 1);
	}
}

```

阶乘函数一般定义成 递归 调用的，就像上面这个例子一样。之哟啊给函数一个名称，而且这个名称不会变，这样定义就没有问题。。

但是这个函数要正确执行就必须保证函数名是factorial，从而导致紧密耦合，使用arguments.callee就可以让函数逻辑与函数名解耦

```js
function factorial(num) {
if (num <= 1) {
	return 1;
} else {
	return num * arguments.callee(num - 1);
	}
}
console.log(factorial(5)); //120
```

这个重写之后的 factorial（）函数已经用arguments.callee代替了之前硬编码的factorial。这意味着无论函数叫什么名字，都可以引用正确的函数

考虑下面的情况：

```js
function factorial(num) {
if (num <= 1) {
	return 1;
} else {
	return num * arguments.callee(num - 1);
	}
}

let trueFactorial = factorial;
factorial = function() {
return 0;
};
console.log(trueFactorial(5)); // 120
console.log(factorial(5)); // 0
//这里，trueFactorial 变量被赋值为factorial，实际上把同一个函数的指针有保存到了另一个位置。然后，factorial函数又被重写为一个返回0的函数。
//如果想factorial()最初的版本那样不适用arguments.callee，那么像上面这样调用trueFactorial()就会返回0。不过，通过将函数与名称解耦，trueFactorial()就可以正确计算阶乘，而factorial()只能返回0；
```

## 10.9.3 caller

es5 会给函数对象上添加一个属性：caller。虽然es3中并没有定义，但所有浏览器除了早期版本的Opera都支持这个属性。

caller属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为null。

```js
function outer() {
inner();
}
function inner() {
console.log(inner.caller);
}
outer();// outer(){inner()}
//以上代码会显示outer()函数的源代码。这是因为ourter()调用了inner(),inner.caller指向outer().
```

如果要降低耦合度，则可以通过arguments.callee.caller来引用同样的值；

```js
function outer() {
inner();
}
function inner() {
console.log(arguments.callee.caller);
}
outer();
```

在严格模式下访问arguments.callee会报错。

es5也定义了arguments.caller,但在严格模式下访问它会报错，在非严格模式下则始终是undefined。这是为了分清arguments.caller 和函数的caller而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码

严格模式还有一个限制，不能给函数的caller属性赋值，否知会报错

## 10.12 递归

**递归函数**通常的形式是一个函数通过名称调用自己，如下面的例子所示：

```js
function factorial(num) {
if (num <= 1) {
	return 1;
} else {
	return num * factorial(num -1);
	}
}
//这是经典的递归阶乘函数。虽然这样写可以，
```

但如果把这个函数赋值给其他变量，就会出问题

```js
let anotherFactorial = factorial;
factorial = null;
console.log(anotherFactorial(4)); // 报错
//把factorial()函数保存在另一个变量anotherFactorial中，然后将factorial设置为null，只保留了一个对原始函数的引用。
//在调用anotherFactorial()时，要递归调用factorial(),但因为它已经不是函数了，所以会出错

//在写递归函数时使用arguments.callee可以避免这个问题。
//arguments.callee 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用，如下所示：
function factorial(num) {
if (num <= 1) {
	return 1;
} else {
	return num * arguments.callee(num - 1);
	}
}
//这样确保无论通过什么变量调用这个函数都不会出问题。因此编写递归函数时，arguments.callee是引用当前函数的首选
```

在严格模式 运行的代码是不能访问arguments.callee的，会报错。

可以使用命名函数表达式达到目的

```js
const factorial = (function f(num) {
if (num <= 1) {
	return 1;
} else {
	return num * f(num - 1);
}
});
factorial(5);//120
//这里创建命名函数表达式f(),然后将他赋值给了变量factorial。即是把函数赋值给另一个变量，函数表达式的名称f也不变，因此递归调用不会出问题。这个模式在严格模式和非严格模式下都可以使用
```

函数中调用函数自己，在使用递归的时候一定需要有结束递归的条件，否则就会变成死循环，直到浏览器崩溃。

```js
var data = [ {     name: "所有物品",     children: [         {             name: "水果",             children: [{name: "苹果", children: [{name: '青苹果'}, {name: '红苹果'}]}]         },         {             name: '主食',             children: [                 {name: "米饭", children: [{name: '北方米饭'}, {name: '南方米饭'}]}             ]         },         {             name: '生活用品',             children: [                 {name: "电脑类", children: [{name: '联想电脑'}, {name: '苹果电脑'}]},                 {name: "工具类", children: [{name: "锄头"}, {name: "锤子"}]},                 {name: "生活用品", children: [{name: "洗发水"}, {name: "沐浴露"}]}             ]         }  ]}]​//递归遍历实现var recursiveFunction = function(){    var str = ''    const getStr = function(list){        list.forEach(function(row){            if(row.children){                getStr(row.children)            }else {                str += row.name + ";"            }        })    }    getStr(data)    console.log(str)}recursiveFunction()//输出：青苹果;红苹果;北方米饭;南方米饭;联想电脑;苹果电脑;锄头;锤子;洗发水;沐浴露;
```

可以看到，递归的方式来实现的时候，我们只需要一个for循环，每次遍历接受到的数据，通过判断是否还有`children`，没有就代表是最后一级了，有就继续把`children`这个`list`传给函数继续遍历，最后就得到了我们想要的数据

#### 递归遍历实现排序

封装 利用递归实现的快速排序，效率很高

```js
var quickSort = function(arr) {
if (arr.length <= 1) {//如果数组长度小于等于1无需判断直接返回即可
    return arr;
}
var pivotIndex = Math.floor(arr.length / 2);//取基准点
var pivot = arr.splice(pivotIndex, 1)[0];//取基准点的值,splice(index,1)函数可以返回数组中被删除的那个数
var left = [];//存放比基准点小的数组
var right = [];//存放比基准点大的数组
for (var i = 0; i < arr.length; i++){ //遍历数组，进行判断分配
    if (arr[i] < pivot) {
        left.push(arr[i]);//比基准点小的放在左边数组
    } else {
        right.push(arr[i]);//比基准点大的放在右边数组
    }
}
//递归执行以上操作,对左右两个数组进行操作，直到数组长度为<=1；
return quickSort(left).concat([pivot], quickSort(right));
};

var arr = [14, 50, 80, 7, 2, 2, 11];
console.log(quickSort(arr));
```

 递归一般是在函数里面把函数自己给调用一遍，通过每次调用改变条件，来结束循环。
 递归在数据格式一致，在数据层级未知的情况下，比普通的遍历更有优势。
 递归在异步的时候，更容易理解，且更容易实现，因为可以在异步的回调里面，调用自己来实现每次都能拿到异步的结果再进行其他操作
 递归实现的快速排序比普通遍历实现的排序效率更好。

## 10.14 闭包

闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。

### 词法作用域

```js
function init() {
    var name = "隔壁龙赐"; // name 是一个被 init 创建的局部变量
    function Names() { // Names() 是内部函数，一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    Names();
}
init();
```

`init()` 创建了一个局部变量 `name` 和一个名为Names()的函数。`displayName()` 是定义在 `init()` 里的内部函数，并且仅在 init() 函数体内可用。请注意，Names() 没有自己的局部变量。因为它可以访问到外部函数的变量，所以 Names()可以使用父函数init()中声明的变量 name

优点

- 外部函数存储的变量可以存储在内存中，避免全局变量的污染

**缺点**

- 占用内存，造成内存泄露
- 父函数每调用一次，会形成不同的闭包
- 对捕获的变量是引用，不是复制

#### 思考

看看下面的参数和return返回结果

```js
function fun(){
     return console.log(arguments[1]) // ?
}
fun({"参数1":1},{"参数2":2},{"参数3":3})  
```

用arguments来判断当前传入参数的个数是否与我们需要的数量一致

```js
function add() {
	if( arguments.length == 2 ){
		return arguments[0] + arguments[1];
	}else{
		return '传入参数不合法';
	}
}
 
console.log( add(2,3) );  //?
console.log( add(1,2,3) ); //?
```

函数的属性length

```js
function fun(num,num1,num2){
    
}
function fun1(){
    
}
console.log(fun.length) // ？
console.log(fun1.length) // ？
```

函数的声明提升

```js
var test1;
	var test2 ;

	console.log(test0)// ？
	console.log(test1)// ？
	console.log(test2)// ？


	function test0 (){
		return 0
	}
	test1 =	function (){
		return 1
	}
	test2 = new Function ( "return 2")

```

递归：

```js
//求5个数字的和
//答:
var sum=0
for(var i=0;i<6;i++){
    sum=sum+i;
}
console.log(sum);
```

