# js1  关键字保留字

?            CMA-262描述了一组保留的关键字，这些关键字有特殊用途，
?     比如表示控制语句的开始和结束，或者执行特定的操作。按照规定，
?     保留的关键字不能用作标识符或属性名
?      break do in typeof case else instanceof var  catch  export  new ......

# 2   var    let  const 区别

   使用var时，这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部
   let跟var的作用差不多，但有着非常重要的区别。最明显的区别是，let声明的范围是块作用域，而var声明的范围是函数作用域，let与var的另一个重要的区别，
就是let声明的变量不会在作用域中被提升在let出现之前，for循环定义的迭代变量会渗透到循环体外，改成使用let之后，这个问题就消失了，因为迭代变量的作
用域仅限于for循环块内部
    const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。const声明的限制
只适用于它指向的变量的引用。换句话说， 如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。

# 3     数据类型

   ECMAScript有6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。
还有一种复杂数据类型叫Object（对象）。Object是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之
一来表示。只有7种数据类型似乎不足以表示全部数据。但ECMAScript的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。

# 4   typeof   undefined  null  boolean   number  string  Symbol

   typeof 对于基本数据类型判断是没有问题的，但是遇到引用数据类型（如：Array）是不起作用
   Undefined类型只有一个值，就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值
   Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因
   Boolean（布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值：true和false
   string字符串是不可变的，意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量
转换字符串方法 toString和string函数两种方法。
   Symbol（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。Symbol.hasInstance   Symbol.isConcatSpreadable   Symbol.iterator
Symbol.match     Symbol.replace   Symbol.search  Symbol.species   Symbol.split  Symbol.toPrimitive   Symbol.toStringTag   Symbol.unscopables

# 5  Object类型

?    ECMAScript中的对象其实就是一组数据和功能的集合。对象通过new操作符后跟对象类型的名称来创建。开发者可以通过创建Object类型的实例来创建自己的对象，然后再给
对象添加属性和方法
   object的实例本身并不是很有用，但理解与它相关的概念非常重要。类似Java中的java.lang.Object，ECMAScript中的Object也是派生其他对象的基类。Object类型的所有属性和
方法在派生的对象上同样存在

# 6 操作符

   一元操作符   位操作符（不太明白） 布尔操作符（逻辑与和逻辑或）  乘性操作符   指数操作符   加性操作符   关系操作符   相等操作符   条件操作符   赋值操作符  逗号操作符

# 7 语句

   if语句是使用最频繁的语句之一     do-while语句   while语句     for语句    for-in语句     for-of语句     标签语句      break和continue语句    with语句     switch语句

# 8函数

  函数对任何语言来说都是核心组件，因为它们可以封装语句，然后在任何地方、任何时间执行。要注意的是，只要碰到return语句，函数就会立即停止执行并退出。

# 9原始值与引用值

?     ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是最简单的数据，引用值（referencevalue）则是由多个值构成的对象。

     原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改
和删除其属性和方法。
     除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。
     在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个
变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来

# 10确定类型

?     typeof操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返回"object"
?     所有引用值都是Object的实例，因此通过instanceof操作符检测任何引用值和Object构造函数都会返回true。类似地，如果用instanceof检测原始值，则始终会返回false，因为原始值不是对象。

# 11执行上下文与作用域

?    执行上下文（以下简称“上下文”）的概念在JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object）
而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。
?    每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript
程序的执行流就是通过这个上下文栈进行控制的
?    上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用
域链的最前端。如果上下文是函数，则其活动对象（activationobject）用作变量对象。活动对象最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包
含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象
?    函数changeColor()的作用域链包含两个对象：一个是它自己的变量对象（就是定义arguments对象的那个），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量color，就是因为可以在
作用域链中找到它

# 12变量声明

?    ECMAScript 5.1，var都是声明变量的唯一关键字。ES6不仅增加了let和const两个关键字，而且还让这两个关键字压倒性地超越var成为首选
?    var
?    在使用var声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在with语句中，最接近的上
下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文
?    let
?    let关键字跟var很相似，但它的作用域是块级的，这也是JavaScript中的新概念。块级作用域由最近的一对包含花括号{}界定。换句话说，if块、
while块、function块，甚至连单独的块也是let声明变量的作用域。
?    let与var的另一个不同之处是在同一作用域内不能声明两次。重复的var声明会被忽略，而重复的let声明会抛出
?    const
?     ES6同时还增加了const关键字。使用const声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。
const声明只应用到顶级原语或者对象。换句话说，赋值为对象的const变量不能再被重新赋值为其他引用值，但对象的键则不受限制

# 13垃圾回收

?    JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源
?     1   标记清理
?           JavaScript最常用的垃圾回收策略是标记清理（mark-andsweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。
?     而不在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。
?     

     2 引用计数
             另一种没那么常用的垃圾回收策略是引用计数（referencecounting）。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。
       如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问
       到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存

# 14 性能

?    垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢
渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作


    由于调度垃圾回收程序方面的问题会导致性能下降，IE曾饱受诟病。它的策略是根据分配数，比如分配了256个变量、4096个对象/数组字面量和数组槽位（slot），或者64KB字符串
只要满足其中某个条件，垃圾回收程序就会运行。这样实现的问题在于，分配那么多变量的脚本，很可能在其整个生命周期内始终需要那么多变量，结果就会导致垃圾回收程序过于频繁
地运行。由于对性能的严重影响，IE7最终更新了垃圾回收程序。

   IE7发布后，JavaScript引擎的垃圾回收程序被调优为动态改变分配变量、字面量或数组槽位等会触发垃圾回收的阈值。IE7的起始阈值都与IE6的相同。如果垃圾回收程序回收的内存不
到已分配的15%，这些变量、字面量或数组槽位的阈值就会翻倍。如果有一次回收的内存达到已分配的85%，则阈值重置为默认值。这么一个简单的修改，极大地提升了重度依赖JavaScript
的网页在浏览器中的性能

# 15 内存管理

   在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，JavaScript运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多
分配给移动浏览器的就更少了。这更多出于安全考虑而不是别的，就是为了避免运行大量JavaScript的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用
栈以及能够同时在一个线程中执行的语句数量

# 16 小结

?     原始值大小固定，因此保存在栈内存上。从一个变量到另一个变量复制原始值会创建该值的第二个副本。
?     引用值是对象，存储在堆内存上。包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。从一个变量到另一个变量复制引用值只会复制指针，
因此结果是两个变量都指向同一个对象。typeof操作符可以确定值的原始类型，而instanceof操作符用于确保值的引用类型。
?     任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分








                                                                                                          基本引用类型
# 17  对象

?     对象被认为是某个特定引用类型的实例。新对象通过使用new操作符后跟一个构造函数（constructor）来创建。构造函数就是用来创建新对象的函数
?     Date类型将日期保存为自协调世界时（UTC，Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式，
Date类型可以精确表示1970年1月1日之前及之后285 616年的日期。 要创建日期对象，就使用new操作符来调用Date构造函数

    比如，要创建一个表示“2019年5月23日”的日期对象，可以使用以下代码：letsomeDate=newDate(Date.parse("May23,2019"));如果传给Date.parse()的
字符串并不表示日期，则该方法会返回NaN。如果直接把表示日期的字符串传给Date构造函数，那么Date会在后台调用Date.parse()

# 18继承方法

   Date类型重写了toLocaleString()、toString()和valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。Date类型的toLocaleString()方法返回
与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息（具体格式可能因浏览器而不
同）。toString()方法通常返回带时区信息的日期和时间，而时间也是以24小时制（0~23）表示的。下面给出了toLocaleString()和toString()返回的2019年2月1
日零点的示例（地区为"en-US"的PST，即Pacific Standard Time，太平洋标准时间）

    例如
     let data= new Date()
    console.log(data.toLocaleString()) //   2021/1/20 下午8:46:23
    console.log(data.toLocaleDateString())  //   2021/1/20
    console.log(data.toLocaleTimeString())   //下午8:52:54
    console.log(data.toUTCString())    //Wed, 20 Jan 2021 12:54:18 GMT

# 19 日期格式化方法

   Date类型剩下的方法（见下表）直接涉及取得或设置日期值的特定部分。注意表中“UTC日期”，指的是没有时区偏移（将日期转换为GMT）时的日期。

# 20 RegExp（正则）

   ECMAScript通过RegExp类型支持正则表达式。正则表达式使用类似Perl的简洁语法来创建
   g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
   i：不区分大小写，表示在查找匹配时忽略pattern和字符串的大小写。
  m：多行模式，表示查找到一行文本末尾时会继续查找。
  y：粘附模式，表示只查找从lastIndex开始及之后的字符串。
  u：Unicode模式，启用Unicode匹配。
  s：dotAll模式，表示元字符.匹配任何字符（包括\n或\r）

# 21   RegExp实例属性

  每个RegExp实例都有下列属性，提供有关模式的各方面信息。
  global：布尔值，表示是否设置了g标记。ignoreCase：布尔值，表示是否设置了i标记。
  unicode：布尔值，表示是否设置了u标记。sticky：布尔值，表示是否设置了y标记。
  lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从0开始。
  multiline：布尔值，表示是否设置了m标记。dotAll：布尔值，表示是否设置了s标记。
  source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
  flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。

# 22   RegExp构造函数属性

?    RegExp构造函数本身也有几个属性。（在其他语言中，这种属性被称为静态属性。）这些属性适用于作用域
中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。这些属性还有一个特点，就是可以通过两
种不同的方式访问它们。换句话说，每个属性都有一个全名和一个简写。下表列出了RegExp构造函数的属性

# 23 模式局限

?    虽然ECMAScript对正则表达式的支持有了长足的进步，但仍然缺少Perl语言中的一些高级特性。

# 24 原始值包装类型

   为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：Boolean、Number和String。
这些类型具有本章介绍的其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。
每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法

# 25 Boolean

  Boolean是对应布尔值的引用类型。要创建一个Boolean对象，就使用Boolean构造函数并传入true或false，
  我们创建一个值为false的Boolean对象。然后，在一个布尔表达式中通过&&操作将这个对象与一个原始值
true组合起来。在布尔算术中，false&&true等于false。可是，这个表达式是对falseObject对象而不是对它
表示的值（false）求值。前面刚刚说过，所有对象在布尔表达式中都会自动转换为true，因此falseObject在这
个表达式里实际上表示一个true值。那么true&&true当然是true。

  原始值和引用值（Boolean对象）还有几个区别。首先，typeof操作符对原始值返回"boolean"，但对引用值
返回"object"。同样，Boolean对象是Boolean类型的实例，在使用instaceof操作符时返回true，但对原始值则返回false

# 26  Number

  Number是对应数值的引用类型。要创建一个Number对象，就使用Number构造函数并传入一个数值
  与Boolean类型一样，Number类型重写了valueOf()、toLocaleString()和toString()方法。valueOf()方
法返回Number对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示
基数的参数，并返回相应基数形式的数值字符串
   除了继承的方法，Number类型还提供了几个用于将数值格式化为字符串的方法。
   toFixed()方法返回包含指定小数点位数的数值字符串
   这里的toFixed()方法接收了参数2，表示返回的数值字符串要包含两位小数。结果返回值为"10.00"，小数位填充了0。如果数值本身的小数位超过了参数指定的位数，则四舍五入到最接近的小数位
   letnum=10.005;   console.log(num.toFixed(2));//"10.01"
   原始数值在调用typeof时始终返回"number"，而Number对象则返回"object"。类似地，Number对象是Number类型的实例，而原始数值不是
    isInteger()方法与安全整数
   ES6新增了Number.isInteger()方法，用于辨别一个数值是否保存为整数。有时候，小数位的0可能会让人误以为数值是一个浮点值

# 27  String

   String是对应字符串的引用类型。要创建一个String对象，使用String构造函数并传入一个数值
  String对象的方法可以在所有字符串原始值上调用。3个继承的方法valueOf()、toLcaleString()和toString()都返回对象的原始字符串值。
每个String对象都有一个length属性，表示字符串中字符的数量。

# 28   字符串操作方法

?    concat()，用于将一个或多个字符串拼接成一个新字符串，虽然concat()方法可以拼接字符串，但更常用的方式是使用加号操作符（+）。
而且多数情况下，对于拼接多个字符串来说，使用加号更方便。
   slice()、substr()和substring()。这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。第一个参数表示子字符串
开始的位置，第二个参数表示子字符串结束的位置。对slice()和substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提
取出来）。对substr()而言，第二个参数表示返回的子字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。

# 29   字符串位置方法

   有两个方法用于在字符串中定位子字符串：indexOf()和lastIndexOf()。这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，
indexOf()方法从字符串开头开始查找子字符串，而lastIndexOf()方法从字符串末尾开始查找子字符串

   如果字符串中只有一个"o"，则indexOf()和lastIndexOf()返回同一个位置。这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个
参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符
 let stringValue="helloworld";   console.log(stringValue.indexOf("o"));//4       console.log(stringValue.lastIndexOf("o"));//7


   在传入第二个参数6以后，结果跟前面的例子恰好相反。这一次，indexOf()返回7，因为它从位置6（字符"w"）开始向后搜索字符串，在位置7找到了"o"。而lastIndexOf()返回4
，因为它从位置6开始反向搜索至字符串开头，因此找到了"hello"中的"o"。像这样使用第二个参数并循环调用indexOf()或lastIndexOf()，就可以在字符串中找到所有的目标子字符串
letstringValue="helloworld";console.log(stringValue.indexOf("o",6));//7console.log(stringValue.lastIndexOf("o",6));//4
    

# 30 字符串包含方法

   ECMAScript 6增加了3个用于判断字符串中是否包含另一个字符串的方法：startsWith()、endsWith()和includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示
是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引0的匹配项，endsWith()检查开始于索引(string.length-substring.length)的匹配项，而includes()检查整个字符串

  startsWith()和includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符
  endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样


  trim()方法
  CMAScript在所有字符串上都提供了trim()方法。这个方法会创建字符串的一个副本，删除前、后所有空格符，再返回结果

  repeat()方法
  ECMAScript在所有字符串上都提供了repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果

  padStart()和padEnd()方法
  padStart()和padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格

# 31 字符串迭代与解构

# 32 字符串大小写转换

?    下一组方法涉及大小写转换，包括4个方法：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。toLowerCase()和toUpperCase()方法是原来就有的方法，
与java.lang.String中的方法同名。toLocaleLowerCase()和toLocaleUpperCase()方法旨在基于特定地区实现。在很多地区，地区特定的方法与通用的方法是一样的。但在少数语言中（如土耳其语）
，Unicode大小写转换需应用特殊规则，要使用地区特定的方法才能实现正确转换。

# 33字符串模式匹配方法

  match()方法返回的数组与RegExp对象的exec()方法返回的数组是一样的：第一个元素是与整个模式匹配的字符串，其余元素则是与表达式中的捕获组匹配的字符串（如果有的话）。另一个查找模式
的字符串方法是search()。这个方法唯一的参数与match()方法一样：正则表达式字符串或RegExp对象。这个方法返回模式第一个匹配的位置索引，如果没找到则返回-1。search()始终从字符串开头向后匹配模式



# 35 Object

   到目前为止，大多数引用值的示例使用的是Object类型。Object是ECMAScript中最常用的类型之一。虽然Object的实例没有多少功能，但很适合存储和在应用程序间交换数据。显式地创建Object的实例有两种方式
。第一种是使用new操作符和Object构造函数，另一种方式是使用对象字面量（object literal）表示法

# 36Array

   创建数组几种方式
   1 使用Array构造函数
   创建数组时可以给构造函数传一个值。这时候就有点问题了，因为如果这个值是数值，则会创建一个长度为指定数值的数组；而如果这个值是其他类型的，则会创建一个只包含该特定值的数组

   2另一种创建数组的方式是使用数组字面量（array literal）表示法。数组字面量是在中括号中包含以逗号分隔的元素列表

   Array构造函数还有两个ES6新增的用于创建数组的静态方法：from()和of()。from()用于将类数组结构转换为数组实例，而of()用于将一组参数转换为数组实例
   Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构
   Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数
中this的值。但这个重写的this值在箭头函数中不适用 
   Array.of()可以把一组参数转换为数组。这个方法用于替代在ES6之前常用的Array.prototype.slice.call(arguments)，一种异常笨拙的将arguments对象转换为数组的写法

# 37数组索引

  要取得或设置数组的值，需要使用中括号并提供相应值的数字索引
  length设置为大于数组元素数的值，则新添加的元素都将以undefined填充

# 38 检测数组

  个经典的ECMAScript问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用instanceof操作符就足矣
   使用instanceof的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的Array构造函数。如果要把数组从一个框架
传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。为解决这个问题，ECMAScript提供了Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不
用管它是在哪个全局执行上下文中创建的

  Array的原型上暴露了3个用于检索数组内容的方法：keys()、values()和entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而entries()返回索引/值对的迭代器
  批量复制方法fill()，以及填充数组方法copyWithin()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法创建的数组不能缩放。
使用fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。
也可以将负索引想象成数组长度加上它得到的一个正索引


  有对象都有toLocaleString()、toString()和valueOf()方法。其中，valueOf()返回的还是数组本身。而toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，
对数组的每个值都会调用其toString()方法，以得到最终的字符串
  toLocaleString()方法也可能返回跟toString()和valueOf()相同的结果，但也不一定。在调用数组的toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，
为了得到最终的字符串，会调用数组每个值的toLocaleString()方法，而不是toString()方法

# 39 数组排序

   数组有两个方法可以用来对元素重新排序：reverse()和sort()。顾名思义，reverse()方法就是将数组元素反向排列
   在给sort()方法传入比较函数后，数组中的数值在排序后保持了正确的顺序。
  slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则slice()会返回该索引到数组末尾的所有元素。
如果有两个参数，则slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组
  splice()的主要目的是在数组中间插入元素，但有3种不同的方式使用这个方法
  删除。需要给splice()传2个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如splice(0,2)会删除前两个元素。
  插入。需要给splice()传3个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2,0,"red","green")会从数组位置2开始插入字符串"red"和"green"。
  替换。splice()在删除元素的同时可以在指定位置插入新元素，同样要传入3个参数：开始位置、要删除元素的数量和要插入的任意

# 40 搜索和位置方法

  ECMAScript提供了3个严格相等的搜索方法：indexOf()、lastIndexOf()和includes()。其中，前两个方法在所有版本中都可用，而第三个方法是ECMAScript 7新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和includes()方法从数组前头
（第一项）开始向后搜索，而lastIndexOf()从数组末尾（最后一项）开始向前搜索。indexOf()和lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，
会使用全等（===）比较，也就是说两项必须严格相等

  ind()和findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部this的值。



# 41定型数组

  Float32Array实际上是一种“视图”，可以允许JavaScript运行时访问一块名为ArrayBuffer的预分配内存。ArrayBuffer是所有定型数组及视图引用的基本单位。
  定型数组是另一种形式的ArrayBuffer视图。虽然概念上与DataView接近，但定型数组的区别在于，它特定于一种ElementType且遵循系统原生的字节序。相应地，定型数组提供了适用面更广的API和更高的性能。设计定型数组的目的就是提高与WebGL等原生库交换二进制数据
的效率。由于定型数组的二进制表示对操作系统而言是一种容易使用的格式，JavaScript引擎可以重度优化算术运算、按位运算和其他对定型数组的常见操作，因此使用它们速度极快
  创建定型数组的方式包括读取已有的缓冲、使用自有缓冲、填充可迭代结构，以及填充基于任意类型的定型数组。

  定型数组与普通数组都很相似。定型数组支持如下操作符、方法和属性：[]copyWithin()entries()every()fill()filter()find()findIndex()forEach()indexOf()join()keys()lastIndexOf()lengthmap()reduce()reduceRight()reverse()slice()some()sort()toLocaleString()toString()values()

# 42合并、复制和修改定型数组

   定型数组同样使用数组缓冲来存储数据，而数组缓冲无法调整大小

# 43 Map

  ECMAScript 6以前，在JavaScript中实现“键/值”式存储可以使用Object来方便高效地完成，也就是使用对象属性作为键，再使用属性来引用值。但这种实现并非没有问题，为此TC39委员会专门为“键/值”存储定义了一个规范。作为ECMAScript 6的新增特性，Map是一种
新的集合类型，为这门语言带来了真正的键/值存储机制。Map的大多数特性都可以通过Object类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个，还是值得细细甄别。

  如果想在创建的同时初始化实例，可以给Map构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象中的每个键/值对都会按照迭代顺序插入到新映射实例中
  初始化之后，可以使用set()方法再添加键/值对。另外，可以使用get()和has()进行查询，可以通过size属性获取映射中的键/值对的数量，还可以使用delete()和clear()删除值。

# 44

   与Object类型的一个主要差异是，Map实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。映射实例可以提供一个迭代器（Iterator），能以插入顺序生成[key,value]形式的数组。可以通过entries()方法（或者Symbol.iterator属性，它引用entries()）取得这个迭代器

# 45基本API

  弱映射中的键只能是Object或者继承自Object的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。如果想在初始化时填充弱映射，则构造函数可以接收一个可迭代对象，其中需要包含键/值对数组。

# 46 弱键

  WeakMap中“weak”表示弱映射的键是“弱弱地拿着”的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是“弱弱地拿着”的。只要键存在，键/值对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收

# 47 对象、类与面向对象编程

   创建自定义对象的通常方式是创建Object的一个新实例，然后再给它添加属性和方法
   例
   letperson=newObject();person.name="Nicholas";person.age=29;person.job="SoftwareEngineer";person.sayName=function(){console.log(this.name);};

   修改
   letperson={name:"Nicholas"};
  这里，我们创建了一个名为name的属性，并给它赋予了一个值"Nicholas"。这意味着[[Value]]特性会被设置为"Nicholas"，之后对这个值的任何修改都会保存这个位置。
  要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述
符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值
  letperson={};Object.defineProperty(person,"name",{writable:false,value:"Nicholas"});console.log(person.name);//"Nicholas"person.name="Greg";console.log(person.name);//"Nicholas"
  把configurable设置为false，意味着这个属性不能从对象上删除。非严格模式下对这个属性调用delete没有效果，严格模式下会抛出错误。此外，一个属性被定义为不可配置之后，就不能再变回可配置的了

# 48访问器属性

   访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。
在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为。
  [[Configurable]]：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true。
  [[Enumerable]]：表示属性是否可以通过for-in循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是true。
  [[Get]]：获取函数，在读取属性时调用。默认值为undefined。
  [[Set]]：设置函数，在写入属性时调用。默认值为undefined。

# 49 定义多个属性在一个对象上同时定义多个属

  在一个对象上同时定义多个属性的可能性是非常大的。为此，ECMAScript提供了Object.defineProperties()方法。这个方法可以通过多个描述符一次性定义多个属性。它接收两个参数：要为之添加或修
改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应

```js
letbook={};Object.defineProperties(book,{year_:{value:2017},edition:{value:1},year:{get(){returnthis.year_;},set(newValue){if(newValue>2017){this.year_=newValue;this.edition+=newValue-2017;}}}});
```

## 50对象标识及相等判定

在ECMAScript 6之前，有些特殊情况即使是===操作符也无能为力

```javascript
//这些是===符合预期的情况console.log(true===1);//falseconsole.log({}==={});//falseconsole.log("2"===2);//false//这些情况在不同JavaScript引擎中表现不同，但仍被认为相等console.log(+0===-0);//trueconsole.log(+0===0);//trueconsole.log(-0===0);//true//要确定NaN的相等性，必须使用极为讨厌的isNaN()console.log(NaN===NaN);//falseconsole.log(isNaN(NaN));//true
```

# 51对象解构

 ECMAScript 6新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简单地说，对象解构就是使用与对象匹配的结构来实现对象属性赋值。

```javascript
letperson={name:'Matt',age:27};let{name:personName,age:personAge}=person;
```

# 52创建对象

工厂模式

  工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。

```javascript
functioncreatePerson(name,age,job){leto=newObject();o.name=name;o.age=age;o.job=job;o.sayName=function(){console.log(this.name);};returno;}letperson1=createPerson("Nicholas",29,"SoftwareEngineer");letperson2=createPerson("Greg",27,"Doctor");

```

函数createPerson()接收3个参数，根据这几个参数构建了一个包含Person信息的对象。可以用不同的参数多次调用这个函数，每次都会返回包含3个属性和1个方法的对象。这种工厂模式虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题

# 53构造函数模式

ECMAScript中的构造函数是用于创建特定类型对象的。像Object和Array这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。

```javascript
functionPerson(name,age,job){this.name=name;this.age=age;this.job=job;this.sayName=function(){console.log(this.name);};}letperson1=newPerson("Nicholas",29,"SoftwareEngineer");letperson2=newPerson("Greg",27,"Doctor");person1.sayName();//Nicholasperson2.sayName();//Greg

```

在这个例子中，Person()构造函数代替了createPerson()工厂函数。实际上，Person()内部的代码跟createPerson()基本是一样的，

# 54构造函数与普通函数区别

构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个函数定义为构造函数的特殊语法。任何函数只要使用new操作符调用就是构造函数，而不使用new操作符调用的函数就是普通函数。



# 55 构造函数的问题

构造函数虽然有用，但也不是没有问题。构造函数的主要问题在于，其定义的方法会在每个实例上都创建一遍。因此对前面的例子而言，person1和person2都有名为sayName()的方法，但这两个方法不是同一个Function实例

# 56原型模式

每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型

##        理解原型

?    无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为constructor的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor指向Person。然后，因构造函数而异，可能会给原型对象添加其他属性和方法。在自定义构造函数时，原型对象默认只会获得constructor属性，其他的所有方法都继承自Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但Firefox、Safari和Chrome会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。

# 57继承

 继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript中是不可能的，因为函数没有签名。实现继承是ECMAScript唯一支持的继承方式，而这主要是通过原型链实现的

# 58原型链

ECMA-262把原型链定义为ECMAScript的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链

# 59原型链的问题

 原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性

# 60组合继承

组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性

# 61原型式继承

# 62寄生式继承

# 63寄生式组合继承

# 64类

类（class）是ECMAScript中新的基础性语法糖结构，因此刚开始接触时可能会不太习惯。虽然ECMAScript 6类表面上看起来可以支持正式的面向对象编程，但实际上它背后使用的仍然是原型和构造函数的概念。

# 65类定义

与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用class关键字加大括号

```javascript
//类声明classPerson{}//类表达式constAnimal=class{};
```

与函数表达式类似，类表达式在它们被求值前也不能引用。不过，与函数定义不同的是，虽然函数声明可以提升，但类定义不能

另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制

# 66类的构成

类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。

与函数构造函数一样，多数编程风格都建议类名的首字母要大写，以区别于通过它创建的实例（比如，通过classFoo{}创建实例foo）

类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符

# 67类构造函数

constructor关键字用于在类定义块内部创建类的构造函数。方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，不定义构造函数相当于将构造函数定义为空函数。



类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符。而普通构造函数如果不使用new调用，那么就会以全局的this（通常是window）作为内部对象。调用类构造函数时如果忘了使用new则会抛出错误

# 68实例、原型和类成员

1. ## 实例成员

   每次通过new调用类标识符时，都会执行类构造函数。在这个函数内部，可以为新创建的实例（this）添加“自有”属性。至于添加什么样的属性，则没有限制。另外，在构造函数执行完毕后，仍然可以给实例继续添加新成员。每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享

##  2原型方法与访问器

   为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法

## 3静态类方法

可以在类上定义静态方法。这些方法通常用于执行不特定于实例的操作，也不要求存在类的实例。与原型成员类似，每个类上只能有一个静态成员。静态类成员在类定义中使用static关键字作为前缀。在静态成员中，this引用类自身。其他所有约定跟原型成员一样

#### 4非函数原型和类成员

虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加

# 69继承

1. 继承基础ES6类支持单继承。使用extends关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）：

2. 构造函数、HomeObject和super()

   派生类的方法可以通过super关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用super可以调用父类构造函数。

# 第十章

## 10.1 箭头函数

 1  ECMAScript 6新增了使用胖箭头（=>）语法定义函数表达式的能力。很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数

例如

1. ```js
   letarrowSum=(a,b)=>{returna+b;};
   letfunctionExpressionSum=function(a,b){returna+b;};
   console.log(arrowSum(5,8));//13
   console.log(functionExpressionSum(5,8));//13
   ```

2 如果只有一个参数，那也可以不用括号。只有没有参数，或者多个参数的情况下，才需要使用括号

```
//两种写法都有效
letdouble=(x)=>{return2*x;};
lettriple=x=>{return3*x;};

//没有参数需要括号
letgetRandom=()=>{returnMath.random();};
//多个参数需要括号
letsum=(a,b)=>{returna+b;};
//无效的写法：
letmultiply=a,b=>{returna*b;};
```

3 箭头函数虽然语法简洁，但也有很多场合不适用。箭头函数不能使用arguments、super和new.target，也不能用作构造函数。此外，箭头函数也没有prototype属性



//思考

箭头函数和普通函数区别  //？

## 10.3理解参数

### 普通函数参数

ECMAScript函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。之所以会这样，主要是因为ECMAScript函数的参数在内部表现为一个数组。函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。事实上，在使用function关键字定义（非箭头）函数时，可以在函数内部访问arguments对象，从中取得传进来的每个参数值。

例如

```js
function sayHi(name,message){
   console.log("Hello"+name+","+message);
}
sayHi('小明','你好')

//可以通过arguments[0]取得相同的参数值。因此，把函数重写成不声明参数也可以
function sayHi(){
   console.log("Hello"+arguments[0]+","+arguments[1])
}
sayHi('小明','你好')

//两者效果一样
```

doAdd()在只传一个参数时会加10，在传两个参数时会将它们相加，然后返回。因此doAdd(10)返回20，而doAdd(30,20)返回50。虽然不像真正的函数重载那么明确，但这已经足以弥补ECMAScript在这方面的缺失了

```js
functiondoAdd(){
    if(arguments.length===1){console.log(arguments[0]+10);
}elseif(arguments.length===2{
        console.log(arguments[0]+arguments[1]);
}
doAdd(10);//20
doAdd(30,20);//50
```

arguments对象可以跟命名参数一起使用

例如

```js
function doAdd(num1,num2){
   if(arguments.length===1){
   console.log(num1+10);
   }elseif(arguments.length===2){
   console.log(arguments[0]+num2);
   }
}
doAdd(1) //11
doAdd(1,2) //3
```

arguments对象的另一个有意思的地方就是，它的值始终会与对应的命名参数同步

```js
function doAdd(num1,num2){
    arguments[1]=10;console.log(arguments[0]+num2);
}

doAdd(1,2)
```

doAdd()函数把第二个参数的值重写为10。因为arguments对象的值会自动同步到对应的命名参数，所以修改arguments[1]也会修改num2的值

### 箭头函数参数

1 如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用arguments关键字访问，而只能通过定义的命名参数访问

例如

```js
function foo(){console.log(arguments[0]);}
foo(5);//5
let bar=()=>{console.log(arguments[0]);};
bar(5);//ReferenceError:arguments is notdefined  报错
```

2 虽然箭头函数中没有arguments对象，但可以在包装函数中把它提供给箭头函数

例如

```js
function foo(){
    letbar=()=>{
        console.log(arguments[0]);//5
    };
    bar();
}
foo(5) 
```

## 10.5默认参数值

在ECMAScript5.1及以前，实现默认参数的一种常用方式就是检测某个参数是否等于undefined，如果是则意味着没有传这个参数，那就给它赋一个值

例如

```js
function makeKing(name){
    name=(typeofname!=='undefined')?name:'Henry';
    return`King${name}VIII`;
}
console.log(makeKing());//'KingHenryVIII'
console.log(makeKing('Louis'));//'KingLouisVIII
```

ECMAScript 6之后就不用这么麻烦了，因为它支持显式定义默认参数了。下面就是与前面代码等价的ES6写法，只要在函数定义中的参数后面用=就可以为参数赋一个默认值

例如

```js
functionmakeKing(name='Henry'){
         return`King${name}VIII`;
}
console.log(makeKing('Louis'));//'KingLouisVIII'
console.log(makeKing());//'KingHenryVIII'
```

给参数传undefined相当于没有传值，不过这样可以利用多个独立的默认值

```js
 function makeKing(name = 'Henry', numerals = 'VIII'){ 
        return `King${name}${numerals}`; 
 } 
 console.log(makeKing());//'King Henry VIII'
 console.log(makeKing('Louis'));//'King Louis VIII'
 console.log(makeKing(undefined,'VI'));//'King Henry VI'
```

在使用默认参数时，arguments对象的值不反映参数的默认值，只反映传给函数的参数

```js
function makeKing(name='Henry'){
   name='Louis';
   return`King${arguments[0]}`;
}
console.log(makeKing());//'Kingundefined'
console.log(makeKing('Louis'));//'KingLouis'
```

### 默认参数作用域与暂时性死区

因为在求值默认参数时可以定义对象，也可以动态调用函数，所以函数参数肯定是在某个作用域中求值的

给多个参数定义默认值实际上跟使用let关键字顺序声明变量一样。

例如

```js
function makeKing(name='Henry',numerals='VIII'){
    return`King${name}${numerals}`;
}
console.log(makeKing());//KingHenryVIII
```

因为参数是按顺序初始化的，所以后定义默认值的参数可以引用先定义的参数。

```js
function makeKing(name='Henry',numerals=name){
    return`King${name}${numerals}`;
}
console.log(makeKing());//KingHenryHenry
```

参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的。

```js
function makeKing(name=numerals,numerals='VIII'){
    return`King${name}${numerals}`;
}
//报错
```

## 10.6.2收集参数

在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似arguments对象的构造机制，只不过收集参数的结果会得到一个Array实例。

```js
function getSum(...values){
    //顺序累加values中的所有值//初始值的总和0
    returnvalues.reduce((x,y)=>x+y,0);
}
console.log(getSum(1,2,3));//6
```

箭头函数虽然不支持arguments对象，但支持收集参数的定义方式，因此也可以实现与使用arguments一样的逻辑

```js
let getSum=(...values)=>{
    returnvalues.reduce((x,y)=>x+y,0);
}
console.log(getSum(1,2,3));//6 
```

另外，使用收集参数并不影响arguments对象，它仍然反映调用时传给函数的参数

```js
function getSum(...values){
	console.log(arguments.length);//3
	console.log(arguments);//[1,2,3]
	console.log(values);//[1,2,3]
}
console.log(getSum(1,2,3));
```

## 10.9.1 arguments

arguments对象，它是一个类数组对象，包含调用函数时传入的所有参数。这个对象只有以function关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包含函数参数，但arguments对象其实还有一个callee属性，是一个指向arguments对象所在函数的指针

例如

```js
function factorial(num){
    if(num<=1){
        return1;
    }else{
        returnnum*factorial(num-1);
    }
}
```

  使用arguments.callee就可以让函数逻辑与函数名解耦

```js
function factorial(num){
    if(num<=1){
        return1;
    }else{
        returnnum*arguments.callee(num-1);
    }
}
```

## 10.9.3caller（不太明白）

ECMAScript 5也会给函数对象上添加一个属性：caller。虽然ECMAScript 3中并没有定义，但所有浏览器除了早期版本的Opera都支持这个属性。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为null

```js
function outer() {
        inner();
}
function inner() {
        console.log(inner.caller);
}
outer();
```

以上代码会显示outer()函数的源代码。这是因为ourter()调用了inner()，inner.caller指向outer()。如果要降低耦合度，则可以通过arguments.callee.caller来引用同样的值

```
function outer(){
	inner();
}
functioninner(){
	console.log(arguments.callee.caller);
}
outer()
```

在严格模式下访问arguments.callee会报错。ECMAScript 5也定义了arguments.caller，但在严格模式下访问它会报错，在非严格模式下则始终是undefined。这是为了分清arguments.caller和函数的caller而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码。严格模式下还有一个限制，就是不能给函数的caller属性赋值，否则会导致错误。

## 10.12递归

递归函数通常的形式是一个函数通过名称调用自己

代码演示

```js
function factorial(num){
    if(num<=1){
        return1;
    }else{
        returnnum*factorial(num-1);
    }
}
```

，但如果把这个函数赋值给其他变量，就会出问题

```js
let anotherFactorial=factorial;
factorial=null;
console.log(anotherFactorial(4));//报错
```

这里把factorial()函数保存在了另一个变量anotherFactorial中，然后将factorial设置为null，于是只保留了一个对原始函数的引用。而在调用anotherFactorial()时，要递归调用factorial()，但因为它已经不是函数了，所以会出错。



在写递归函数时使用arguments.callee可以避免这个问题。arguments.callee就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用

```js
function factorial(num){
    if(num<=1){
        return1;
    }else{
        returnnum*arguments.callee(num-1);
    }
}
```

把函数名称替换成arguments.callee，可以确保无论通过什么变量调用这个函数都不会出问题。因此在编写递归函数时，arguments.callee是引用当前函数的首选。

## 10.14闭包

##### 概念

闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。

##### 代码演示

```js
function createComparisonFunction(propertyName){
    return function(object1,object2){
        letvalue1=object1[propertyName];
        letvalue2=object2[propertyName];
        if(value1<value2){
            return-1;
        }else if(value1>value2){
            return1;
        }else{
            return0;
        }
    };
}
let result=compare(5,10);
```

这里加粗的代码位于内部函数（匿名函数）中，其中引用了外部函数的变量propertyName。在这个内部函数被返回并在其他地方被使用后，它仍然引用着那个变量。这是因为内部函数的作用域链包含createComparisonFunction()函数的作用域





函数执行时，每个执行上文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着compare()函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在createComparisonFunction()函数中，匿名函数的作用域链中实际上包含createComparisonFunction()的活动对象。



##### 个人总结

js的作用域分两种，全局和局部，基于我们所熟悉的作用域链相关知识，我们知道在js作用域环境中访问变量的权利是由内向外的，内部作用域可以获得当前作用域下的变量并且可以获得当前包含当前作用域的外层作用域下的变量，反之则不能，也就是说在外层作用域下无法获取内层作用域下的变量，同样在不同的函数作用域中也是不能相互访问彼此变量的，那么我们想在一个函数内部也有限权访问另一个函数内部的变量该怎么办呢？闭包就是用来解决这一需求的，闭包的本质就是在一个函数内部创建另一个函数。

###### 闭包三个特性

***1函数嵌套函数***

***2函数内部可以引用函数外部的参数和变量***

***3参数和变量不会被垃圾回收机制回收***

###### 思考

```
function fn(){
        var num=3
        return function(){
            var n=0;
            console.log(++n)
            console.log(++num)
        }
 }
 var fn1=fn()
 fn1()
 fn1()
```

# 第十一章    期约与异步函数

**ECMAScript 6新增了正式的Promise（期约）引用类型，支持优雅地定义和组织异步逻辑。接下来几个版本增加了使用async和await关键字定义异步函数的机制**

## 11.1异步编程

?	单线程事件循环模型中，同步操作与异步操作更是代码所要依赖的核心机制。异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的****

### 11.1.1同步与异步

**同步操作**

同步：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。如果在函数A返回的时候，调用者就能够得到预期的结果（即拿到了预期的返回值或者看到了预期的效果），那么这个函数就是同步的

**异步操作**

异步不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。如果在函数A返回的时候，调用者还不能马上得到预期的结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的 

*最基础的异步是setTimeout和setInterval函数，很常见，但是很少人有人知道其实这就是异步，因为它们可以控制js的执行顺序。我们也可以简单地理解为：可以改变程序正常执行顺序的操作就可以看成是异步操作。如下代码*

```js
 console.log( "1" );
 setTimeout(function() {
      console.log( "2" )
 }, 0 );
 setTimeout(function() {
      console.log( "3" )
 }, 0 );
 setTimeout(function() {
      console.log( "4" )
 }, 0 );
 console.log( "5" );

//请自己写一个简单的异步操作  ？
```

### 11.1.2以往的异步编程模式

异步行为是JavaScript的基础，但以前的实现不理想。在早期的JavaScript中，只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回调地狱”）来解决

例如

```
function double(value) { 
   setTimeout(() => setTimeout(
      console.log, 0, value * 2  //不太明白此行代码
   ), 1000); 
 } 
double(3) //6
```

1. **异步返回值**

   假设setTimeout操作会返回一个有用的值。有什么好办法把这个值传给需要它的地方？广泛接受的一个策略是给异步操作提供一个回调，这个回调中包含要使用异步返回值的代码（作为回调的参数）

   代码

   ```js
   function double(value, callback) {
           setTimeout(() => callback(value * 2), 1000);
   }
   double(3, (x) => console.log(`Iwasgiven:${x}`));
   //Iwasgiven:6（大约1000毫秒之后）
   ```

2. **失败处理**

异步操作的失败处理在回调模型中也要考虑，因此自然就出现了成功回调和失败回调

```js
	function double(value, success, failure) {
        setTimeout(() => {
            try {
                if (typeofvalue !== 'number') {
                    throw 'Mustprovidenumberas firstargument';
                } success(2 * value);
            } catch (e) { failure(e); }
        }, 1000);
    }
    constsuccessCallback = (x) => console.log(`Success:${x}`);
    constfailureCallback = (e) => console.log(`Failure:${e}`);
    double(3, successCallback, failureCallback);
    double('b', successCallback, failureCallback);
    //Success:6（大约1000毫秒之后）
    //Failure:Mustprovide number as firstargument（大约1000毫秒之后）
```

## 11.2期约

### 11.2.1Promises/A+规范

ECMAScript 6增加了对Promises/A+规范的完善支持，即Promise类型。一经推出，Promise就大受欢迎，成为了主导性的异步编程机制。所有现代浏览器都支持ES6期约，很多其他浏览器API（如fetch()和电池API）也以期约为基础

### 11.2.2期约基础

ECMAScript 6新增的引用类型Promise，可以通过new操作符来实例化。创建新期约时需要传入执行器（executor）函数作为参数（后面马上会介绍），下面的例子使用了一个空函数对象来应付一下解释器

```js
 let p=new Promise(()=>{});setTimeout(console.log,0,p);//Promise  <pending>
```

**注  setTimeout 只是模拟异步操作，并不是真正的异步操作**

### **promise是什么？**

1、主要用于异步计算
2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果
3、可以在对象之间传递和操作promise，帮助我们处理队列



### 为什么会有promise？

**为了避免界面冻结（任务）**

同步：假设你去了一家饭店，找个位置，叫来服务员，这个时候服务员对你说，对不起我是“同步”服务员，我要服务完这张桌子才能招呼你。那桌客人明明已经吃上了，你只是想要个菜单，这么小的动作，服务员却要你等到别人的一个大动作完成之后，才能再来招呼你，这个便是同步的问题：也就是“顺序交付的工作1234，必须按照1234的顺序完成”。



异步：则是将耗时很长的A交付的工作交给系统之后，就去继续做B交付的工作，。等到系统完成了前面的工作之后，再通过回调或者事件，继续做A剩下的工作。
 AB工作的完成顺序，和交付他们的时间顺序无关，所以叫“异步”。



### promise有三个状态：

1、pending[待定]初始状态
2、fulfilled[实现]操作成功
3、rejected[被否决]操作失败

#### 参数

resolve作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
reject作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去

##### Promise对象的状态改变，只有两种可能：

从pending变为fulfilled
从pending变为rejected。
这两种情况只要发生，状态就凝固了，不会再变了。

**简单案例**

```js
new Promise(resolve => {
  setTimeout(() => {
    resolve('hello')
  }, 2000)
}).then(res => {
  console.log(res)
})
```

##### 

**分两次顺序执行**

```js
new Promise(resolve => {
    setTimeout(() => {
      resolve('hello')
    }, 2000)
  }).then(val => {
    console.log(val) //  参数val = 'hello'
    return new Promise(resolve => {
      setTimeout(() => {
        resolve('world')
      }, 2000)
    })
  }).then(val => {
    console.log(val) // 参数val = 'world'
  })
```

##### 

**promise完成后then()**

```js
let pro = new Promise(resolve => {
   setTimeout(() => {
     resolve('hello world')
   }, 2000)
 })
 setTimeout(() => {
   pro.then(value => {
   console.log(value) // hello world
 })
 }, 2000)
```

## 11.3异步函数

异步函数，也称为“async/await”（语法关键字），是ES6期约模式在ECMAScript函数中的应用。async/await是ES8规范新增的。这个特性从行为和语法上都增强了JavaScript，让以同步方式写的代码能够异步执行。

```js
let p=new Promise((resolve,reject)=>
        setTimeout(resolve,1000,3)
 );
```

### 11.3.1异步函数

ES8的async/await旨在解决利用异步结构组织代码的问题。为此，ECMAScript对函数进行了扩展，为其增加了两个新关键字：async和await。

**1 async**     关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上

```js
async function foo(){}
letbar=async function(){};
letbaz=async()=>{};class Qux{async qux(){}}
```

使用async关键字可以让函数具有异步特征，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通JavaScript函数的正常行为。

2. **await**

   因为异步函数主要针对不会马上完成的任务，所以自然需要一种暂停和恢复执行的能力。使用await关键字可以暂停异步函数代码的执行，等待期约解决

   ```js
      let p = new Promise((resolve, reject) =>
           setTimeout(resolve, 1000, 3)
       );
       p.then((x) => console.log(x));//3
   
   //使用async/await可以写成这样
     async function foo() {
           let p = new Promise((resolve, reject) =>
               setTimeout(resolve, 1000, 3)
           );
           console.log(awaitp);
       }
       foo();//3
   ```

   1. await后面接一个会return new promise的函数并执行它

   2. await只能放在async函数里

      例如

      使用async和await获取成功的结果

      ``` js
      	function 摇色子() {
              return new Promise((resolve, reject) => {
                  let sino = parseInt(Math.random() * 6 + 1)
                  setTimeout(() => {
                      resolve(sino)
                  }, 3000)
              })
          }
          async function test() {
              let n = await 摇色子()
              console.log(n)
          }
          test()
      ```

      上面这段代码async中使`await 摇色子()`先执行，等到三秒后执行完再把得到的结果赋值给左边的n，也就是说test函数需要三秒钟才执行完成，所以test函数是异步的，因此前面必须写async

      获取失败的结果

      ```js
      function 摇色子(猜测) {
              return new Promise((resolve, reject) => {
                  let sino = parseInt(Math.random() * 6 + 1)
                  if (sino > 3) {
                      if (猜测 === '大') {
                          resolve(sino)
                      } else {
                          reject(sino)
                      }
                  } else {
                      if (猜测 === '大') {
                          reject(sino)
                      } else {
                          resolve(sino)
                      }
                  }
                  setTimeout(() => {
                      resolve(sino)
                  }, 300)
              })
          }
          async function test() {
              try {
                  //把await及获取它的值的操作放在try里
                  let n = await 摇色子('大')
                  console.log('赢了' + n)
              } catch (error) {
                  //失败的操作放在catch里
                  console.log('输了' + error)
              }
          }
          test()
      ```

      

      把await和成功后的操作放到try里，失败的放在catch

      - 为什么要用await
        为了使我们的异步代码，更像同步的代码

要完全理解await关键字，必须知道它并非只是等待一个值可用那么简单。JavaScript运行时在碰到await关键字时，会记录在哪里暂停执行。等到await右边的值可用了，JavaScript运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。因此，即使await后面跟着一个立即可用的值，函数的其余部分也会被异步求值。

**思考打印结果**

```js
    async function foo(){
        console.log(2);
        await null;
        console.log(4);
    }
    console.log(1);
    foo();
    console.log(3);
   
```

**11.3.3异步函数策略**（不懂）

因为简单实用，所以异步函数很快成为JavaScript项目使用最广泛的特性之一。不过，在使用异步函数时，还是有些问题要注意。

1. 实现sleep()

   很多人在刚开始学习JavaScript时，想找到一个类似Java中Thread.sleep()之类的函数，好在程序中加入非阻塞的暂停。以前，这个需求基本上都通过setTimeout()利用JavaScript运行时的行为来实现的。有了异步函数之后，就不一样了。一个简单的箭头函数就可以实现sleep()：

2. 利用平行执行

3. 串行执行期约

4. 栈追踪与内存管理